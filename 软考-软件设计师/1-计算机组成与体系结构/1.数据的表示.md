参考：

https://zhuanlan.zhihu.com/p/99082236



### 一、进制的转换

---

#### R进制转10进制（按权展开法）

将每一位数字用 `R^k` 表示然后相加，k与该位与小数点的距离有关，小数点左边第一位为0，右边第一位为-1，往左递增，网往右递减。

> 如：二进制数 10100.01 = `1*2^4+1*2^2+1*2^-2`

#### 十进制转R进制

- 整数位采用**除R倒取余法**，直至商为零；
- 小数位采用**乘R取整法**，每乘一次R就取它的整数位（ 整数位为零时就取零)，直至小数位为零，然后将取得的整数位由上往下排列。

>如：(20.25)~10~ 
>
>20/2=10...0
>
>10/2=5...0
>
>5/2=2...1
>
>2/2=1...0
>
>1/2=0...1
>
>`10100`
>
>0.25*2=0.5
>
>0.5*2=1.0
>
>`10`
>
>`10100.10`

#### 二进制转八进制（取三合一法）

将二进制数以小数点为界向左及向右每三个一组，接着将三个二进制按权相加，得到的数就是一位八位二进制数，按顺序进行排列，小数点的位置不变；

>如：(10100.10)~2~ = (?)~8~
>
><u>010</u> <u>100</u> . <u>100</u> --------> (2 4 . 4)~8~

举一反三，八进制转二进制（取一分三法）：将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。

掌握二进制与八进制的关系：

| 二进制数 | 八进制数 |
| -------- | -------- |
| 000      | 0        |
| 001      | 1        |
| 010      | 2        |
| 011      | 3        |
| 100      | 4        |
| 101      | 5        |
| 110      | 6        |
| 111      | 7        |

二进制每一个三位就表示一个八位，所以都是三个数一组。

#### 二进制转十六进制（取四合一法）

每四个一组，缺的数用零来补充，然后依次转化为相应的进制数然后按顺序排列即可。

>如：(10100.10)~2~ = (?)~16~
>
><u>0001</u> <u>0100</u> . <u>1000</u> --------> (E . 8)~16~

举一反三，十六进制转二进制（取一分四法）

掌握二进制与十六进制的关系：

| 二进制 | 十六进制 |
| ------ | -------- |
| 0000   | 0        |
| 0001   | 1        |
| 0010   | 2        |
| 0011   | 3        |
| 0100   | 4        |
| 0101   | 5        |
| 0110   | 6        |
| 0111   | 7        |
| 1000   | 8        |
| 1001   | 9        |
| 1010   | A        |
| 1011   | B        |
| 1100   | C        |
| 1101   | D        |
| 1110   | E        |
| 1111   | F        |



### 二、原码、反码、补码、移码

---

原码、反码、补码的产生过程就是为了解决计算机做减法和引入符号位的问题。

#### 原码

将一个十进制转换为二进制数，并且该二进制数的**首位表示正负，0表示正，1表示负**，==不足八位的就在首位与二进制数中间用零填充==。如-1的原码是 `1`0000001

>原码的表示法很简单，虽然出现了+0和-0，但是直观易懂。于是开始运算。
>
>0001 + 0010 = 0011，1 + 2 = 3
>
>0000 + 1000 = 1000，+0 + (-0) = -0
>
>0001 + 1001 = 1010，1 + (-1) = -2
>
>可以看到正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

#### 反码

原码最大的问题就在于一个数加上它的相反数不等于0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

**正数的反码为本身**，**负数的反码为其原码除首位不变外全部取反**，即零变为一，一变为零。如`1`0000001 的反码是 `1`1111110

>再试着用反码的方式解决一下原码的问题
>
>0001 + 1110 = 1111，1 + (-1) = -0
>
>1110 + 1100 = 1010，(-1) + (-3) = -5
>
>互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加的出错了。

**反码表示在计算机中往往作为数码变换的中间环节。**

#### 补码

**正数的补码与原码相同**，**负数的补码即为其反码加一**（补码的运算符合正确答案）。

>接下来做一做四位二进制数的减法（先不引入符号位）。
>
>0110-0010，6-2=4，但是由于计算机中没有减法器，没法算。
>
>这时候，想想时钟运算中，减去一个数，是可以等同于加上另外一个正数（同余数），这个数与减数相加正好等于模。
>
>也就是四位二进制数最大容量是多少？2^4=16（10000）
>
>那么-2的同余数，就等于10000-0010=1110，16-2=14。
>
>既然如此，0110 - 0010 = 0110 + 1110 = 10100，6 - 2 = 6 + 14 = 20
>
>按照这种算法得出的结果是10100，但是对于四位二进制数最大只能存放4位，如果低四位正好是0100，正好是想要的结果，至于最高位的1，计算机会把它放入psw寄存器进位位中，8位则会放在cy中，x86会放在cf中。
>
>这个时候，再想想在四位二进制数中，减去2就相当于加上它的同余数（至于它们为什么同余，还是建议看《计算机组成原理》）。
>
>但是减去2，从另一个角度来说，也是加上-2，即加上-2和加上14得到的二进制结果除了进位位，结果是一样的。如果我们把1110的最高位看作符号位后就是-2的补码，**这可能也是为什么负数的符号位是1，而不是0**。
>
>由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此**计算机中均采用补码进行加减运算**。

![img](1.%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA.assets/v2-15756f4b9ee904787eefefdfdda748ff_1440w.jpg)

#### 移码

将正数和负数的补码首位取反，其余位不改变（移码的运算也符合正确答案）。

#### 各自数值表示范围

其中n一般等于8

|      | 整数                 |
| ---- | -------------------- |
| 源码 | -(2^n-1^-1)~2^n-1^-1 |
| 反码 | -(2^n-1^-1)~2^n-1^-1 |
| 补码 | -2^n-1^~2^n-1^-1     |



### 三、浮点数运算

---

浮点数的概念：浮点数即科学计数法，如1000=1X10^3^；其中，1为尾数，10为基数，3为指数。

计算机中浮点数的运算：当两个指数不等的浮点数相加时，计算机会**把低阶浮点数的指数转化为高阶浮点数的指数**。

如：1.0X10^3^+1.19X10^2^，计算机会将1.19X10^2^转化为0.119X10^3^，然后作和，然后结果格式化(即通过指数的转化**保证尾数必须为非零的一位数**)如：0.1119X10^3^+1.119X10^2^；得到11.3019X10^3^以后，要化为1.13019X10^4^。
