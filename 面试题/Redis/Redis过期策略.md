Redis 是怎么删除过期的 key，而且 Redis 是单线程的，删除 key 会不会造成阻塞。

**Redis采用的是定期删除 + 懒惰删除策略。**



#### 1. 定期删除策略

---

> Redis会将每个设置了过期时间的key放入到一个独立的字典中，默认每100ms进行一次过期扫描：
>
> 1. ==随机抽取20个key==；
> 2. 删除这20个key中过期的key；
> 3. 如果过期的key比例超过1/4，就重复步骤1，继续删除。

>**为什么不扫描所有的key？**
>
>Redis是单线程，全部扫描岂不是卡死了。==为了防止每次扫描过期的key比例都超过1/4，导致不停循环卡死线程，Redis为每次扫描添加了上限时间，默认是25ms==。
>
>如果客户端将超时时间设置的比较短，比如 10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常。而且这时你还无法从 Redis 的 slowlog 中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。
>
>如果在同一时间出现大面积 key 过期，Redis 循环多次扫描过期词典，直到过期的 key 比例小于 1/4。这会导致卡顿，而且在高并发的情况下，可能会导致缓存雪崩。

>**为什么Redis为每次扫描的上限时间是25ms，还会出现上面的情况？**
>
>==Redis是单线程，每个请求处理都需要排队==，而且由于Redis每次扫描都是25ms，也就是每个请求最多25ms，100个请求就是2500ms。
>
>==如果有大批量的key过期，要给过期时间设置一个随机范围==，而不宜全部在同一时间过期，分散过期处理的压力。



#### 2. 从库的过期策略

---

从库不会进行过期扫描，从库对过期的处理是被动的。主库在key到期时，会在AOF文件里增加一条del命令，同步到所有的从库，从库通过执行这条del指令在删除过期的key。

因为指令同步是异步进行的，所以主库过期的key的del指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在。



#### 3. 惰性删除策略

---

==在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西==。

>**为什么要惰性删除？**
>
>del指令会直接释放对象的内存，大部分情况下，这个指令非常快，没有明显延迟。不过如果删除的key是一个非常大的对象，比如一个包含了千万元素的hash，又或者在使用FLUSHDB和FLUSHALL删除包含大量键的数据库时，那么删除操作就会导致单线程卡顿。
>
>redis 4.0引入==懒惰删除的机制==，==可以将删除键或数据库操作放在后台线程里执行，从而尽可能避免服务器阻塞==。

>`unlink`
>
>能对删除操作进行懒处理，丢给后台线程来异步回收内存。
>
>---
>
>`flush`
>
>flushdb 和 flushall 指令，用来清空数据库，这也是极其缓慢的操作。Redis 4.0 同样给这两个指令也带来了异步化，在指令后面增加 `async `参数。

>**异步队列**
>
>主线程将对象的引用从【大树】中摘除后，会将这个key的内存回收操作包装成一个任务，塞进异步任务队列，后台线程会从这个异步队列中取任务。任务队列被主线程和异步线程同时操作，所以必须是一个线程安全的队列。
>
>==不是所有的unlink操作都会延后处理，如果对应key所占用的内存很小，延后处理就没有必要了，这时候Redis会将对应的key内存立即回收==。



#### 4. 内存淘汰机制

---

> Redis提供了redis.config中的配置参数`maxmemory`来限制最大使用内存。当超出最大使用内存时，提供了以下几种内存淘汰策略：
>
> - **noeviction：**当内存超出 maxmemory，写入请求会报错，但是删除和读请求可以继续。（使用这个策略，疯了吧）
> - ==**allkeys-lru：**当内存超出 maxmemory，在所有的 key 中，移除最少使用的key。只把 Redis 既当缓存是使用这种策略。（推荐）。==
> - **allkeys-random：**当内存超出 maxmemory，在所有的 key 中，随机移除某个 key。
> - **volatile-lru：**当内存超出 maxmemory，在设置了过期时间 key 的字典中，移除最少使用的 key。把 Redis 既当缓存，又做持久化的时候使用这种策略。
> - **volatile-random：**当内存超出 maxmemory，在设置了过期时间 key 的字典中，随机移除某个key。
> - **volatile-ttl：**当内存超出 maxmemory，在设置了过期时间 key 的字典中，优先移除 ttl 小的。



#### 5. LRU算法（Least Recently Used-最近最少使用）

---

><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq7ckdtwaoj30830cgt8n.jpg" style="zoom:80%">
>
>1. 新增key-value：首先==在链表结尾添加Node节点==，如果超过LRU设置的阈值就==淘汰队头的节点并删除掉HashMap中对应的节点==。
>2. 修改key对应的值：先修改对应的Node中的节点，然后把Node节点移动队尾。
>3. 访问key对应的值：把访问的Node节点移动到队尾即可。

>**Redis的近似LRU**
>
>Redis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。==每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟==。
>
>比如我现在要进行LRU，那么==首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰==，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。
>
>Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。



#### 6. LFU（Least Frequently Used-最少使用）

---

按最近的访问频率进行淘汰，比LFU更加精准地表示一个key被访问的热度。

>**Redis对象的热度**
>
>Redis的所有对象结构中都有一个24bit的字段，这个字段用来记录对象的热度。
>
>```c
>// redis 的对象头
>typedef struct redisObject {
>  unsigned type:4; // 对象类型如 zset/set/hash 等等
>  unsigned encoding:4; // 对象编码如 ziplist/intset/skiplist 等等
>  unsigned lru:24; // 对象的「热度」
>  int refcount; // 引用计数
>  void *ptr; // 对象的 body
>} robj;
>```
>
>在 LFU 模式下，lru 字段 24 个 bit 用来存储两个值，分别是 ldt(last decrement time) 和 logc(logistic counter)。
>
>logc 是 8 个 bit，用来存储访问频次，因为 8 个 bit 能表示的最大整数值为 255，存储频次肯定远远不够，所以这 8 个 bit 存储的是频次的对数值，并且这个值还会随时间衰减。如果它的值比较小，那么就很容易被回收。为了确保新创建的对象不被回收，新对象的这 8 个 bit 会初始化为一个大于零的值，默认是 LFU_INIT_VAL=5。
>
>ldt 是 16 个位，用来存储上一次 logc 的更新时间，因为只有 16 位，所以精度不可能很高。它取的是分钟时间戳对 2^16 进行取模，大约每隔 45 天就会折返。
>
>同 LRU 模式一样，我们也可以使用这个逻辑计算出对象的空闲时间，只不过精度是分钟级别的。图中的 server.unixtime 是当前 redis 记录的系统时间戳，和 server.lruclock 一样，它也是每毫秒更新一次。

