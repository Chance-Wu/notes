#### 1. 缓存雪崩

---

通常，会使用缓存用于缓冲对DB的冲击，如果缓存宕机，所有请求将直接打在DB，造成DB宕机——导致整个系统宕机。（缓存每秒可抗住1万请求；Mysql每秒抗住2000请求）

>解决办法：
>
>- 对缓存做==高可用==，防止缓存宕机；
>- 使用==断路器==，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入DB，保证部分可用，其余的请求返回断路器的默认值。



#### 2. 缓存穿透

---

>1. 缓存查询一个没有的key，同时数据库也没有，如果黑客大量使用这种方式，那么就会导致DB宕机。
>
>解决办法：
>
>可以使用一个==默认值==来防止。例如，当访问一个不存在的key，然后再去访问数据库，还是没有，那么久在缓存放一个占位符，下次来的时候，检查这个占位符，如果发生占位符，就不去数据库查询了。

>2. 大量请求查询一个刚刚失效的key，导致DB压力倍增，可能宕机，实际上，查询的都是相同的数据。
>
>解决办法：
>
>可以在这些请求代码加上==双重检查锁==。但是那个阶段的请求会变慢。不过总比DB宕机好。



#### 3. 缓存并发竞争

---

多个客户端写一个key，如果顺序错了，数据就不对了。但是无法控制顺序。

>==使用分布式锁==，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳。



#### 4. 缓存和数据库双写不一致

---

同时写数据库和缓存，但是操作期间，出现并发，数据不一致。

>方法一：
>
>==先更新数据库，再更新缓存==
>
>并发写的时候有问题

>方法二：
>
>==先删缓存，再更新数据库==
>
>如果在删除缓存后，有客户端读取数据，将可能读到旧的数据，并有可能设置到缓存中，导致缓存中的数据一致是老数据。

>方法三：（常用）
>
>Cache Aside Pattern
>
>- 读：先读缓存，没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应；
>- 更新：先更新数据库，然后再删除缓存。