Java虚拟机层面所暴露给我们的状态，与操作系统底层的线程状态是两个不同层面的事。具体而言，这里说的Java线程状态均来自于`Thread`类下的`State`这一内部枚举类中所定义的状态：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq9tz7tk8hj30gc0c4jrf.jpg" style="zoom:60%">



#### 1. RUNNABLE状态

---

一个在Java中==执行==的线程处于这一状态中。

而传统的线程状态一般划分如下：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq9u2p65quj30jk07r0sy.jpg" style="zoom:60%">

>**runnable与图中的ready与running区别在哪呢？**
>
>- 处于`runnbale`状态下的线程正在JVM中执行，但它==可能正在等待==来自于操作系统的其他资源（比如处理器）。显然runnable实质上包括了ready状态。
>- 对Java线程而言，不存在所谓的running状态，它的runnable状态包含了`running`状态。

>**为什么JVM中不去区分ready和running状态呢？**
>
>现在的==时分==（time-sharding）==多任务==（multi-task）操作系统架构通常是所谓的“==时间分片==”方式进行==抢占式==轮转调度。
>
>复杂的可能还会加入==优先级（priority）机制==。
>
>这个时间分片通常是很小的，一个线程一次最多只能在cpu上运行比如10-20ms的时间（此时处于running状态），时间片用后就要被切换下来放入调度度列的末尾等待再次调度。（即回到ready状态）
>
>==在此期间如果进行了I/O操作还会导致提前释放时间分片，并进入等待队列==。又或者是时间分片没有用完就被抢占，这时也是回到ready状态。
>
>这一切换的过程称为==上下文切换==（context switch），当然cpu不是简单地把线程踢开就完了，还需要把被相应的执行状态保存到内存中以便后续的恢复执行。
>
>不计切换开销（每次在1ms 以内），相当于1秒内有50-100次切换。事实上时间片经常没用完，线程就因为各种原因被中断，实际发生的切换次数还会更多。
>
>==单核CPU上实现所谓的“并发”的基本原理，其实是快速切换所带来的假象==。多核CPU才有可能实现真正意义上的并发。
>
>通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分ready与running就没什么太大的意义了。当你看到监控上显示时running时，对应的线程可能早就被切换下去了，甚至又再次地切换了上来。
>
>==主流的JVM实现都把Java线程一一映射到操作系统底层的线程上，把调用委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装==。JVM本身没有做什么实质的调用，把底层的ready即running状态映射上来也没有多大意义，因此，统一称为runnable状态是不错的选择。
>
>Java线程状态的改变通常只与自身显示引入的机制有关。



#### 2. 当 I/O 阻塞时

---

传统的I/O都是==阻塞式（blocked）==的，原因是I/O操作比起cpu来是在是太慢了。如果让cpu去等I/O的操作，会导致cpu的利用率极低。

解决办法：

- ==一旦线程中执行到I/O有关的代码，相应线程立马切走，然后调度ready队列中另一个线程来运行==。
- 这时，==执行I/O的线程会被放到所谓的等待队列中==，处于图中的waiting状态。与此同时，硬盘在努力工作。
- ==当I/O完成时，则用中断（interrupt）机制来通知CPU==。
- ==cpu 会收到一个比如说来自硬盘的中断信号==，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 ready 队列，这时 cpu 可能会选择它来执行。
- 所谓时间分片轮转本质上也是由一个定时器定时中断来驱动的，可以使线程从running回到ready状态。（比如设置一个10ms的倒计时，时间一到就发一个中断，然后重置倒计时，如此循环。）

>Java中的线程状态，也有`BLOCKED`、`WAITING`、`TIMED_WAITING`。
>
>**那么进行阻塞式I/O操作时，Java的线程状态究竟是什么？**
>
>其实状态还是`RUNNABLE`。
>
>网络阻塞时同理，比如socket.accept，这是一个阻塞式方法，但是线程还是`RUNNBALE`。



#### 3.如何看待 RUNNABLE 状态

---

分清 ==虚拟机层面== / ==操作系统层面==

>当进行阻塞式的IO操作时，获取底层的操作系统线程确实处于阻塞状态，但是我们关心的是JVM的线程状态。==JVM将cpu、硬盘、网卡等都视作资源，有东西在为线程服务，它就认为线程在“执行”==。
>
>处于阻塞时，只是cpu不在执行线程了，但网卡可能还在监听，虽然可能暂时还没收到数据。所以JVM任务线程还在执行。而操作系统的线程状态是围绕着cpu这一核心去诉说的，与JVM侧重点不同。

>Java线程状态的改变只与自身显式引入的机制有关，如果JVM中的线程状态发生了改变，通常是自身机制引发的。（比如==synchronize 机制有可能让线程进入BLOCKED 状态==，==sleep，wait等方法则可能让其进入 WATING 之类的状态==。）
>
><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq9wo07f3qj30jz0bawes.jpg" style="zoom:60%">
>
>`RUNNABLE` 状态对应了传统的 `ready， running 以及部分的 waiting 状态`。



#### 4. nio下线程状态

>

































