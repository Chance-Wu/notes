#### 1. 创建线程的方式

---

- 继承`Thread`类
- 实现`Runnable`接口
- 应用程序可以使用`Executor`框架来创建线程池（推荐）



#### 2. 线程的几种状态

---

- **新建（new）**：新创建一个线程对象。
- **可运行（runnable）**：有了线程对象后，其他线程（main）调用了该对象的`start()`方法。==该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权==。
- **运行（running）**：可运行状态的线程获得了CPU时间片，执行程序代码。
- **阻塞（block）**：阻塞状态是指线程因为某种原因放弃了CPU使用权，让出了CPU时间片，暂时停止运行。直到线程进入可运行状态，才有机会再次获得CPU时间片。
  - ==等待阻塞==：运行的线程执行`wait()`方法，JVM会把该线程放入等待队列中；
  - ==同步阻塞==：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中；
  - ==其他阻塞==：运行的线程执行`Thread.sleep()`或`join()`方法，或者发出了I/O请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，<u>线程重新转入可运行( runnable )状态</u>。
- **死亡（dead）**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。



#### 3. 同步方法和同步代码块的区别

---

- 同步方法默认用this或者当前类class对象作为锁；
- 同步代码块可以选择以什么来加锁，比同步方法更细粒度，可以选择只同步会发生同步问题的部分代码而不是整个方法；



#### 4. 监视器内部如何做线程同步

---

监视器和锁在Java虚拟机中是一块使用的。==监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块==。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

两种锁方案：<u>*显式监视器（Lock）*</u>和<u>*隐式监视器synchronized*</u>



#### 5. 什么是死锁——deadlock

---

两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。



#### 6. 如何确保N个线程可以访问N个资源同时又不导致死锁

---

多线程产生死锁的四个必要条件：

- 互斥条件：一个资源每次只能被一个进程使用；
- 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放；
- 不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺；
- 循环等待（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系。

> 一种避免死锁的方式：**指定获取锁的顺序，并强制线程按照指定的顺序获取锁。**因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

