Java语言是一种单继承结构语言，Object类是所有类的共同祖先。

#### 1. registerNatives()

---

为了使JVM发现本机功能，他们被一定的方式命名。例如，对于`java.lang.Object.registerNatives`，对应的C函数命名为`Java_java_lang_Object_registerNatives`。

通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），可以命名任何你想要你的C函数。(非重点)



#### 2. clone()

---

clone()函数的用途是用来另存一个当前存在的对象。==只有实现了Cloneable接口才可以调用该方法==，否则抛出CloneNotSupportedException异常。（注意：回答这里时可能会引出设计模式的提问）



#### 3. getClass()

---

final方法，==用于获得运行时的类型==。该方法返回的是此Object对象的类对象/运行时类对象Class。==效果与Object.class相同==。（注意：回答这里时可能会引出类加载，反射等知识点的提问）



#### 4. equals()

---

equals用来比较两个对象的内容是否相等。默认情况下(继承自Object类)，equals和==是一样的，除非被覆写(override)了。（注意：这里可能引出更常问的“equals与==的区别”及hashmap实现原理的提问）



#### 5. hashCode()

---

该方法用来返回其所在对象的==物理地址（哈希码值）==，常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。（同样，可能引出hashmap实现原理的提问）



#### 7. wait()

---

==导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法==。（引出线程通信及“wait和sleep的区别”的提问）



#### 8. wait(long timeout)

---

导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。（引出线程通信及“wait和sleep的区别”的提问）



#### 9. wait(long timeout, int nanos)

---

导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。（引出线程通信及“wait和sleep的区别”的提问）



#### 10. notify()

---

唤醒在此对象监视器上等待的单个线程。（引出线程通信的提问）



#### 11. notifyAll()

---

唤醒在此对象监视器上等待的所有线程。（引出线程通信的提问）



#### 12. finalize()

---

当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。（非重点，但小心引出垃圾回收的提问）



#### 13. “==”与“equals()”的区别

---

>  **== 运算符**
>
> 1. `==`可以使用在==基本数据类型==变量和==引用数据类型==变量中；
> 2. 比较基本数据类型：比较的是两个变量保存的==数据==是否相等。（不一定要类型相同）
> 3. 比较引用数据类型：比较的是两个对象的==地址值==是否相同（两个引用是否指向同一个对象实体）

>**equals()方法**
>
>1. 只适用于引用数据类型
>2. Object类中的`"equals()"`和`"=="`的作用是相同的：比较两个对象的地址值是否相同。
>3. ==String、Date、File、包装类==都重写了equals()方法，比较两个对象的“==实体内容==”是否相同。



#### 14. wait()方法与sleep()的区别

---

- `wait`指线程处于进入等待状态，形象地说明为“==等待使用CPU==”，此线程==不占用任何资源，不增加时间限制==。（Object类的方法）
- `sleep`指线程被调用时，==占着CPU不工作==，此时，==系统的CPU部分资源被占用，其他线程无法进入，会增加时间限制==。（Thread类的方法）



#### 15. 为什么重写了equals就必须重写hashCode

---

1. 不被重写（原生）的hashCode值是根据内存地址换算出来的一个值。
2. 不被重写（原生）的equals方法是严格判断一个对象是否相等的方法（object1 == object2）。

>Object.hashCode的通用约定：
>
>1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。
>2. 如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。
>3. 如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。

