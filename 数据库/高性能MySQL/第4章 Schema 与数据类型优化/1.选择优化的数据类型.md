>- 一般情况下，尽量使用可以正确存储数据的最小数据类型。
>- 简单数据类型的操作通常需要更少的CPU周期。例如，==整型比字符操作代价更低==，因为字符集和校对规则使字符比较比整型更复杂。（使用MySQL内建的类型而不是字符窜来存储日期和时间，另外一个应该用整型存储IP地址。）
>- 尽量避免NULL。可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间。==如果计划在列上建索引，就应该尽量避免设计成可为NULL的列==。InnoDB使用单独的bit存储NULL值，对于很多值为NULL的情况有很好的空间效率。

>1. 确定合适的大类型：数字、字符串、时间等
>2. 选择具体类型。如DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。

#### 1. 整数类型

>如果存储整数，可以使用这几种整数类型：==tinyint（8），smallint（16），mdediumint（24），int（32），bigint（64）==。可以存储的值的范围从$-2^{(N-1)}$到$2^{(N-1)}-1$，其中N是存储空间的位数。
>
>整数类型有可选的`UNSIGNED属性`，表述==不允许负值==。这大致可以使整数的上限提高一倍。如TINYINT.UNSIGNED可以存储的范围是0~255。
>
>MySQL可以为整数类型指定==宽度==，例如int(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具==用来显示字符的个数==。

#### 2. 实数类型

>实数是带有小数部分的数字。不只是为了存储小数部分，也可以使用`decimal`存储比bigint还大的整数。MySQL既支持精确类型，也支持不精确类型。
>
>- ==`float`和`double`类型支持使用标准的浮点运算进行近似计算==。
>
>- ==`decimal`类型用于存储精确的小数，支持精确计算==。
>
>对于decimal列，可以指定小数点前后所允许的最大位数。MySQL将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。例如，==decimal(18,9)小数点两边将各存储9个数字，一共使用9个字节：小数点本身占1个字节。==
>
>`decimal类型`允许最多65个数字。==decimal只是一种存储格式。在计算中decimal会转换为double类型==。
>
>浮点类型在存储同样范围的值时，通常比decimal使用更少的空间。float使用4个字节；double使用8个字节，比float有更高的精度和更大的范围。==MySQL使用double作为内部浮点计算的类型。==
>
>因为需要额外的空间和计算开销，所以应该==尽量只在对小数进行精确计算时才使用decimal==——例如存储财务数据。==在数据量较大时，考虑使用bigint代替decimal，将需要存储的货币单位根据小数的位数乘以相应的倍数即可==。（比如假设要存储财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在bigint里，可以同时避免浮点存储计算的不精确和decimal精确计算代价高的问题。）

#### 3. 字符串类型

>支持多种字符传类型，每个字符串列可以定义自己的字符集和排序规则/校对规则（collation）。

##### 3.1 varchar和char类型

>varchar和char是两种最主要的字符串类型。这些值的存储和存储引擎的具体实现有关。
>
>存储引擎存储char或者varchar的方式在内存中和在磁盘上可能不一样，所以MySQL服务器从存储引擎读出的值可能需要转换为另一种存储格式。

>`varchar类型`用于存储可变长字符串。比定长更节省空间，因为它仅使用必要的空间。适用varchar的场景如下：
>
>- 字符串列的最大长度比平均长度大很多；
>- 列的更新很少，所以碎片不是问题；
>- 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。
>
>==在存储和检索varchar类型时会保留末尾空格==。

>`char类型`是定长的。==存储时会删除末尾空格==。适用以下场景：
>
>- 适合存储很短的字符串或者所有值都接近同一个长度；（MD5密码）
>- 对于经常变更的数据，char比varchar更好，==定长的char不容易产生碎片==。（例如用char(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是varchar(1)却需要两个字节，因为还有一个记录长度的额外字节）

>类似的还有binary和varbinary，它们存储的是二进制字符串（和常规字符串非常相似）。但是二进制字符串存储的是字节码而不是字符，填充binary采用的是\0（零字节）而不是空格，在检索时也不会去掉填充值。

##### 3.2 blob和text类型

>blob和text都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
>
>当blob和text值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。
>
>==只对`max_sort_length`字节而不是整个字符串做排序==。如果只需要排序前面一小部分字符，则可以减少`max_sort_length`的配置，或者使用`ORDER BY SUSDTRING(column, length)`。
>
>MySQL不能将blob和text列全部长度的字符串进行索引，也不能使用这些索引消除排序。

##### 3.3 使用enum代替字符串类型

>枚举列可以把一些不重复的字符串存储成一个预定义的集合。
>
>```sql
>CREATE TABLE enum_test(e ENUM('fish','apple','dog') NOT NULL);
>
>INSERT INTO enum_test(e) VALUES('fish'),('dog'),('apple');
>```
>
>MySQL在内部会==将每个值在列表中的位置保存为整数==，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。枚举字段是按照内部存储的整数进行排序的：
>
>```sql
>SELECT e FROM enum_test ORDER BY e;
>```
>
>| e     |
>| ----- |
>| fish  |
>| apple |
>| dog   |
>
>枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。

#### 4. 日期和时间类型

>MySQL能存储的最小粒度为秒。但是可以使用微妙级的粒度进行临时运算。

>**datetime**
>
>这个类型能保存范围的值，==从1001年到9999年==，精度为秒。它==把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中==，与时区无关。使用==8个字节==的存储空间。默认情况下，以一种可排序的、无歧义的格式显示datetime值。
>
>**timestamp**
>
>这个类型能保存范围的值，==从1970年1月1日午夜（格林尼治时间）以来的秒数==，它和UNIX时间戳相同。使用==4个字节==的存储空间，因此它的范围比datetime小得多：只能表示从1970年到2038年。MySQL提供了`FROM_UNIXTIME()`函数把Unix时间戳转换为日期，并提供了`UNIX_TIMESTAMP()`函数把日期转换为Unix时间戳。timestamp显示的值依赖于时区。

>除了特殊行为之外，通常也应该尽量使用timestamp，因为它比datetime空间效率更高。
>
>如果需要存储比秒更小粒度的日期和时间值怎么办？
>
>- ==可以使用bigint类型存储微妙级别的时间戳==
>- ==或者使用double存储秒之后的小数部分==

#### 5. 位数据类型

>位类型不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。
>
>**bit**
>
>- bit数据类型用来存储bit值
>- bit(M)代表可以存储M个bit，M的取值范围为1到64
>- 如果手工指定bit值，则可以使用==b'value'格式==，比如`b'111'`和`b'10000000'`分别代表`7`和`128`
>- 除非特殊情况，否则不要使用这个类型
>
>**set**
>
>- ==set是一个字符串对象==，可以有零或多个值，其值来自表创建时规定的允许的一列值。
>- 指定包括多个set成员的set列值时各成员之间用逗号(',')间隔开。这样==set成员值本身不能包含逗号==。
>- set最多可以有64个不同的成员。
>- 建表时，set成员值的尾部空格将自动被删除。

#### 6. 选择标识符（identifier）

>为标识列（外键列）选择合适的数据类型非常重要。
>
>1. 在相关的表中使用相同的数据类型，因为这些列很可能在关联中使用。混用数据类型可能导致隐式类型转换错误。
>2. MySQL在内部使用整数存储ENUM和SET类型，然后==在作比较操作时转换为字符串==。
>3. 在可以满足值的范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。
>4. 通常来说==整数是标志列最好的选择==，因为他们很快并且可以使用auto_increment。
>5. 大部分情况下都要避免使用ENUM或者SET作为标志列的数据类型。
>6. 如果可能应该==避免字符串类型作为标志列==，因为他们很消耗空间，并且通常比数字类型慢。尤其是在MyISAM表里使用字符串作为标志列时要特别小心。MyISAM默认对字符串使用压缩指引，这会导致慢的很多。大概6倍的性能下降。
>7. 对于完全‘随机’的字符串也要多加小心，例如MD5(),SHA1()或者UUID()产生的字符串，这些函数产生的字符串会任意分布在很大的空间，这会导致INSET和SELECT语句变得很慢。

#### 7. 特殊类型数据

>IPv4地址，使用varchar(15)列来存储IP地址。
>
>使用INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。