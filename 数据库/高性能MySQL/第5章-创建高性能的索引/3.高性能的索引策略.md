#### 1. 独立的列

>查询的时候，要保证查询中的列是独立的，否则MySQL不会使用索引。“独立的列”是指索引列不能够是表达式的一部分，也不能是函数的参数。
>
>```sql
>SELECT actor_id FROM sakila.actor WHERE actor_id +1 = 5;
>```
>
>WHERE中等价于actor_id=4，但MySQL不会自动解析。所以应该始终将索引列单独放在比较符号的一侧。

#### 2. 前缀索引和索引选择性

>有时候需要索引很长的字符列，这会让索引变得大且慢，此时通常可以索引开始的部分字符，这样能节省索引空间，提高索引效率。要选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间）。
>
>```sql
>ALTER TABLE city_demo ADD KEY (city(7));
>```
>
>其缺点：
>
>- 无法使用前缀索引做ORDER BY和GROUP BY
>- 也无法使用前缀索引做覆盖扫描

#### 3. 多列索引

>“索引合并”的策略，一定程度上可以==使用表上的多个单列索引来定位指定的行==。
>
>- 当出现服务器对多个索引做==相交==操作时（通常由多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
>- 当服务器需要对多个索引做==联合==操作时（通常有多个OR条件），通常需要消耗大量的CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。

#### 4. 选择合适的索引列顺序

>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。
>
>将==选择性最高==的列放在索引最前列。但是查询性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。举一个例子，假设如下的查询：
>
>```sql
>SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
>```
>
>索引应该是(staff_id, customer_id)还是两者相反的顺序呢？可通过一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。而且在这个过程中，我们不能只用某一个特定的查询来看，而是要考虑全局。即我们可以先执行如下查询语句：
>
>```sql
>SELECT COUNT(DISTINCT staff id)/COUNT(*) AS staff_id_selectivity,
>		COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
>		COUNT(*)
>		FROM payment
>
>#结果为：
>staff_id_selectivity: 0.0001
>customer_id_selectivity: 0.0373
>COUNT(*): 16049
>```
>
>customer_id的选择性更高，所以答案是将其作为索引列的第一列：
>
>```sql
>ALTER TABLE paayment ADD KEY(customer_id, staff_id);
>```

#### 5. 聚簇索引

>聚簇索引是一种数据存储方式。当表中有聚簇索引时，他的==数据行实际上存放在索引的叶子页中==。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不容的地方，所以==一个表只能有一个聚簇索引==。
>
>如图展示了聚簇索引中的记录是如何存放的，要知道，`叶子页`包含了行的全部数据，但是`节点页`只包含了索引列。下图中，索引列包含的是整数值。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwaoyxm93j30ye0pmgqb.jpg" style="zoom:50%">
>
>- ==InnoDB通过主键聚集数据==即主键列就是“被索引的列”。
>- 如果没有主键，InnoDB会选择一个唯一的非空索引代替。
>- 如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引。
>
>==InnoDB只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远（例如上图中的20和后面的21可能相聚的比较远，但是11到20他们是聚到一起的）==。

>聚集的数据有一些优点：
>
>- 能把相关数据保存在一起。例如实现电子邮箱时，可根据用户ID来聚集数据，这样只需读取少数数据页就能获取某个用户的全部邮件。
>- 数据访问更快。==聚簇索引将索引和数据保存在同一个B-Tree中==，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。
>- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

>缺点：
>
>- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE重新组织一下表。
>- ==更新聚簇索引列的代价很高==，因为会强制InnoDB将每个被更新的行移动到新的位置。
>- 基于聚簇索引的行在插入新行，或者主键被更新导致需要移动行的时候，可能面临==页分裂==的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，页分裂会导致表占用更多的磁盘空间。
>- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候（这个地方是和B-Tree数据结构有关）。
>- 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了饮用含的主键列。
>- ==二级索引访问需要两次索引查找，而不是一次==。因为二级索引中保存的“行指针”并不是指向行的物理位置，而是行的主键值。因此如果通过二级索引查找某一行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找对应的航。这里是做了重复的工作，两次B-Tree查找而不是一次。

##### 5.1 InnoDB和MyISAM的数据分布对比

>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。看一下InnoDB和MyISAM是如何存储下面这个表的：
>
>```sql
>CREATE TABLE layout_test (
>    col1 int NOT NULL,
>    col2 int NOT NULL,
>    PRIMARY KEY(col1),
>    KEY(col2)
>);
>```
>
>表中主键索引是col1，二级索引是col2。

>**MyISAM的数据分布**
>
>按照数据插入的顺序存储在磁盘上。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwb8ydfkaj307w0ay0t4.jpg" style="zoom:60%">
>
>行号从0开始递增。==行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行，即只需要知道行号就能快速找到数据。==这种分布很容易创建索引，下面的图隐藏了页的物理细节，只显示索引中的“节点”，索引中的每个叶子节点包含“行号”，这样也能快速找到数据。其主键索引如下图所示：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwbb2bapij30vu0cstaa.jpg" style="zoom:60%">
>
>在col2列上的索引什么样子的呢，有什么特殊的吗？其实没有：它和其他索引没有什么区别。下图显示了col2列上的索引，类似的，只是叶子节点中的索引列变成了col2，而不是上面的主键col1，另一部分存储的也是行号：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwbfgvbykj30q80coq46.jpg" style="zoom:50%">

>**InnoDB的数据分布**
>
>InnoDB支持聚簇索引，使用不同的方式存储同样的数据，如图所示：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwbneexmuj30xu0fyac2.jpg" style="zoom:50%">
>
>在InnoDB中，聚簇索引“就是”表。聚簇索引的每个叶子节点都包含了==主键值、事务ID、用于事务和MVCC的回滚指针==以及所有的==剩余列==（此例子是col2）。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。
>
>InnoDB的二级索引和聚簇索引很不相同。==InnoDB二级索引的叶子节点中存储的是主键值==，以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当做行指针会让二级索引占用更多空间，但换来的好处是InnoDB在移动时无需更新二级索引中的这个“指针”。下图显示了col2索引的结构，每个叶子节点都包含了索引列（col2），紧接着是主键值（col1）。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwbykohjqj30y60co0u6.jpg" style="zoom:60%">
>
>下图则对比了InnoDB和MyISAM的存储结构：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwc2js8c7j311y0t6n2f.jpg" style="zoom:50%">

##### 5.2 在InnoDB表中按主键顺序插入行

>如果使用的InnoDB表没有什么数据需要聚集，那可以定义一个代理键作为主键，而且要保证和应用无关，最简单的方法是使用AUTO_INCREMENT自增列，这样可以保证数据行是按顺序写入。==最好避免随机的聚簇索引，例如使用UUID来作为聚簇索引会很糟糕，因为它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性==。
>
>我们看一下如果两个表一个是用AUTO_INCREMENT列作为聚簇索引，另一个用UUID时，往表里插入数据时有什么区别。
>
>下图是向自增表中插入数据时的情况，因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。==当达到页的最大填充因子时（InnoDB默认为页大小的15/16，留出空间用于以后修改），下一条记录就会写入新的页中==。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，也正是期望的结果。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwcbyqx43j30y20a6mzl.jpg" style="zoom:50%">
>
>对比一下向UUID表中插入数据的情况，如下图所示。因为新行的主键值不一定比之前插入的大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置—通常是已有数据的中间位置并分配空间，会增加很多额外工作，并导致数据分布不够优化。简而言之其缺点可汇总如下：
>
>- 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者还没有被加载到缓存中，所以InnoDB在插入前不得不先找到并从磁盘读取目标页到内存中，会导致大量的随机I/O。
>- 因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页面而不是一个页（和B-Tree数据结构有关）。
>- 由于频繁的页分割，页会变得稀疏并被不规则地填充，最终数据会有碎片。
>
>如果插入了这些随机值，也许需要做一次**OPTIMIZE TABLE**来重建表并优化页的填充。所以==使用InnoDB时，尽可能按主键顺序插入数据，并尽可能地使用单调增加的聚簇键的值来插入新行。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnwd3ctw9rj30ki0omdiv.jpg" style="zoom:50%">

>对于高并发工作负载,在Innodb中按主键顺序插入可能会造成明显的争用。主键的上界会成为"热点"。因为所有的插入都发生在这里，所以并发插入可能导致==间隙锁竞争==。另一个热点可能是==AUTO_INCREMENT锁机制==。如果遇到这个问题，则可能考虑重新设计表或者应用，或者更改`innodb_autoinc_lock_mode`配置。

#### 6. 覆盖索引

>如果==一个索引包含或覆盖所有需要查询的字段值==，我们就称之为“覆盖索引”。
>
>覆盖索引可以极大的提升性能。试想一下，如果一个查询==只需要扫描索引而无需二次回表查询==，会带来那些好处：
>
>- 索引行通常远小于数据行的大小，所以如果只需要索引，那么MySQL就会极大地减少数据访问量。
>- 因为索引是按照顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多。
>- 由于InnoDB的聚簇索引，所以覆盖索引对InnoDB特别有用。
>
>当发起一个覆盖查询的时候，在Explain中的Extra列中可以看到“`Using index`”的信息。让我们回到select *这个问题上，==select * 可能会导致原本可以用到覆盖索引的查询而无法使用覆盖索引==。

#### 7. 使用索引扫描来做排序

>MySQL有两种方式可以生成有序的结果：
>
>1. ==通过排序操作==；
>2. ==按索引顺序扫描==；
>
>如果EXPLAIN出来的==type列的值为“index“==，则说明MySQL使用索引扫描来做排序。
>
>扫描索引本身是很快的，因为需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此==按索引顺序读取数据的速度通常比顺序地全表扫描慢==，尤其是在I/O密集型的工作负载时。
>MySQL可以==使用同一个索引既满足排序，又用于查找行==。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。
>
>- 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。
>- 如果查询需要<u>关联多张表</u>，则==只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序==。
>- OEDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。
>- 有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列制定了常量，就可以“弥补“索引的不足。
>
>例如，Sakila示例数据库的表rental在列（rental_date,inventory_id,customer_id）上有名为rental_date的索引。
>
>```sql
>CREATE TABLE rental_id (
>    ...
>    PRIMARY KEY(rental_id),
>    UNIQUE KEY rental_date(rental_date,inventory_id,customer_id),
>    KEY idx_fk_inventory_id(inventory_id),
>    KEY idx_fk_customer_id(customer_id),
>    KEY idx_fk_staff_id(staff_id),
>);
>```
>
>下面是一些不能使用索引做排序的查询：
>
>- 下面这个查询使用了两种不同的排序方向，但是索引列都是正序排列的：
>  … WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id DESC , customer_id ASC;
>- 下面这个查询的ORDER BY子句中引用了一个不在索引中的列：
>  … WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id , staff_id;
>- 下面这个查询的WHERE和ORDER BY中的列无法组合成索引的最左前缀:
>  … WHERE rental_date = ‘2005-05-25’ ORDER BY customer_id;
>- 下面这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：
>  … WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id , customer_id;
>- 这个查询在inventory_id列上有多个等于条件。对于排序来说，这也是一种范围查询：
>  … WHERE rental_date = ‘2005-05-25’ AND inventory_id IN(1,2) ORDER BY customer_id;

#### 8. 压缩（前缀压缩）索引

>MyISAM压缩每个索引块的方法是：
>
>- 先完全保存索引块中的第一个值，
>- 然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。
>
>例如：索引块中的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7,ance”这样的形式。
>
>优点：占用空间减小
>
>缺点：MyISAM查找时无法在索引块使用二分法查找而只能从头开始扫描。

#### 9. 冗余和重复索引

>MySQL允许在相同列上创建多个索引，并需要单独维护重复索引，并且优化器在优化查询得时候也需要逐个地进行考虑，这会影响性能。
>
>重复索引是指==在相同得列上按照相同得顺序创建相同类型的索引==，应该避免，并及时删除。
>
>冗余索引不等于重复索引，如创建了索引（A，B）后又创建了索引（A），A是冗余索引因为它是前一个索引得前缀索引，但如果再创建索引（B，A）或者（B）则不是冗余索引。
>
>==可以写一些复杂得访问INFORMATION_SCHEMA表得查询来找，或者使用common_schema中得一些视图来定位冗余和重复索引==。

#### 10. 为使用的索引

>定位未使用的索引：在Percona Server或MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器运行一段时间再通过查询`INFORMATION_SCHEMA.INDEX_STATISTICS`就能查到每个索引得使用频率。

#### 11. 索引和锁

>==索引可以让查询锁定更少得行==。
>
>==如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。这时已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当的时候才释放==。InnoDB可以在服务器端过滤掉行后就释放锁。
>通过下面的例子很好地解释了这些情况：
>
>```sql
>SET AUTOCOMMIT=0;
>BEGIN;
>SELECT actor_id FROM sakila.actor WHERE actor_id < 5 AND actor_id <> 1 FOR UPDATE;
>```
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnykw1m6caj305806gweb.jpg" style="zoom:60%">
>
>这条查询仅仅会返回2~4之间的行，但是实际上==获取了1~4之间的行的排它锁==。InnoDB会锁住第1行，MySQL为该查询选择的执行计划是==索引范围扫描==。
>
>| id   | select_type | table | type  | key     | Extra                   |
>| ---- | ----------- | ----- | ----- | ------- | ----------------------- |
>| 1    | SIMPLE      | actor | range | PRIMARY | Using where;Using index |
>
>底层存储引擎的操作是“==从索引的开头开始获取满足条件actor_id<5的记录==”，服务器并没有告诉InnoDB可以过滤第1行的WHERE条件。==注意到EXPLAIN的Extra列出现了“Using where”，这表示MySQL服务器将存储引擎返回行以后再应用WHERE过滤条件==。
>
>下面的查询能证明第1行确实已经被锁定，尽管第一个查询的结果中并没有第1行。保持第一个连接打开，然后开启第二个连接并执行如下查询：
>
>```sql
>SET AUTOCOMMIT=0;
>BEGIN;
>SELECT actor_id FROM sakila.actor WHERE actor_id=1 FOR UPDATE;
>```
>
>这个查询将会挂起，直到第一个事务释放第1行的锁。这个行为对于基于语句的复制的正常运行来说是必要的。
>
>就像这个例子显示的，==即使使用了索引，InnoDB也可能锁住一些不需要的数据=。如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行，而不管是不是需要==。
>
>==InnoDB在二级索引上使用共享锁，但访问主键索引需要排它锁==。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢得多。
