MySQL执行一个查询的过程：

![image-20220524151112181](4.%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80.assets/image-20220524151112181.png)

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. ==服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划==。
4. MySQL根据优化器生成的执行计划，调用存储引擎API来执行查询。
5. 将结果返回给客户端。



#### 1. MySQL 客户端/服务器通信协议

---

==MySQL客户端和服务器之间的通信协议是“半双工”的==，这意味着，**在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据**，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。

这种协议让MySQL通信简单快速，但是意味着没法进行流量控制。一旦一端开始发生消息，另一端要接收完整的消息才能响应它。这就像来回抛球的游戏：在任何时刻，只有一个人能控制球，而且只有控制球的人才能将球抛回去（发送消息）。

客户端用一个单独的数据包将查询传给服务器。当查询的语句很长时，参数 `max_allowed_packet` 限制了查询的大小。

一旦客户端发送了请求，它能做的事情就只是等待结果了。相反的，一般服务器响应给要不过户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或者接收完几条结果后就“粗暴”地断开连接，都不是好主意。这也是在必要的时候一定要在查询中加上LIMIT限制的原因。

换一种方式解释这种行为：当客户端从服务器取数据时，客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。**多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里**，还可以逐行获取需要的数据。MySQL通常需要等待所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器压力，让查询能够早点结束、早点释放相应的资源。

当使用多数连接MySQL的库函数从MySQL获取数据时，其结果看起来都像是从MySQL服务器获取数据，而**实际上都是从这个库函数的缓存获取数据**。多数情况下这没什么问题，但是如果需要返回一个很大的结果集的时候，这样做并不好，因为库函数会花很多时间和内存来存储所有的结果集。如果能够尽早开始处理这些结果集，就能大大减少内存的消耗，这种情况下可以不使用缓存来记录结果而是直接处理。缺点：对于服务器来说，需要查询完成后才能释放资源，所以在和客户端交互的整个过程中，服务器的资源都是被这个查询所占用的。

##### 1.1 查询状态

对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态。

使用 `SHOW FULL PROCESSLIST` 命令查看。（返回结果中的Command列就表示当前的状态）在一个查询的生命周期中，状态会变化很多次。

| 状态                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| Sleep                          | 线程正在等待客户端发送新的请求                               |
| Query                          | 线程正在执行查询或者正在将结果发送给客户端                   |
| Locked                         | **在MySQL服务器层，该线程正在等待表锁**。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常会出现 |
| Analyzing and statistics       | 线程正在收集存储引擎的统计信息，并生成查询的执行计划         |
| Copying to tmp table [on disk] | 线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上 |
| Sorting result                 | 线程正在对结果集进行排序                                     |
| Sending data                   | 表示多种情况，线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据 |

了解这些状态，可以很快了解当前“谁正在持球”。



#### 2. 查询缓存

---

在解析一个查询语句之前，如果查询缓存时打开的，那么MySQL会优先检查这个查询是否命中缓存中的数据。这个检查是通过一个**对大小写敏感的哈希查找**实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理。

如果命中查询缓存，那么在返回查询结果前MySQL会检查一次用户权限，查询**缓存中已经存放了当前查询需要访问的表信息**。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。



#### 3. 查询优化处理

---

查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。

这包括多个子阶段：

- **解析SQL**
- **预处理**
- **优化SQL执行计划**

这个过程中任何错误都可能终止查询。

##### 3.1 语法解析器和预处理

- 首先，MySQL**通过关键字将SQL语句进行解析**，并生成一颗对应的“解析树”。==解析器将使用MySQL语句规则验证和解析查询==。（例如，验证是否使用错误的关键字，或使用关键字的顺序是否正确，再或者验证引号是否能前后正确匹配）
- 预处理器则根据一些MySQL规则**进一步检查解析树是否合法**。（例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看他们是否有歧义。）
- 下一步预处理器会**验证权限**。这通常很快，除非服务器上有非常多的权限配置。

##### 3.2 查询优化器

语法树被认为合法后，有**优化器将其转化为执行计划**。

MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。

最初，成本的最小单位是随机读取一个4K数据页的成本，后来成本计算公式变得更加复杂，并且引入了一些“因子”来估算某些操作的代价，如当执行一次WHERE条件比较的成本。可以通过查询当前会话的 `Last_query_cost` 的值来得知MySQL计算的当前查询的成本。

```sql
SELECT count(*) FROM sys_job;

SHOW STATUS LIKE 'Last_query_cost';
```

| Variable_name   | Value     |
| --------------- | --------- |
| Last_query_cost | 12.499000 |

这个结果表示优化器认为大概需要做12个数据页的随机查找才能完成上面的查询。这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数（索引中不同值的数量）、索引和数据行的长度、索引分布情况。**优化器在评估成本的时候并不考虑任何层面的缓存**，它假设读取任何数据都需要一次磁盘I/O。

很多种原因会导致MySQL优化器选择错误的执行计划，如下所示：

- 统计信息不准确。（MySQL依赖存储引擎提供的统计信息来评估成本。有的存储引擎提供的统计信息有偏差，例如，**InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息**）
- 执行计划中的成本估算不等同于实际执行的成本。所以即使统计信息准确，优化器给出的执行计划也可能不是最优的。（例如有时候某个执行计划虽然需要读取更多的页面，但是它的成本却更小。因为如果这些页面都是顺序读或者这些页面已经再内存中的话，那么它的访问成本将很小。MySQL层面并不知道哪些页面在内存中、哪些在磁盘上，所以**查询实际执行过程中到底需要多少次物理I/O是无法得知的**。）
- 只是基于其成本模型选择最优的执行计划，而有些时候这并不是最快的执行方式。所以，根据执行成本来选择执行计划并不是完美的模型。
- 从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。
- 并不是都基于成本的优化。有时也会基于一些固定的规则。（例如，如果存在全文搜索的MATCH()子句，则在存在全文索引的时候就使用全文索引。即使有时候使用别的索引和WHERE条件可以远比这种方式要快，MySQL也仍然会使用对应的全文索引。）
- 不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。
- 优化器有时候无法去估算所有可能的执行计划，所以它可能错过实际上最优的执行计划。

> 优化策略可以简单分为两种：
>
> 1. 静态优化：直接对解析树进行分析和优化，例如可以通过一些简单的代数变换将WHERE条件转换成另一种等价形式。（编译时优化）
> 2. 动态优化：和查询的上下文有关，也可能和很多其他因素有关，例如WHERE条件中的取值、索引条目对应的数据行数等。（运行时优化）

MySQL对查询的静态优化只需要做一次，但对查询的动态优化则在每次执行时都需要重新评估。有时候甚至在查询的执行过程中也会重新优化。

>下面是一些MySQL能够处理的优化类型：
>
>



-javaagent:/Applications/IntelliJ\ IDEA.app/Contents/ja-netfilter.jar=jetbrains



























