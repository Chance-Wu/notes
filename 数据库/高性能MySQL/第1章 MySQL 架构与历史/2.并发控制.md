>多个查询在同一时刻修改数据，都会产生并发控制的问题。
>
>讨论两个层面的并发控制：
>
>- 服务器层
>- 存储引擎层

#### 1. 读写锁

>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。
>
>- ==共享锁（shared lock） / 读锁（read lock）==
>
>  读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。
>
>- ==排它锁（exclusive lock） / 写锁（write lock）==
>
>  写锁是排他的，也就是说<u>一个写锁会阻塞其他的写锁和读锁</u>，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

#### 2. 锁粒度

>一种提高共享资源并发性的方式就是让锁对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。锁定的数据量越少，则系统的并发程度越高。
>
>加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。
>
><u>锁策略就是在锁的开销和数据的安全性之间寻求平衡</u>。大多数商业数据库系统没有提供更多的选择，一般都是==在表上施加行级锁==（row level lock），并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而MySQL提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。MySQL支持多个存储引擎的架构，所以不需要单一的通用解决方案。下面介绍两种重要的锁策略：

##### 2.1 表锁（table lock）

>表锁是MySQL中最基本的锁策略，并且是==开销最小==的策略。表锁会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。
>
>写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。
>
>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，==服务器会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制==。

##### 2.2 行锁（row lock）

>行级锁可以==最大程度地支持并发处理==（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。