>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。为了提升并发性能，它们一般都同时实现了==多版本并发控制==。
>
>多版本并发控制是行级锁的一个变种，但是它<u>在很多情况下避免了加锁操作，因此开销低</u>。大多数都实现了非阻塞的读操作，写操作也只锁定必要的行。

#### 1. 多版本并发控制的实现

>通过==保存数据在某个时间点的快照==来实现。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同意时刻看到的数据可能是不一样的。
>
>不同的存储引擎的多版本并发控制实现是不同的，典型的有==乐观并发控制==和==悲观并发控制==。

##### 1.1 多版本并发控制如何工作

>通过InnoDB的简化版行为来说明多版本并发控制是如何工作的。
>
>在每行记录后面保存两个隐藏的列来实现。一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是==系统版本号==。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
>
>REPEATABLE READ隔离级别下，多版本并发控制的具体操作：
>
>- SEELCT
>  - InnoDB会根据以下两个条件检查每行记录：
>    - InnoDB只查找==版本早于当前事务版本的数据行==（行的系统版本号小于或等于事务的系统版本号）。
>    - 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
>- INSERT
>  - InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
>- DELETE
>  - InnoDB为删除的每一行保存当前系统版本号作为行版本号。
>- UPDATE
>  - InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
>
>保存这2个额外系统版本号，使大多数读操作都可以不用加锁。多版本并发控制只在可重复读和提交读两个隔离级别下工作。未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行。而可串行化则会对所有读取的行都加锁。