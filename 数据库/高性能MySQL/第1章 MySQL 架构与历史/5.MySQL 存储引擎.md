>在文件系统中，MySQL将每个数据库(也可称之为`schema`)保存为数据目录下的一个子目录。创建表时，会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。
>
>例如创建一个test库，user表。MySQL会在==user.frm文件保存表的定义==。（因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体平台密切相关。==Windows中大小写不敏感，类Unix中则是大小写敏感。==）
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnty6txr66j306y02q743.jpg" style="zoom:60%">
>
>==表的定义是在服务层统一处理的==。
>
>使用以下命令查看表的相关信息：
>
>```sql
>mysql> SHOW TABLE STATUS LIKE 'user';
>
>*************************** 1. row ***************************
>           Name: user
>         Engine: InnoDB
>        Version: 10
>     Row_format: Dynamic
>           Rows: 0
> Avg_row_length: 0
>    Data_length: 16384
>Max_data_length: 0
>   Index_length: 0
>      Data_free: 0
> Auto_increment: 2
>    Create_time: 2021-02-20 10:14:28
>    Update_time: NULL
>     Check_time: NULL
>      Collation: utf8_general_ci
>       Checksum: NULL
> Create_options:
>        Comment:
>1 row in set (0.00 sec)
>```
>
>输出结果表明这是一个InnoDB表。还包含以下信息：
>
>- Name 表名
>- Engine 表的存储引擎类型
>- Row_format 行的格式（`Dynamic`的行长度是可变的；`Fixed`的长度固定；`Compressed`的行只在压缩表中存在）
>- Rows 表中的行数（对于InnoDB，该值是估计值）
>- Avg_row_length 平均每行包含的字节数
>- Data_length 表数据的大小
>- Max_data_length 表数据的最大容量（该值和存储引擎有关）
>- Index_length 索引的大小（字节为单位）
>- Data_free 表示已分配但目前没有使用的空间
>- Auto_increment 下一个AUTO_INCREMENT的值
>- Create_time 表的创建时间
>- Update_time 表数据的最后修改时间
>- Check_time 使用CHECK TABLE命令或者myisamchk工具最后一次检查表的时间
>- Collation 表的默认字符集和字符排列顺序规则
>- Checksum 如果启用，保存的是整个表的实时校验和
>- Create_options 创建表时只读的其他选项
>- Comment 该列包含了一些其他的额外信息（对InnoDB，保存的是表空间剩余空间信息；对于MyISAM表，保存的是表在创建时带的注释。）

#### 1. InnoDB存储引擎

>InnoDB是MySQL的默认事务型引擎。被设计用来<u>处理大量的短期(short-lived)事务</u>，短期事务大部分情况是正常提交的，很少会被回滚。

##### 1.1 InnoDB的历史

>现代的InnoDB版本，就是MySQL 5.1中所谓的InnoDB plugin，支持一些新特性（如：利用排序创建索引、删除或者增加索引时不需要复制全表数据、新的支持压缩的存储格式、新的大型列值如BLOB的存储方式，以及文件格式管理等。）

##### 1.2 InnoDB预览

>==InnoDB的数据存储在表空间（tablespace）==，表空间是由InnoDB管理的一个黑盒子，由一系列的==数据文件组成==。
>
>InnoDB采用多版本并发控制来支持高并发，并且实现了四个标准的隔离级别。==默认隔离级别为REPEATABLE READ（可重复读）==，并且==通过间隙锁策略防止幻读的出现==。间隙锁（next-key locking）使得InnoDB不仅仅锁定查询设计的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
>
>InnoDB表是基于==聚簇索引==建立的。InnoDB的索引结构和其他的存储引擎有很大的不同，聚簇索引<u>对主键查询有很高的性能</u>。不过==它的二级索引（secondary index，非主键索引）中必须包含主键列==，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。InnoDB的存储格式是平台独立的，也就是说可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。
>
>InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。
>
>作为支持事务型的存储引擎，InnoDB通过一些机制和工具支持真正的热备份：`mysqldump`、`xtrabackup`。MySQL其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入也意味着停止读取。

#### 2. MyISAM存储引擎

>- 崩溃后无法安全恢复
>- 不支持事务
>
>对于只读的数据，或者表比较小、可以忍受修复操作，则可以使用MyISAM。

##### 2.1 存储

>MyISAM会将表存储在两个文件中：==数据文件==（`.MYD`）和==索引文件==（`.MYI`）。
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnty8fjcu2j306e03qt8j.jpg" style="zoom:60%">
>
>- MyISAM表可以包含动态或者静态行。（MySQL会根据表的定义来决定采用何种行格式。）
>- MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。

##### 2.2 MyISAM特性

>- 加锁与并发
>
>  对整张表加锁。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。
>
>- 修复
>
>  可以手工或自动执行检查和修复操作。（可能导致一些数据丢失）
>
>- 索引特性
>
>  - 对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。
>  - 也支持全文索引，一种基于分词创建的索引，支持复杂的查询。
>
>- 延迟更新索引建
>
>  创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。提升写入性能，但是会在崩溃时造成索引损坏。

##### 2.3 MyISAM压缩表

>如果表在创建并导入数据以后，不会再进行修改操作，那么或许时候采用MyISAM压缩表。
>
>使用`myisampack`对表进行压缩（打包）。
>
>- ==压缩表不能进行修改==
>- 减少磁盘占用空间，减少磁盘I/O
>- 提升查询性能
>- 压缩表支持索引（只读）
>- 压缩时表中的记录时独立压缩的，所以读取单行的时候不需要去解压整个表。

##### 2.4 MyISAM性能

>MyISAM引擎设计简单，数据以紧密格式存储。最典型的性能问题是==表锁的问题==，如果发现索引的查询都长期处于“Locked”状态，毫无疑问表锁就是罪魁祸首。

#### 3. MySQL 内建的其他存储引擎

##### 3.1 ARCHIVE引擎

>- 是一个针对高速插入和压缩做了优化的简单引擎。
>- 只支持INSERT和SELECT操作。
>- 会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少。
>- 每次SELECT都需要执行全表扫描。
>- ==ARCHIVE表适合日志和数据采集类应用==。
>
>ARCHIVE引擎支持行级锁和专用的缓冲区，可以实现高并发的插入。在一个查询开始直到返回表中存在的所有行数之前，ARCHIVE引擎会阻止其他SELECT的执行，已实现一致性读。
>
>另外，实现了批量插入在完成之前对读操作不可见。

##### 3.2 BLACKHOLE引擎

>没有实现任何的存储机制，会丢弃所有插入的数据，不做任何保存。但是服务器会记录BLACKHOLE表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。
>
>可以应用在特殊的复制架构和日志审核时。

##### 3.3 CSV引擎

>- 可以将普通的CSV文件（逗号分隔值的文件）作为MySQL的表来处理。
>- 这种表不支持索引。
>- CSV引擎可以在数据库运行时拷入或者拷出文件。
>- 可以将Excel等电子表格软件中的数据存储为CSV文件，然后复制到MySQL数据目录下，就能在MySQL中打开使用。
>
>CSV引擎可以作为一种数据交换的机制。

##### 3.4 MEMORY引擎

>- 如果需要快速的访问数据，并且这些数据不会被修改，重启以后丢失也没关系，那么使用MEMORY表。
>- 所有数据都保存在内存中，不需要进行磁盘I/O。
>- MEMORY表的结构在重启后会保留，数据丢失。
>- 支持Hash索引，查询快
>- 表级锁，并发写入性能低
>- 不支持BLOB或TEXT类型的列，每行长度固定
>
>MEMORY表在以下场景发挥好的作用：
>
>- 用于查找或者映射表，例如将邮编和洲名映射的表。
>- 用于缓存周期性聚合数据的结果。
>- 用于保存数据分析中产生的中间数据。
>
>如果MySQL在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是MEMORY表。如果中间结果大大超出了MEMORY表的限制，或者含有BLOB或TEXT字段，则临时表会转换成MyISAM表。

>==临时表==：使用CREATE TEMPORATY TABLE语句创建的表，它可以使用任何存储引擎。只在单个连接中可见，当连接断开时，临时表也将不复存在。

#### 4. 第三方存储引擎

##### 4.1 OLTP类引擎

>`XtraDB`存储引擎是基于InnoDB引擎的一个改进版本，已经包含在Percona Server和MariaDB中。可以作为InnoDB的一个完全替代产品。
>
>`TokuDB`引擎使用了一种新的叫做分形树（Fractal Trees）的索引数据结构。是一种大数据存储引擎，用于很高的压缩比，可以在很大数据量上创建大量索引。

##### 4.2 面向列的存储引擎

>MySQL默认是面向行的，每一行的数据是一起存储的，服务器的查询也是以行为单位处理的。而在大数据处理时，面向列的方式可能效率更高。
>
>Infobright、InfiniDB是面向列的存储引擎。

##### 5. 选择合适的引擎

>选择存储引擎需要考虑一下因素：
>
>- 事务
>- 备份
>- 崩溃恢复
>- 特有的特性

#### 6. 转换表的引擎

>三种方法

##### 6.1 ALTER TABLE

>将表从一个引擎修改为另一个引擎。
>
>```sql
>ALTER TABLE test ENGINE=InnoDB;
>```
>
>耗时长。消耗系统的I/O能力。

##### 6.2 导出与导入

>使用`mysqldump`工具将数据导出到文件，然后<u>修改文件中CREATE TABLE语句的存储引擎选项</u>，注意同时修改表名。
>
>注意：==mysqldump默认会自动在CREATE TABLE语句前加上DROP TABLE语句==。可能导致数据丢失。

##### 6.3 创建与查询

>先创建一个新的存储引擎表，然后利用INSERT ... SELECT语法来导出数据：
>
>```sql
>CREATE TABLE innodb_table LIKE myisam_table;
>ALTER TABLE innodb_table ENGINE=InnoDB;
>INSERT INTO innodb_table SELECT * FROM myisam_table;
>```
>
>数据量不大的话，这样做很好。数据量大可以做分批处理，针对每一段数据执行事务提交操作。
>
>```sql
>START TRANSACTION;
>INSERT INTO innodb_table SELECT * FROM myisam_table WHERE id BETWEEN x AND y;
>COMMIT;
>```
>
>Percona Toolkit提供了一个pt-online-schema-change的工具可以执行上述过程。