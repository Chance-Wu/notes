>索引（键key）是存储引擎==用于快速找到记录的一种数据结构==。
>
>当表中的数据量越来越大时，索引对性能的影响愈发重要。
>
>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级。

>如果想在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码。在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
>
>```sql
>SELECT first_name FROM sakila.actor WHERE actor_id=5;
>```
>
>如果在actor_id列上建有索引，则将使用该索引找到actor_id为5的行，即先在索引上按值进行查找，然后返回所有包含该值的数据行。

>如果索引包含多个列，那么列的顺序十分重要。因为==MySQL只能高效地使用索引的最左前缀列==。
>
>注意：使用ORM时，也需要关心索引。

#### 1. 索引的类型

>索引在引擎层实现。没有统一的索引标准。

##### 1.1 B树索引

>如果没有特别指明类型，多半说的是B-Tree索引。
>
>不同的存储引擎可能使用不同的存储结构。
>
>- InnoDB使用的是B+Tree
>- InnoDB按照原数据格式进行存储
>- InnoDB根据主键引用被索引的行
>- B树意味着所有的值都是按顺序存储的，每一个叶子页到根的距离相同。
>
>下图大致反映了InnoDB索引是如何工作的：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnw1bw5ihmj30zu0mogom.jpg" style="zomm:50%">
>
>B树索引能够加快访问数据的速度，存储引擎==不再需要进行全表扫描==来获取需要的数据，而是
>
>- ==从索引的根节点开始进行搜索==。==根节点的槽中存放了指向子节点的指针==，存储引擎根据这些指针向下层查找。
>- 通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。
>- 最终存储引擎要么找到对应的值，要么该记录不存在。
>
>根节点和叶子节点之间可能有很多层节点页。==树的深度和表的大小直接相关==。B树对索引列是==顺序组织存储==的，==适合查找范围数据==。
>
>假如有以下数据表：
>
>```sql
>CREATE TABLE People (
>    last_name varchar(50) not null,
>    first_name varchar(50) not null,
>    dob date not null,
>    gender enum('m','f') not null,
>    key(last_name,first_name,dob)
>);
>```
>
>对于表中的每行数据，索引包含了last_name、first_name和dob列的值，下图显示了该索引是如何组织数据的存储的：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnw1x69qf4j30yw0ng43l.jpg" style="zoom:50%">
>
>注意：==索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序==。最后两个条目，两个人的姓和名都一样，则根据出生日期来排序。

>B树索引适用于==全键值==、==键值范围==或==键前缀==查找。其中键前缀查找只适用于根据==最左前缀==的查找。上述索引对如下类型的查询有效：
>
>- ==全值匹配==
>
>  和索引中的所有列进行匹配（查找姓名为Cuba Allen、出生与1960-01-01的人）
>
>- ==匹配最左前缀==
>
>  即值使用索引的第一列（查找所有姓为Allen的人）
>
>- ==匹配列前缀==
>
>  匹配某一列的值的开头部分（查找所有以J开头的姓的人，只使用了索引的第一列）
>
>- ==匹配范围值==
>
>  和索引第一列的范围值进行匹配（查找姓在Allen和Barrymore之间的人）
>
>- ==精确匹配某一列并范围匹配另外一列==
>
>  索引的第一列全匹配，第二列范围匹配（查找所有姓为Allen，并且名字是字母K开头的人）
>
>- ==只访问索引的查询==
>
>  查询只需访问索引，无须访问数据行。

>因为索引树中的节点是有序的，除了按值查找之外，还可以用于查询中的ORDER BY操作（按顺序查找）。如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

>**B树索引的限制**
>
>- 如果不是按照索引的最左列开始查找，则无法使用索引。（索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人）
>- 不能跳过索引中的列（索引无法用于查找姓为Smith并且在某个特定日期出生的人）
>- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。（WHERE last_name=''Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'，这个查询只能使用索引的前两列，==LIKE是一个范围条件==，如果范围查询列值的数量有限，可以通过使用多个等于条件来代替范围条件）

##### 1.2 哈希索引

>哈希索引基于hash表实现，只有==精确匹配索引所有列的查询才有效==。
>
>对于每行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同于键值的行计算出的哈希码也不一样。==哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针==。
>
>MySQL中，只有Memory引擎显式地支持哈希索引。

>**哈希索引的限制**
>
>- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
>- 不是按照索引值顺序存储的，无法用于排序
>- 不支持部分索引列匹配查找（始终是使用索引列的全部内容计算哈希值的）
>- 只支持等值比较查询，=、IN()、<=>
>- 访问哈希索引的数据非常快，除非有很多哈希冲突。
>- 如果哈希冲突很多，则索引维护操作的代价会很高。

>InnoDB引擎有一个“`自适应哈希索引`”。==当InnoDB注意到某些索引值被使用得非常频繁时，会在内存中基于B树索引之上再创建一个哈希索引==，这样就让B树索引也具有哈希索引的一些优点，如快速的哈希查找。

##### 1.3 空间数据索引(R-Tree)

>MyISAM表支持空间索引，可以用作地理数据存储。空间索引会从所有维度来索引数据。

##### 1.4 全文索引

>全文索引类似于LIKE语句，把包含一定字符串的行记录挑选出来。
>
>- 性能，LIKE通配符和正则表达式通常需要全表扫描，且极少使用表索引，所以这些操作非常耗时。
>- 不能明确控制
>- 结构不够智能