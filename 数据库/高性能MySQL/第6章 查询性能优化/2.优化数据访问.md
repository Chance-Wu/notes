查询性能低下最基本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。

1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着==访问了太多的行==，但有时候也可能是==访问了太多的列==。
2. 确认MySQL服务器层是否在分析大量超过需要的数据行。



#### 1.  是否向数据库请求了不需要的数据

有些查询会请求查过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。

典型案例：

- 查询不需要的记录（在查询后加上LIMIT）
- 多表关联时返回全部列（不使用*，只查询需要的列）
- 总是取出全部列（==看到SELECT * 的时候需要用怀疑的眼光审视==，是不是真的需要返回全部的列？取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗。）
- 重复查询相同的数据（==使用缓存==）



#### 2. MySQL是否在扫描额外的记录

---

最简单的衡量查询开销的三个指标如下：

- **响应时间**
- **扫描的行数**
- **返回的行数**

这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。

##### 2.1 响应时间

响应时间是两个部分之和：

- **服务时间**：数据库处理这个查询真正花了多长时间。
- **排队时间**：服务器因为等待某些资源而没有真正执行查询的时间。（可能是等I/O操作完成，也可能是等待行锁等等）

当看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用“**快速上限估计**”法来估算查询的响应时间。

>概括得说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件条件下一次I/O的消耗时间。最后把这些消耗都加起来，就可以获取一个大概参考值来判断当前响应时间是不是一个合理值。

##### 2.2 扫描的行数和返回的行数

较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快。理想情况下扫描的行数和返回的行数应该是相同的。

> 实际情况下，例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间。不过有时候这个值也可能非常大。

##### 2.3 扫描的行数和访问类型

在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无需扫描就能返回结果。

在EXPLAIN语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。速度从慢到快，扫描的行数也是从大到小。需要明白==扫描表==、==扫描索引==、==范围访问==和==单值访问==的概念。

> 如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。

示例：

```sql
# 有索引的情况
EXPLAIN SELECT
	* 
FROM
	t1 
WHERE
	person = '小红';
```

| id   | select_type | table | partitions | type | possible_keys | key          | ken_len | ref   | rows | filtered | Extra       |
| ---- | ----------- | ----- | ---------- | ---- | ------------- | ------------ | ------- | ----- | ---- | -------- | ----------- |
| 1    | SIMPLE      | t1    | (NULL)     | ref  | person_index  | person_index | 202     | const | 1    | 100.00   | Using index |

EXPLAIN的结果显示预估要访问1行数据。如果没有合适的索引，MySQL不得不使用一种更糟糕的访问类型，下面如果删除对应的索引再来运行这个查询：

| id   | select_type | table | partitions | type | possible_keys | key    | ken_len | ref    | rows | filtered | Extra       |
| ---- | ----------- | ----- | ---------- | ---- | ------------- | ------ | ------- | ------ | ---- | -------- | ----------- |
| 1    | SIMPLE      | t1    | (NULL)     | ALL  | (NULL)        | (NULL) | (NULL)  | (NULL) | 3    | 33.33    | Using where |

访问类型变成了==全表扫描（ALL）==。这里的“Using where”表示MySQL将通过where条件来筛选存储引擎返回的记录。

>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：
>
>- 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。
>- 使用索引覆盖扫描（在Extra列中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。
>- 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。

好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如使用聚合函数count()的查询，可能需要读取几千行数据，但是仅返回200行结果。

>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：
>
>- 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应的行就可以返回结果了；
>- 改变库表结构。例如使用单独的汇总表；
>- 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。