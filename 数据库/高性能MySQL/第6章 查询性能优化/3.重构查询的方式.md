#### 1. 一个复杂查询还是多个简单查询

---

设计查询的时候需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。



#### 2. 切分查询

---

有时候对于一个大查询需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。

> 删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多很小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。
>
> 例如，需要每个月运行一次下面的查询：
>
> ```sql
> DELETE 
> FROM
> 	message 
> WHERE
> 	created < DATE_SUB( NOW(), INTERVAL 3 MONTH );
> ```
>
> 可以用类似下面的办法来完成同样的工作：
>
> ```sql
> rows_affected = 0 
> DO { 
> 	rows_affected = do_query ( "DELETE FROM	message WHERE created < DATE_SUB( NOW(), INTERVAL 3 MONTH) LIMIT 10000" ) 
> } WHILE rows_affected > 0;
> ```
>
> 一次删除一万行数据一般来说是一个比较高效而且对服务器影响也最小的做法（==如果是事务性引擎，很多时候小事务更高效==）。如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。



#### 3. 分解关联查询

---

>在很多场景下，通过重构查询将关联放到应用程序中将会更加高效。比如：当应用能够方便地缓存单个查询的结果的时候、**当可以将数据分布到不同的MySQL服务器上的时候**、**当能够使用IN()的方式代替关联查询的时候**、**当查询中使用同一个数据表的时候**。

对关联查询进行分解。可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。

例如以下查询：

```sql
SELECT * FROM tag
	JOIN tag_post ON tag_post.tag_id = tag.id
	JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = 'mysql'
```

可以分解成以下查询代替：

```sql
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id in(123,456,567,9098,8904);
```

>分解关联查询的方式重构查询有如下的优势：
>
>- 让缓存的效率更高。
>- 将查询分解后，==执行单个查询可以减少锁的竞争==。
>- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展性。
>- 查询本身效率也可能会有所提升。这个例子中，使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。
>- 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。
>- 这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高得多。