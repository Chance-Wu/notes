>事务就是==一组原子性的SQL查询==，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么久执行该组查询。若其中任何一条语句因为奔溃或其他原因无法执行，那么所有的语句都不会执行，也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

>可以用`START TRANSACTION`语句开始一个事务，然后要么使用COMMIT提交事务将修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。
>
>除非系统通过严格的`ACID`测试，否则空谈事务的概念是不够的。
>
>**原子性（atomicity）**
>
>一个事务必须被视为不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
>
>**一致性（consistency）**
>
>数据库总是从一个一致性的状态转换到另外一个一致性的状态。
>
>**隔离性（isolation）**
>
>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
>
>**持久性（durability）**
>
>一旦事务提交，则其所做的修改就会永久保存到数据库中。==此时即使系统崩溃，修改的数据也不会丢失==。持久性是个有点模糊的概念，因为实际上持久也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。

>用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。即使存储引擎不支持事务，也可以通过`LOCK TABLES`语句为应用提供一定程度的保护。

#### 1. 隔离级别

>SQL标准中定义了四种隔离级别，每一种界别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

>**READ UNCOMMITED（未提交读）**
>
>事务中的修改，即使没有提交，对其他事务都是可见的。事务可以读取未提交的数据，即==脏读==。
>
>**READ COMMITED（提交读）**
>
>大多数数据库系统的默认隔离级别都是READ COMMITED。满足隔离性的简单定义。也称为==不可重复读==，因为两次执行同样的查询，可能会得到不一样的结果。
>
>**REPEATABLE READ（可重复读）**——MySQL默认事务隔离级别
>
>可重复读解决了脏读的问题。该级别保证了同一个事务中多次读取同样记录的结果是一致的。但是理论上，还是无法解决另外一个==幻读的问题==（<u>当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行</u>）。InnoDB和XtraDB存储引擎通过==多版本并发控制==解决了幻读问题。
>
>**SERIALIZABLE（可串行化）**
>
>最高的隔离界别。==强制事务串行执行，避免了幻读的问题==。即可串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
>
>| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
>| ---------------- | ---------- | ---------------- | ---------- | ------ |
>| READ UNCOMMITTED | YES        | YES              | YES        | NO     |
>| READ COMMITTED   | NO         | YES              | YES        | NO     |
>| REPEATABLE READ  | NO         | NO               | YES        | NO     |
>| SERIALIZABLE     | NO         | NO               | NO         | YES    |

#### 2. 死锁

>两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
>
>- ==当多个事务试图以不同的顺序锁定资源时，就可能产生死锁==。
>- 多个事务同时锁定同一个资源时，也会产生死锁。
>
>例如，设想下面两个事务同时处理StockPrice表：
>
>```
>事务1
>START TRANSACTION;
>UPDATE StockPrice SET close=45.50 WHERE stock_id=4 and date='2002-05-01';
>UPDATE StockPrice SET close=19.80 WHERE stock_id=3 and date='2002-05-02';
>COMMIT;
>
>事务2
>START TRANSACTION;
>UPDATE StockPrice SET high=20.12 WHERE stock_id=3 and date='2002-05-02';
>UPDATE StockPrice SET high=47.20 WHERE stock_id=4 and date='2002-05-01';
>COMMIT;
>```
>
>如果凑巧，两个事务都执行第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后==两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环==。除非有外部因素介入才可能解除死锁。

>解决死锁的方式：
>
>- 数据库系统实现了各种==死锁检测机制==和==死锁超时机制==。比如InnoDB存储引擎能检测到死锁依赖，并立即返回一个错误。死锁会导致慢查询。
>- 当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式不太好。
>
>==InnoDB目前处理死锁的方法是，将持有最少行级排它锁的事务进行回滚==（这是相对比较简单的死锁回滚算法）。

>锁的行为和顺序是和存储引擎相关的。以相同的顺序执行语句，有些存储引擎会产生死锁，有些则不会。==死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的==。

>死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

#### 3. 事务日志

>事务日志帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时==只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中==，而不用每次都将修改的数据本身持久到磁盘。
>
>事务日志采用的是==追加的方式==，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。
>
>==事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘==。大多数存储引擎都是这样实现的，称之为==预写式日志==（Write-Ahead Logging），==修改数据需要写两次磁盘。==
>
>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

#### 4. MySQL 中的事务

>MySQL提供了两种事务型的存储引擎：==InnoDB==和==NDB Cluster==。还有一些第三方存储引擎也支持事务，比较知名的包括`XtraDB`和`PBXT`。

##### 4.1 自动提交（AUTOCOMMIT）

>==MySQL默认采用自动提交模式==。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过==设置AUTOCOMMIT变量来启用或者禁用自动提交模式==：
>
>```sql
>SHOW VARIABLES LIKE 'AUTOCOMMIT';
>```
>
>| Variable_name | Value |
>| ------------- | ----- |
>| autocommit    | ON    |
>
>```sql
>SET AUTOCOMMIT=1;
>```
>
>`1 / ON`表示启用，`0 / OFF`表示禁用。
>
>当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。==修改AUTOCOMMIT对非事务性的表，比如MyISAM或者内存表，不会有任何影响==。对这类表来说，没有COMMIT或者ROLLBACK的概念，也可以说是相当于一直处于AUTOCOMMIT启用的模式。

>在数据定义语言(DDL)中，如果是会导致大量数据改变的操作，比如`ALTER TABLE`，`LOCK TABLES`等其他语句也会导致自动提交。

>通过执行以下命令来设置隔离级别。新的隔离级别在下一个事务开始的时候生效。
>
>```sql
>SET TRANSACTION ISOLATION LEVEL;
>```
>
>也可以只改变当前会话的隔离级别：
>
>```sql
>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
>```

##### 4.2 在事务中混合使用存储引擎

>MySQL服务层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

##### 4.3 隐式和显式锁定

>InnoDB采用的是==两阶段锁定协议==。
>
>- 在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。（隐式锁定）
>- InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范：
>  - SELECT ... LOCK IN SHARE MODE
>  - SELECT ... FOR UPDATE
>
>MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。<u>不能替代事务处理</u>。
>
>建议：除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎。