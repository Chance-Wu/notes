>Redis事务保证了==一致性==`Consistency`和==隔离性==`Isolation`；不满足原子性`Atomicity`和持久性`Durability`。
>
>- redis事务在执行的中途遇到错误，不会回滚所有的命令，而是继续执行后续命令；（违反原子性）
>- 事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定。
>- redis事务在执行的过程中，不会处理其它命令，而是等所有命令都执行完后，再处理其它命令（满足隔离性）
>- redis事务在执行过程中发生错误或进程被终结，都能保证数据的一致性；

>Redis事务相关命令：
>
>- DISCARD：取消事务，放弃执行事务块内的所有命令。
>- EXEC：执行所有事务块内的命令
>- MULTI：标记一个事务块的开始
>- UNWATCH：取消WATCH命令对所有key的监视
>- WATCH：监视一个或多个key，如果在事务执行之前这些key被其他命令所改动，那么事务将被打断。

#### 1. 事务

>`MULTI`，`EXEC`，`DISCARD`和`WATCH`是Redis中事务的基础。它们允许一步执行一组命令，并具有两个重要保证：
>
>1. 事务中的==所有命令都被序列化并顺序执行==。在Redis事务的执行过程中，永远不会发生另一个客户端发出的请求。这样可以确保将命令作为单个隔离操作执行。
>2. 所有命令都将被处理，或者不处理任何命令，因此==Redis事务也是原子的==。
>   1. EXEC 命令负责触发并执行事务中的所有命令：如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。
>   2. 另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

#### 2. 使用

>- 使用`MULTI`命令输入Redis事务。该命令始终以OK答复。
>
>- 此时，用户可以发出多个命令，Redis不会执行这些命令，而是将它们排队。
>- 调用`EXEC`，将执行所有命令。
>- 调用`DISCARD`，将刷新事务队列并退出事务。
>
>```
>> MULTI
>OK
>> INCR foo
>QUEUED
>> INCR foo
>QUEUED
>>EXEC
>1) (integer) 1
>1) (integer) 1
>```
>
>当Redis连接处于MULTI请求的上下文中时，所有命令都将使用字符串`QUEUED`进行答复（从Redis协议的角度作为状态答复发送）。当调用EXEC时，仅将调度的命令排定为执行。

#### 3. 事务中的错误

>在事务期间，可能会遇到两种命令错误：
>
>- ==命令可能无法排队==，因此在调用EXEC之前可能存在错误。==此次事务是会被取消执行的，所有命令都不会被执行==。
>- ==调用EXEC后，命令可能会失败==。例如，因为我们对具有错误值的键执行了操作（例如，针对字符串值调用了列表操作）。==事务失败了但是命令执行的结果并没有回滚==。
>
>```
>MULTI
>+OK
>SET a abc
>+QUEUED
>LPOP a
>+QUEUED
>EXEC
>*2
>+OK
>-ERR Operation against a key holding the wrong kind of value
>```

#### 4. 为什么Redis不支持回滚？

>Redis命令在事务期间可能会失败，但Redis仍将执行事务的其余部分而不是回滚。
>
>这样做的优点：
>
>1. Redis 命令==只会因为错误的语法而失败==，或是==命令用在了错误类型的键上面==：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而==这些错误应该在开发的过程中被发现，而不应该出现在生产环境中==。
>2. 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

#### 5. WATCH监控(CAS)

>使用`WATCH`命令可以决定事务是执行还是回滚。
>
>- 一般而言，可以==在MULTI命令之前使用WATCH命令监控某些键值对==，然后使用multi命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命名就会进入队列。
>
>- 当使用`EXEC`命令执行事务的时候，会首先对比被WATCH命令所监控的键值对，如果没有发生变化，那么它会执行事务队列中的命令，提交事务；如果发生变化，那么不会执行事务中的任何命令。

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm61i2hdvj30ff0atmxf.jpg" style="zoom:100%">

>Redis参考多线程中使用的`CAS（比较与交换，Compare And Swap）`去执行的。在数据高并发环境的操作中，把这样的一个机制称为==乐观锁==。

>当一条线程去执行某些业务逻辑，但是这些业务逻辑操作的数据可能被其他线程共享了，这样会引发多线程中数据不一致的情况。
>
>为了克服这个问题，
>
>1. 首先，==在线程开始时读取这些多线程共享的数据，并将其保存到当前进程的副本中，称为旧值（old value）==，watch命令就是这样的一个功能。
>2. 然后，开启线程业务逻辑，由multi命令提供这一功能。==在执行更新前，比较当前线程副本保存的旧值和当前线程共享的值是否一致，如果不一致，那么该数据已经被其他线程操作过，此次更新失败==。
>3. 为了保持一致，线程就不去更新任何值，而将事务取消(DISCARD)；否则就认为它没有被其他线程操作过，执行对应的业务逻辑，EXEC命令就是执行类似这样的一个功能。

>注意，“类似”这个字眼，因为不完全是，原因是CAS原理会产生ABA问题。
>
>从上面的分析可以看出，Redis 在执行事务的过程中，并不会阻塞其他连接的并发，而只是==通过比较 watch 监控的键值对去保证数据的一致性==，所以 Redis 多个事务完全可以在非阻塞的多线程环境中并发执行，而且 ==Redis 的机制是不会产生 ABA 问题的（单线程，每个单独的操作都是原子的）==，这样就有利于在保证数据一致的基础上，提高高并发系统的数据读/写性能。

##### 5.1 示例

>演示一个提交的事务：
>
>| 时刻 | 客户端1         | 客户端2       | 说  明                                                       |
>| ---- | --------------- | ------------- | ------------------------------------------------------------ |
>| T1   | set key1 value1 |               | 客户端1：返回 OK                                             |
>| T2   | watch key1      |               | 客户端1：监控 key1                                           |
>| T3   | multi           |               | 客户端1：开启事务                                            |
>| T4   | set key2 value2 |               | 客户端1：事务命令入列                                        |
>| T5   | ——              | set key1 vall | 客户端2：修改 key1 的值                                      |
>| T6   | exec            | ——            | 客户端1：执行事务，事务会先检査在 T2 时刻<br/>被监控的key1是否被其他命令修改过。<br/>因为客户端 2 修改过，所以它会回滚事务，<br/>事实上如果客户端执行的是 set key1 value1 命令，它也会认为 key1 被修改过，<br/>然后返回（nil），所以是不会产生 ABA 问题的 |

