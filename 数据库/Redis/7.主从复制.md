#### 1. 主从复制

##### 1.1 概念

>将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为`主节点(master)`，后者称为`从节点(slave)`；==数据的复制是单向的==，只能由主节点到从节点。
>
>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

##### 1.2 作用

>1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
>2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
>3. 负载均衡：在主从复制的基础上，==配合读写分离，可以由主节点提供写服务，由从节点提供读服务==（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
>4. 高可用基石：除了上述作用以外，主从复制还==是哨兵和集群能够实施的基础==，因此说主从复制是Redis高可用的基础。

##### 1.3 如何使用

>建立复制：主从复制的开启，完全是在从节点发起的。有以下3种开启方式：
>
>1. 配置文件：`slaveof <masterip> <masterport>`
>2. 启动命令：`--slaveof <masterip> <masterport>`
>3. 客户端命令：`slaveof <masterip> <masterport>`

#### 2. 主从复制的实现原理

>可以分为3个阶段：<u>连接建立阶段（即准备阶段）</u>、<u>数据同步阶段</u>、<u>命令传播阶段</u>

##### 2.1 连接建立阶段

>1. 保存主节点信息
>
>   从节点服务器内部维护了两个字段：`materhost`和`masterport`。
>
>2. 建立socket连接
>
>   从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点ip和port，创建socket连接。如果连接成功，则：
>
>   - 从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。
>   - 主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。
>
>3. 发送ping命令
>
>   从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。
>
>   - 返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。
>   - 超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。
>   - 返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。
>
>4. 身份验证
>
>   如果从节点中设置了`masterauth`选项，则从节点需要向主节点进行身份验证（auth命令）
>
>5. 发送从节点端口信息
>
>   从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的`slave_listening_port`字段中。

##### 2.2 数据同步阶段(核心)

>主从节点之间的连接建立以后，便可以开始进行数据同步。具体执行的方式是：==从节点向主节点发送psync命令==，开始同步。
>
>根据主从节点当前状态的不同，可以分为==全量复制==和==部分复制==。
>
>需要注意的是，在数据同步阶段之前，<u>从节点是主节点的客户端</u>，主节点不是从节点的客户端；而到了这一阶段及以后，<u>主从节点互为客户端</u>。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。

##### 2.3 命令传播阶段

>在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
>
>在命令传播阶段，==除了发送写命令，主从节点还维持着心跳机制==：PING和REPLCONF ACK。
>
>==延迟与不一致==
>
>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的`repl-disable-tcp-nodelay`配置(多数情况使用默认值no)等有关。

##### 2.4 【数据同步阶段】全量复制和部分复制

>**全量复制**
>
>1. 从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。
>
>2. 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令
>
>3. 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态
>
>4. 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态
>
>5. 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态

>全量复制是非常重型的操作：
>
>1. 主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；
>
>2. 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗
>
>3. 从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗

>**部分复制**
>
>1. 复制偏移量
>2. 复制积压缓冲区
>3. 服务器运行ID(runid)

##### 2.5 psync命令(确定使用何种复制方式)

><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmn77hvo8ej30fe092mxe.jpg" style="zoom:100%">

##### 2.6 【命令传播阶段】心跳机制

>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。

>**主->从：PING**

>**从->主：REPLICONF ACK**

#### 3. 应用中的问题

##### 3.1 读写分离及其中的问题

>1. 延迟与不一致问题
>2. 数据过期问题
>3. 故障切换问题

##### 3.2 复制超时问题

>**超时判断的意义**

>**判断机制**

>**需注意的坑**
>
>1. 数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。
>
>2. 命令传阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。
>
>3. 慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。

##### 3.3 复制中断问题

>**复制缓冲区溢出**
>
>



