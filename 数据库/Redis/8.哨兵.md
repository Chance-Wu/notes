>Redis主从复制的作用有数据热备、负载均衡、故障恢复等；但==主从复制存在的一个问题是故障恢复无法自动化==。
>
>以下介绍的哨兵，它基于Redis主从复制，主要作用便是解决主节点故障恢复的自动化问题。

#### 1. 作用和架构

##### 1.1 作用

>回顾一下Redis实现高可用相关的技术。它们包括：
>
>- `持久化`：持久化是最简单的高可用方法，主要作用是<u>*数据备份*</u>，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
>- `主从复制`：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于*<u>读操作的负载均衡</u>*和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
>- `哨兵`：在复制的基础上，哨兵实现了*<u>自动化的故障恢复</u>*。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
>- `集群`：通过集群，*<u>解决了写操作无法负载均衡，以及存储能力受到单机限制的问题</u>*，实现了较为完善的高可用方案。

>**哨兵 Redis Sentinel**
>
>核心功能：==主节点的自动故障转移==。
>
>- `监控（Monitoring）`：哨兵会不断地检查主节点和从节点是否运作正常。
>- `自动故障转移（Automatic failover）`：==当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点==。
>- `配置提供者（Configuration provider）`：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。
>- `通知（Notification）`：哨兵可以将故障转移的结果发送给客户端。

##### 1.2 架构

><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmnazsqurbj30av08cglm.jpg" style="zoom:100%">
>
>- `哨兵节点`：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。
>- `数据节点`：主节点和从节点都是数据节点。

#### 2. 部署

##### 2.1 部署主从节点

>部署一个简单的哨兵系统，包含<u>*1个主节点*</u>、*<u>2个从节点</u>*和*<u>3个哨兵节点</u>*。方便起见：所有这些节点都部署在一台机器上，使用端口号区分；节点的配置尽可能简化。
>
>启动
>
>```bash
>redis-server redis-6379.conf
>redis-server redis-6380.conf
>redis-server redis-6380.conf
>```
>
>使用`info replication`命令查看节点状态。

##### 2.2 部署哨兵节点

>下面以26379节点为例介绍节点的配置和启动方式；配置部分尽量简化。
>
>```
>#sentinel-26379.conf
>port 26379
>daemonize yes
>logfile "26379.log"
>sentinel monitor mymaster 192.168.92.128 6379 2
>```
>
>`sentinel monitor mymaster 192.168.92.128 6379 2`配置的含义：==该哨兵节点监控192.168.92.128:6379这个主节点，该主节点的名称是mymaster，最后的2的含义与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移==。

>哨兵节点的两种启动方式：
>
>1. redis-sentinel sentinel-26379.conf
>2. redis-server sentinel-26379.conf  --sentinel
>
>启动完成后，通过redis-cli连接哨兵节点进行验证。`info sentinel`。

#### 3. 总结

>在故障转移阶段，哨兵和主从节点的配置文件都会被改写。
>
>注意点：
>
>1. 哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。
>
>2. ==哨兵节点本质上是redis节点==。
>
>3. 每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。
>
>4. 在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。
>
>5. 上述例子中，一个哨兵只监控了一个主节点；实际上，一个哨兵可以监控多个主节点，通过配置多条sentinel monitor即可实现。

#### 4. 哨兵基本原理

>1. 定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。
>
>2. 主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。
>
>3. 客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。
>
>**需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。**
>
>4. 选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。
>
>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。
>
>5. 故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：
>   - 在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。
>   - 更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。
>   - 将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。

#### 5. 实践建议

>1. 哨兵节点的数量应不止一个，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，这些不同的哨兵节点应部署在不同的物理机上。
>
>2. 哨兵节点的数量应该是奇数，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。
>
>3. 各个哨兵节点的配置应一致，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。
>
>4. 哨兵的配置提供者和通知客户端功能，需要客户端的支持才能实现，如前文所说的Jedis；如果开发者使用的库未提供相应支持，则可能需要开发者自己实现。
>
>5. 当哨兵系统中的节点在docker（或其他可能进行端口映射的软件）中部署时，应特别注意端口映射可能会导致哨兵系统无法正常工作，因为哨兵的工作基于与其他节点的通信，而docker的端口映射可能导致哨兵无法连接到其他节点。例如，哨兵之间互相发现，依赖于它们对外宣称的IP和port，如果某个哨兵A部署在做了端口映射的docker中，那么其他哨兵使用A宣称的port无法连接到A。

