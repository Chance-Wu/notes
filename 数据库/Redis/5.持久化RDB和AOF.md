Redis提供了不同的持久化选项：

>1. ==RDB（Redis DataBase）==：以指定的时间间隔执行行数据集的时间点快照。
>
>2. ==AOF（Append Only File）==：记录服务器接收的每个写入操作，将在服务器启动时再次执行，重建原始数据集。

>注意：
>
>可以在同一实例中组合AOF和RDB。在这种情况下，当Redis重新启动时，AOF文件将用于重建原始数据集，因为它保证是最完整的。

#### 1. Redis DataBase

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkpxl1f0aj30ls0eigmv.jpg" style="zoom:80%">

>在指定的时间间隔内==将内存中的数据集快照写入磁盘==，即Snapshot快照，它恢复时是将快照文件直接读到内存里。
>
>Redis会==单独创建（fork）一个子进程来进行持久化==，
>
>1. 会先将数据写入到一个临时文件中，
>2. 待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
>
>整个过程中，==主进程是不进行任何IO操作的，这就确保了极高的性能==。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

>RDB默认的持久化策略：`save <seconds> <changes>`
>
>```
>save 60 10000
>save 300 10
>save 900 1
>```

##### 1.1 fork

>fork的作用是==复制一个与当前进程一样的进程==。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并<u>作为原进程的子进程</u>。

##### 1.2 如何触发RDB

>- `save`：只管保存，其他不管，全部阻塞。
>- ``bgsave`：后台异步进行快照操作，快照同时还可以响应客户端请求。
>- `flushall`：也会产生dump.rdb，但里面是空的，无意义。

##### 1.3 如何恢复

>将dump.rdb移动到redis安装目录并启动服务即可。

##### 1.4 优势

>- RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备。
>- RDB对redis对外提供读写服务的时候，影像非常小，因为redis  主进程只需要fork一个子进程出来，让子进程对磁盘io来进行rdb持久化
>- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

##### 1.5 缺点

>- 如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，例如1:00进行的快照，在1:10又要进行快照的时候宕机了，这个时候就会丢失10分钟的数据。
>- RDB每次fork出子进程来执行RDB快照生成文件时，如果文件特别大，可能会导致客户端提供服务暂停数毫秒或者几秒

#### 2. Append Only File

>==以日志形式来记录每个写操作==，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，<u>redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</u>。

##### 2.1 AOF启动、修复、恢复

>dump.rdb文件和appendonly.aof文件可以共存，==启动的时候先找appendonly.aof，如果文件出错则启动失败。==
>
>修复：`redis-check-aof --fix appendonly.aof`

##### 2.2 重写

>当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令`bgrewriteaof`

>**原理**
>
>==fork出一条新进程来将文件重写（也是先写临时文件最后再rename）==，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

>**触发机制**
>
>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。

##### 2.3 优势

>- AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。
>- AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。
>- AOF日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删除紧急恢复，如果某人不小心用flushall命令清空了所有数据，只要这个时候还没有执行rewrite，那么就可以将日志文件中的flushall删除，进行恢复。

##### 2.4 缺点：

>- 对于同一份文件AOF文件比RDB数据快照要大。
>- AOF开启后支持写的QPS会比RDB支持的写的QPS低，因为AOF一般会配置成每秒fsync操作，每秒的fsync操作还是很高的
>- 数据恢复比较慢，不适合做冷备。

#### 3. 总结

>同时开启两种持久化方式：
>
>- 在这种情况下，当redis重启的时候就==会优先载入AOF文件来恢复原始的数据==，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
>- RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？建议不要，因为==RDB更适合用于备份数据库==（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

>性能建议：
>
>==RDB文件只用作后备用途，建议只在slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。==
>
>如果开了AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF重写的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF重写的频率，==AOF重写的基础大小默认值64M太小了，可以设到5G以上==。默认超过原大小100%时重写可以改到适当的数值。
>
>如果不开AOF，仅靠Mater-Slave Replication（主从复制）实现高可用性也可以。能省掉一大笔IO也减少了重写时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个，新浪微博就选用了这种架构。



