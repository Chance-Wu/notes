>Redis客户端执行一条命令分4个过程：
>
>`发送命令 —> 命令排队 —> 命令执行 —> 返回结果`
>
>这个过程称为`RTTR`（ound trip time，往返时间），mget、mset有效节约了RTT，但大部分命令不支持批量操作，需要消耗N次RTT，这个时候需要==pipelined==来解决这个问题。

><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmnelai7xj30ge0ayt8y.jpg" style="zoom:100%">
>
>在实际操作中，往往会发生这样的场景，当命令1在时刻T1发送到Redis服务器后，服务器就很快执行完了命令1，而命令2在T2时刻却没有通过网络送达Redis服务器，这样就变成了 Redis 服务器在等待命令 2 的到来，当命令 2 送达，被执行后，而命令 3 又没有送达，Redis 又要继续等待，依此类推，这样 Redis 的等待时间就会很长，很多时候在空闲的状态，而问题出在==网络的延迟==中，造成了系统瓶颈。

#### 1. 使用pipelined执行N条命令

>**Redis的流水线（pipelined）**：可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmnft791kj30jx0a0jro.jpg" style="zoom:100%">

#### 2. 结论

>使用Pipeline执行速度比逐条执行要快，特别是客户端与服务端的网络延迟越大，性能体能越明显。

#### 3. 原生批命令与pipelined对比

>1. ==原生批命令是原子性，pipeline是非原子性==
>
>(原子性概念：一个事务是一个不可分割的最小工作单位，要么都成功要么都失败。原子操作是指你的一个业务逻辑必须是不可拆分的。处理一件事情要么都成功，要么都失败，原子不可拆分)
>
>2. 原生批命令一命令多个key，但pipeline支持多命令（存在事务），非原子性
>
>3. 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成

#### 4. pipelined正确使用方式

>使用pipeline组装的==命令个数不能太多==，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的pipeline命令完成。

##### 4.1 Jedis中的pipelined使用步骤

>- 获取jedis对象（一般从连接池中获取）
>- 获取jedis对象的pipelined对象
>- 添加指令
>- 执行指令

