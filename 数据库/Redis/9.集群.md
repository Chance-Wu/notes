参考博客：[深入学习Redis](https://www.cnblogs.com/kismetv/p/9853040.html)

>Redis的持久化、主从复制和哨兵都解决不了<u>*存储能力受单机限制*</u>，以及*<u>无法实现写操作的负载均衡</u>*。
>
>Redis集群解决了上述问题，实现了较为完善的高可用方案。

#### 1. 集群的作用

>Redis Cluster，Redis 3.0开始引入的分布式存储方案。
>
>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：==只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制==。
>
>集群的作用，可以归纳为两点：
>
>1、数据分区：==数据分区==是集群最核心的功能。
>
>集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。
>
>Redis单机内存大小受限问题，在介绍持久化和主从复制时都有提及；例如，如果单机内存太大，bgsave和bgrewriteaof的fork操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……。
>
>2、高可用：集群==支持主从复制和主节点的自动故障转移==（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。

#### 2. 集群的搭建

>我们将搭建一个简单的集群：共==6个节点，3主3从==。方便起见：所有节点在同一台服务器上，以端口号进行区分；配置从简。3个主节点端口号：7000/7001/7002，对应的从节点端口号：8000/8001/8002。
>
>集群的搭建有两种方式：
>
>1. 手动执行Redis命令，一步步完成搭建；
>2. ==使用Ruby脚本搭建==。Ruby脚本将Redis命令进行了打包封装；在实际应用中推荐使用脚本方式，简单快捷不容易出错。

##### 2.1 执行Redis命令搭建集群

>1. 启动节点
>
>   ```
>   #redis-7000.conf
>   port 7000
>   cluster-enabled yes	# 启动集群模式
>   cluster-config-file "node-7000.conf"	# 指定生成集群文件的位置
>   logfile "log-7000.log"
>   dbfilename "dump-7000.rdb"
>   daemonize yes
>   ```
>
>   每个节点在运行过程中，会维护一份`cluster-config-file`，每当集群信息发生变化时（如增减节点），集群内所有节点会将最新信息更新到该配置文件；当节点重启后，会重新读取该配置文件，获取集群信息，可以方便的重新加入到集群中。
>
>   编辑好配置文件后，使用redis-server命令启动该节点：
>
>   ==redis-server redis-7000.conf==
>
>2. 节点握手
>
>   节点启动后是相互独立的，并不知道其他节点存在；需要进行握手，将独立的节点组成一个网络。例如在7000节点中执行cluster meet 192.168.72.128 7001，可以完成7000节点和7001节点的握手；注意ip使用的是局域网ip而不是localhost或127.0.0.1，是为了其他机器上的节点或客户端也可以访问。
>
>   ```
>   cluster meet 192.168.72.128 7002
>   cluster meet 192.168.72.128 8001
>   cluster meet 192.168.72.128 8002
>   cluster meet 192.168.72.128 8003
>   ```
>
>3. 分配槽
>
>   在Redis集群中，借助槽实现数据分区。==集群有16384个槽，槽是数据管理个迁移的基本单位。当数据库中的16384个槽都分配了节点时，集群处于上线状态(ok)；如果有任意一个槽没有分配节点，则集群处于下线状态(fail)==。
>
>   ```
>   # 将槽（编号0-16383）全部分配完毕
>   redis-cli -p 7000 cluster addslots {0..5461}
>   redis-cli -p 7001 cluster addslots {5462..10922}
>   redis-cli -p 7002 cluster addslots {10923..16383}
>   ```
>
>4. 指定主从关系
>
>   通过`cluster nodes`获得几个主节点的节点id后，执行下面的命令为每个从节点指定主节点。
>
>   ```
>   redis-cli -p 8000 cluster replicate be816eba968bc16c884b963d768c945e86ac51ae
>   redis-cli -p 8001 cluster replicate 788b361563acb175ce8232569347812a12f1fdb4
>   redis-cli -p 8002 cluster replicate a26f1624a3da3e5197dde267de683d61bb2dcbf1
>   ```

##### 2.2 使用Ruby脚本搭建集群

>在{REDIS_HOME}/src目录下的`redis-trib.rb`文件是一个Ruby脚本，可以实现自动化的集群搭建。以下以Ubuntu为例：

>1. 安装Ruby环境
>
>   ```bash
>   apt-get install ruby # 安装ruby环境
>   gem install redis # gem是ruby的包管理工具，该命令可以安装ruby-reids依赖
>   ```
>
>2. 启动节点
>
>   与第一种方法中的“启动节点”完全相同。
>
>3. 搭建集群
>
>   redis-trib.rb脚本提供了众多命令，其中create用于搭建集群：
>
>   ```
>   ./redis-trib.rb create --replicas 1 192.168.72.128:7000 192.168.72.128:7001 192.168.72.128:7002 192.168.72.128:8000 192.168.72.128:8001 192.168.72.128:8002
>   ```
>
>   --replicas 1表示每个主节点有一个从节点；多个{ip:port}，前面的做主节点，后面的做从节点。
>
>   执行命令后，脚本会给出创建集群的计划，包括：哪些是主节点，哪些是从节点，以及如何分配槽。
>
>   输入yes确认执行计划，脚本便开始按照计划执行。

##### 2. 3 集群方案设计

>考虑以下因素：
>
>1. 高可用要求：根据故障转移的原理，==至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上==；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此高可用集群==至少包含6个节点==。
>2. 数据量和访问量：估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的主节点数量。
>3. 节点数量限制：Redis官方给出的节点数量限制为1000，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：(1)业务分割，大集群分为多个小集群；(2)减少不必要的数据；(3)调整数据过期策略等。
>4. 适度冗余：Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。

#### 3. 集群的基本原理

>集群最核心的功能是数据分区。

##### 3.1 数据分区方案

>

##### 3.2 节点通信机制

>

##### 3.3 数据结构

>

##### 3.4 集群命令的实现

>

#### 4. 客户端访问集群

##### 4.1 redis-cli

>当节点收到redis-cli发来的命令时，过程如下：
>
>1. 计算key属于那个槽：`CRC16(key) & 16383`
>2. 判断key所在的槽是否在当前节点：假设key位于第i个槽，clusterState.slots[i]则指向了槽所在的节点，如果clusterState.slots[i]==clusterState.myself，说明槽在当前节点，可以直接在当前节点执行命令；否则，说明槽不在当前节点，则查询槽所在节点的地址(clusterState.slots[i].ip/port)，并将其包装到MOVED错误中返回给redis-cli。
>3. redis-cli收到MOVED错误后，根据返回的ip和port重新发送请求

##### 4.2 Jedis

>1. JedisCluster初始化时，在内部维护slot->node的缓存，方法是连接任一节点。
>2. 此外，JedisCluster为每个节点创建连接池(即JedisPool)。
>3. 当执行命令时，JedisCluster根据key->slot->node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现MOVED错误时，使用cluster slots重新同步slot->node的映射关系。

>注意事项：
>
>1. JedisCluster中已经包含所有节点的连接池，因此==JedisCluster要使用单例==。
>
>2. 客户端维护了slot->node映射关系以及为每个节点创建了连接池，当节点数量较多时，应注意客户端内存资源和连接资源的消耗。





