>Redis是基于内存而运行的数据集合，也存在着对内存垃圾的回收和管理的问题。
>
>内存对于一个系统是最为宝贵的资源，而且它远远没有磁盘那么大，所以对于 Redis 的键值对的内存回收也是一个十分重要的问题，如果操作不当会产生 Redis 宕机的问题，使得系统性能低下。
>
>一般而言，当内存不足时 Redis 会触发自动垃圾回收的机制。
>
>- `del`命令可以删除一些键值对。
>- 当内存运行空间满了之后，它还会按照回收机制去自动回收一些键值对，但是当垃圾进行回收的时候，又有可能执行回收而引发系统停顿，因此选择适当的回收机制和时间将有利于系统性能的提高。

#### 1. 键值对的超时命令

>| 命令                     | 说明                                      |
>| ------------------------ | ----------------------------------------- |
>| persist key              | 持久化key，取消超时时间                   |
>| ttl key                  | 查看超时时间                              |
>| expire key seconds       | 设置超时时间戳（秒）                      |
>| expireat key timstamp    | 设置超时时间点（uninx时间戳确定）         |
>| pptl key milliseconds    | 查看key的超时时间戳（毫秒计算）           |
>| pexpire key              | 设置键值超时的事件（毫秒）                |
>| pexpireat key stamptimes | 设置超时时间点（毫秒为单位的uninx时间戳） |

#### 2. 超时键值对的回收

>如果 key 超时了，Redis 会回收 key 的存储空间吗？
>
>不会，key超时不会被自动回收，只会标识哪些键值对超时了。这样做的一个好处在于，如果一个很大的键值对超时，比如一个列表或者哈希结构，存在数以百万个元素，要对其回收需要很长的时间。如果采用超时回收，则可能产生停顿。

>Redis提供两种方式回收这些超时键值对：
>
>- ==定时回收==：是指在确定的某个时间触发一段代码，回收超时的键值对。
>  - 如果这些键值对比较多，则 Redis 需要运行较长的时间，从而导致停顿。一般会选择在没有业务发生的时刻触发 Redis 的定时回收，以便清理超时的键值对。
>- ==惰性回收==：则是当一个超时的键，被再次用 get 命令访问时，将触发 Redis 将其从内存中清空。
>  - 要执行一个莫名其妙的 get 操作，或者在某些时候，我们也难以判断哪些键值对已经超时。

#### 3. 6种内存回收策略

>在 Redis 的配置文件中，当 Redis 的内存达到规定的最大值(`maxmemory`)时，允许配置 6 种策略(`maxmemory-policy`)中的一种进行淘汰键值，并且将一些键值对进行回收。
>
>| 策略                 | 说明                                                         |
>| -------------------- | ------------------------------------------------------------ |
>| volatile-lru         | 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 |
>| volatile-ttl         | 从已设置过期时间的数据集中挑选将要过期的数据淘汰             |
>| volatile-random      | 从已设置过期时间的数据集中任意挑选数据淘汰                   |
>| allkeys-lru          | 从数据集中挑选最近最早使用的数据淘汰                         |
>| allkeys-random       | 从数据集中任意选择数据淘汰                                   |
>| no-enviction（默认） | 禁止驱逐数据                                                 |

