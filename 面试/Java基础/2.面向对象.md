### 1. 面向对象与面向过程

二者都是一种思想。面向过程：强调的是功能行为。面向对象，==将功能封装进对象==，强调*具备了功能的对象*。

> ==类==和==对象==是面向对象的核心概念：*类是对一类事物的描述，是抽象的，概念上的定义*。对象是实际存在的该类事物的每个个体，因而也称实例（instance）。

面向对象的落地法则：

* 设计类，并设计类的成员（成员变量&成员方法）
* 通过类来创建类的对象
* 通过“对象.成员变量”或“对象.成员方法”来调用，完成相应的功能。

#### 1.1 面向对象的三大特征

* 封装（Encapusulation）：封装隐藏了对象的属性和实施细节。
* 继承（Inheritance）
* 多态（Polymorphism）

#### 1.2 类与类之间的关系

- [ ] 关联关系
- [ ] 继承关系
- [ ] 聚合关系：聚合、组合

### 2. 成员变量 vs 局部变量

相同点：

* 遵循变量声明的格式：修饰符 数据类型 变量名 = 初始化值；
* 都有作用域。

不同点：

* 声明的位置不同，成员变量声明在类里，方法外，局部变量声明在方法内，方法的形参部分，代码块内。
* 成员变量的访问权限修饰符有4个：public private protected default，局部变量没有修饰符，与所在方法相同。
* 成员变量，如果在声明的时候，不显式地赋值 ，那么不同数据类型会有不同的默认初始化值。局部变量，一定要显式的赋值。(==局部变量没有默认初始化值==)
* 二者在内存中存放的位置不同：*成员变量存在于堆空间*。*局部变量，栈空间中*。

#### 2.1 变量的分类

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy0h5yad5j30hi0ckt9n.jpg" style="zoom:70%">

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy0jh58rqj30mu0bm0tu.jpg" style="zoom:100%">

### 3. 类的方法

#### 3.1 什么是方法

* 方法是类或对象行为特征的抽象，也称为函数。
* Java里的方法不能独立存在，所有方法必须定义在类里。

#### 3.2 方法的调用

方法调用阶段唯一的任务就是确定调用哪一个方法。在程序运行时，进行方法调用是最普遍和最频繁的操作，但是class文件的编译过程中不包含传统编译中的连接步骤，==一切方法调用在class文件里面存储的都只是符号引用==，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。

所有方法调用中的目标方法在class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。*换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法调用被称为解析（Resolution）*。

在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括==静态方法==和==私有方法==两大类，前者与类型直接相关，后者在外部不可被访问，这两种方法各自的特点决定了他们都不可能通过继承或者别的方式重写其他版本，因此他们都适合*在类加载阶段进行解析*。

与之相对应的，在java虚拟机里面提供了5条方法调用字节码指令，分别如下：

1. invokestatic：调用静态方法
2. invokespecial：调用实例构造器<init>方法、私有方法和父类方
3. invokevirtual：调用所有的虚方法。
4. invokeinterface：调用接口方法，会在运行时在确定一个实现此接口的对象。
5. invokedynamic：先在运行时动态解析出调用点限定符号所引用的方法，然后在执行该方法，在此之前的4条调用指令，分派逻辑是固化在java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

> 只要能被*invokestatic*和*invokespecial*指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有*<u>静态方法、私有方法、实例构造器、父类方法4种</u>*，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可称为非虚方法，与之相反，其他方法称为虚方法（除去final方法）。参见如下代码，演示了一个最常见的解析调用的例子，此样例中，静态方法sayHello()只可能属于类型StaticResolution，没有任何手段可以覆盖或隐藏这个方法。

```java
public class StaticResolution {
    public static void sayHello() {
        System.out.printlb("hello");
    }
    
    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}
```

使用javap -v命令查看这段程序的字节码，会发现是通过invokestatic命令来调用sayHello方法的，如下图：
<img src="../../../../Pictures/assets/image-20200921100520459.png" style="zoom:80%">

<u>*虽然final修饰的方法使用invokevirtual指令来调用*</u>，但是由于它无法被覆盖，没有其他版本，所以也无需对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。==final方法是一种非虚方法==。

>==解析调用==是一个静态过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及到的符号引用全部转变为可确定的直接引用，不会延迟到运行期才完成。而==分派（dispatch）调用==则可能是静态的也可能是动态的，根据分派的总量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。

#### 3.3 方法的重载

> 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。（只看参数列表）

#### 3.4 方法的参数传递

实参值如何传入方法？
Java里方法的参数传递方式只有一种：**值传递机制**。即将实际参数值的副本传入方法内，而**参数本身不受影响**。

* 形参是**基本数据类型**：将实参的值传递给形参的基本数据类型的变量。
* 形参是**引用数据类型**：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。

#### 3.5 可变个数的形参

`public static void test(int a, String...books);`

* 声明方式：方法名(参数的类型名==...==参数名)。
* 方法的参数部分有可变形参，需要==放在形参声明的最后==。

### 4. 构造器

#### 4.1 构造器属于类的方法吗？

> 类成员是很明确的有三种： 
>
> 1. Filed：成员变量 
> 2. Method：普通方法 
> 3. Type：内部定义的其他类型，如内部接口、内部类等

**Constructor** 是负责对一个对象进行初始化的，会在对象创建完成后由系统执行，*它本身并不是类的成员，更不是一个“方法”*。既然**Constructor** 都不是个“方法”，那就没有返回值这个问题了？毕竟返回值是”方法“才有的特性。
Java虚拟机层面Constructor和Method的区别：

* 构造器在字节码层面，是对应于一个名字为xxx的代码块，由编译器去生成，会在对象创建完成后需要初始化的时候进行执行。
* 两者的执行在虚拟机层面也是有区分的，它们会使用不同的虚拟机指令来执行，对应的虚拟机指令：
  * Constructor：使用invokespecial指令来执行。
  * Method：使用invokevirtual指令来执行。

#### 4.2 构造器的作用

* 创建对象
* 给对象进行初始化

#### 4.3 构造器的特征

* 具有与类相同的名称。
* 不声明返回值类型。
* 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。

> 注意：
>
> * Java语言中，每个类都至少有一个构造器。
> * 默认构造器的修饰符与所属类的修饰符一致。
> * 一旦显式定义了构造器，则系统不再提供默认构造器。
> * **父类的构造器不可被子类继承**。

#### 4.4 构造器重载

* 构造器用来创建对象的同时初始化对象。
* 构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。
* 构造器重载，参数列表必须不同。

### 5. this关键字

> 作用：
>
> * 在**Method**内部使用，即这个方法*<u>所属对象的引用</u>*。
> * 在**Constructor**内部使用，表示该*<u>构造器正在初始化的对象</u>*。

#### 5.1 什么时候使用this关键字?

* 当在方法内部需要用到调用该方法的对象时，就用this。
* 使用this调用属性、方法。
  * 当形参与成员变量重名时，如果在方法内部需要使用成员变量，必须添加this来表明该变量是类的成员变量。
  * 在任意方法内，如果使用当前类的成员变量或成员方法，可以在前面添加this，增强程序的阅读性。
* ==使用this调用本类的构造器==。

> 注意：
>
> * 使用this()必须==放在构造器的首行==。
> * 使用this调用本类中其他的构造器，保证==至少有一个构造器是不用this的==。

### 6. JavaBean

* JavaBean是一种Java语言写成的可重用组件。
* 符合如下标准的Java类:
  * 类是公共的。
  * 有一个无参的公共的构造器。
  * 有成员变量，且有对应的get、set方法。

### 7. UML类图

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giy7rtcah3j30jo08q3yu.jpg" style="zoom:80%">

* +表示public类型，-表示private类型，#表示protected类型
* 方法的类型(+、-) 方法名(参数名: 参数类型): 返回值类型

### 8. 关键字package、import

#### 8.1 package

* package帮助管理大型软件系统：将语义近似的类组织到包中；解决类命名冲突的问题；
* 包可以包含类和子包；

* package语句作为Java源文件里的第一条语句，指明该文件中定义的类所在的包。（若缺省该语句，则指定为无包名）。

#### 8.2 import

* 为使用定义在不同包中的Java类，需要import语句来引入指定包层次下所需要的类或全部类(.*)。**import语句告诉编译器到哪里去寻找类**。
* 注意：
  * 若引入的包为：java.lang，则编译器默认可获取此包下的类，不需要再显示声明。
  * import语句出现在package语句之后、类定义之前。
  * 可以使用==import lee.;==语句，表明导入lee包下的所有类。而lee包下sub子包内的类则不会被导入。
  * import语句不是必需的，可以在类里使用其它类的全名
  * JDK 1.5加入import static语句

#### 8.3 JDK中主要包介绍

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |



| 包        | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| java.lang | 一些java语言的核心类，如String、Math、Integer、System和Thread。 |
| java.net  | 执行与网络相关的操作的类和接口。                             |
| java.io   | 提供多种输入/输出功能的类。                                  |
| java.util | 实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 |
| java.text | 格式化相关的类。                                             |
| java.sql  | 进行JDBC数据库编程的相关类/接口                              |

### 9. Java的四种引用方式

- 强引用：指创建一个对象并把这个对象赋给一个引用变量。（强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。）
- 软引用（SoftReference）：可用来实现内存敏感的高速缓存，比如网页缓存、图片缓存等。使用软引用能防止内存泄露。（SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收）。
- 弱引用（WeakReference）
- 虚引用（PhantomReference）

> 软引用和弱引用
>
> 对于强引用，编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是==软引用==和==弱引用==。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。
>
> 在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）

```java
public class FourReferenceTest {

    @Test
    public void testSoftReference() {
        Obj obj = new Obj();
        //使用obj
        obj.test();
        //使用完了obj,将它设置为soft引用类型,并且释放强引用
        SoftReference sr = new SoftReference(obj);
        obj = null;

        //下次使用
        if (sr != null) {
            obj = (Obj) sr.get();
            obj.test();
        } else {
            //GC由于低内存,已释放obj,因此需要重新装载
            obj = new Obj();
            obj.test();
            obj = null;
            sr = new SoftReference(obj);
        }
    }

    class Obj {
        public void test() {
            System.out.println("SoftReference test");
        }
    }
}
```



#### 9.1 如何利用软引用和弱引用解决OOM问题

举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。

设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。

