在高性能硬件上部署程序，目前主要有两种方式：

- 通过 64 位 JDK 来使用大内存；
- 使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。



### 一、使用 64 位 JDK 管理大内存

---

堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为 14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。

对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。

可能面临的问题：

- 内存回收导致的长时间停顿；
- 现阶段，64 位 JDK 的性能普遍比 32 位 JDK 低；
- 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；
- 相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。



### 二、使用 32 位 JVM 建立逻辑集群

---

在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。

考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。

可能遇到的问题：

- 尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常；
- 很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；
- 各个节点受到 32 位的内存限制；
- 大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。



### 三、调优案例分析与实战

---

#### 3.1 场景描述

一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志），但再次发生内存溢出时，没有生成相关异常日志。

#### 3.2 分析

在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。

**32 位 JVM 的内存寻址限制**

- 

- **32位JVM最多只能使用约 3.2GB ~ 3.5GB 的虚拟地址空间**（取决于操作系统和JVM本身开销）。

- 即使物理内存有4GB，32位JVM也无法完全利用。

- JVM本身需要内存用于堆（heap）、方法区（Metaspace/PermGen）、线程栈、直接内存（Direct Buffer）、JIT编译代码等。

- 如果你设置了较大的堆（如 `-Xmx3g` 或更高），

  剩余空间不足以容纳非堆内存，很容易导致：

  - `java.lang.OutOfMemoryError: Java heap space`
  - `java.lang.OutOfMemoryError: GC overhead limit exceeded`
  - `java.lang.OutOfMemoryError: unable to create new native thread`
  - **甚至在尝试生成堆转储时因无足够内存而失败**

`-XX:+HeapDumpOnOutOfMemoryError` 需要在发生 OOM 后尝试生成一个 `.hprof` 文件，这个过程本身需要：

1. **额外的本地内存（native memory）来执行序列化操作**
2. **足够的磁盘空间**
3. **JVM进程仍有能力执行异常处理逻辑**

但在32位JVM中，当发生OOM时，很可能已经：

- 耗尽了所有虚拟地址空间
- 没有足够本地内存来触发 `HeapDump`
- JVM处于不稳定状态，无法完成文件写入

> 所以：**不是参数没生效，而是JVM已经“瘫痪”，无法执行生成dump的操作。**

#### 3.3 解决方案

1. 升级到 64 位 JDK（推荐）

   | 项目           | 32位JDK                   | 64位JDK                |
   | -------------- | ------------------------- | ---------------------- |
   | 最大堆大小     | ~3.5GB                    | 可设置几十GB           |
   | 地址空间       | 4GB（共享给所有内存区域） | 几乎无限制（64位寻址） |
   | 支持大内存应用 | ❌ 不支持                  | ✅ 支持                 |

2. 合理设置 JVM 参数（临时缓解）

   ```bash
   # 示例：保守设置堆大小，留足非堆空间
   -Xms1g
   -Xmx2g
   -XX:MaxMetaspaceSize=256m
   -Xss256k                 # 减小线程栈大小（默认1M，太大会吃内存）
   -XX:+HeapDumpOnOutOfMemoryError
   -XX:HeapDumpPath=/path/to/dump.hprof
   ```

   >⚠️ 注意：`-Xmx` 不要超过 2.5G，否则很可能无法生成 dump。

3. 检查是否真的触发了HeadDump

   添加显示路径和日志

   ```bash
   -XX:+HeapDumpOnOutOfMemoryError
   -XX:HeapDumpPath=/tmp/heapdump.hprof
   -XX:+PrintGCDetails
   -XX:+PrintGCDateStamps
   -XX:+PrintCommandLineFlags
   -Xloggc:/tmp/gc.log
   ```

   然后检查：是否有GC日志；OOM异常是否真的发生在堆（heap）而不是其他区域？`/tmp/` 目录是否有写权限？磁盘是否满？

4. 确认 OOM 类型

   不是所有的 `OutOfMemoryError` 都会触发 HeapDump。

   `-XX:+HeapDumpOnOutOfMemoryError` **只对 `Java heap space` 类型的OOM有效**。

   其他类型的OOM不会生成堆转储，例如：

   | OOM类型                              | 是否生成HeapDump   |
   | ------------------------------------ | ------------------ |
   | `Java heap space`                    | ✅ 是               |
   | `Metaspace` / `PermGen space`        | ❌ 否（默认不生成） |
   | `unable to create new native thread` | ❌ 否               |
   | `Direct buffer memory`               | ❌ 否               |

5. 手动触发堆转储辅助分析

   在服务运行期间，使用工具主动抓取内存快照：

   ```bash
   # 查看Java进程
   jps
   ```

   ```bash
   # 生成堆转储
   jmap -dump:format=b,file=/tmp/heap.hprof <pid>
   ```

   ```bash
   # 或使用 jcmd
   jcmd <pid> GC.run_finalization
   jcmd <pid> VM.gc
   jcmd <pid> GC.run
   jcmd <pid> VM.class_hierarchy java.lang.Object
   jcmd <pid> VM.system_properties
   jcmd <pid> Thread.print
   ```

6. 监控与诊断工具

   - 使用 `jstat` 观察GC情况
   - 使用 `jstack <pid>` 查看线程状态（是否有大量线程？死锁？）
   - 使用 `top` / `htop` 查看进程实际内存使用（RES/VIRT）