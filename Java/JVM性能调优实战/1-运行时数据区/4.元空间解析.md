**元空间就是方法区的实现。**

> 当JVM使用类装载器装载某个类时：
>
> - 它首先要定位对应的class文件，然后读入这个class文件。
> - 最后，JVM提取该文件的内容信息，并将这些信息存储到方法区，最后返回一个class实例。
>
> 上面是对类的装载过程作了个简单的描述，看了上面一段文字，也许你会问：方法区是什么？里面存了哪些内容？

#### 1. 方法区是什么？有哪些特点？

> 1、存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等，回收目标主要是常量池的回收和类型的卸载，各线程共享
> 2、**方法区**在**JDK1.7**的时候叫做**永久代**，到**JDK1.8**之后废弃了永久代改为**元空间**（meta space）
>
> 方法区是系统分配的一个内存逻辑区域，是用来==存储类型信息==的（类型信息可理解为类的描述信息）。
>
> 方法区主要有以下几个特点：
>
> 1. 方法区是线程安全的。==由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的==。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待 。
>
> 2. 方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。
> 3. 方法区也可被垃圾收集，当某个类不再被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。

#### 2. 方法区里存放的是哪些内容

##### 2.1 类型信息

> - 类型的全限定名
> - 超类的全限定名
> - 直接超接口的全限定名
> - 类型标志（该类是类类型还是接口类型）
> - 类的访问描述符（public、private、default、abstract、final、static）

##### 2.2 类型的常量池

> （独有的，运行时，把该部分加载进运行时常量池，当调用时则从符号引用解析为直接引用，但是有些确定的方法会直接转换，比如静态方法，比如构造方法）
>
> 存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的符号引用，所以它也是动态连接(栈中对应的方法指向这个引用)的主要对象（在动态链接中起到核心作用）。

##### 2.3 字段信息（该类声明的所有字段）

> - 字段修饰符
> - 字段的类型
> - 字段名称

##### 2.4 方法信息

> 方法信息中包含类的所有方法，每个方法包含以下信息：
>
> - 方法名
> - 方法的返回类型（包括void）
> - 方法参数的类型、数目以及顺序
> - 方法修饰符（public,private,protected,static,final,synchronized,native,abstract）
>
> 针对本地方法，还有些附加方法信息需要存储在方法区内：
>
> - 方法字节码
> - 方法中局部变量区的大小
> - 方法栈帧
> - 异常表

##### 2.5 类变量（静态变量）

> 指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。

##### 2.6 指向类加载器的引用

> 每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。

##### 2.7 指向Class实例的引用

> 类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(StringclassName)来查找获得该实例的引用，然后创建该类的对象。

##### 2.8 方法表

> 为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。

#### 3. 栈、堆、方法区的关系

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmafi5ylr5j30yg0gi0vk.jpg" style="zoom:50%">

>- 方法区（Method Area）与Java堆一样，是各个==线程共享==的内存区域。
>- 方法区在==JVM启动的时候被创建==，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。（可以选择固定大小或者可扩展）
>- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样抛出内存溢出的错误：java.lang.OutOfMemoryError:PermGen space 或者java.lang.OutOfMemoryError：Metaspace加载大量的第三方jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类
>- 关闭JVM就会释放这个区域的内存

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmafim6ggdj30jq062dgb.jpg" style="zoom:60%">

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmafly12ikj30qe0eejs7.jpg" style="zoom:60%">

##### 3.1 方法区的演进

>- 在jdk7以及以前，习惯上把方法区，称为永久代。jdk8开始，使用==元空间==取代了永久代，并且==存储在直接内存中==。
>- 本质上，方法区和永久代并不等价。仅是对hotspot而言的，《Java虚拟机规范》对如何实现方法区，不做统一要求。例如JRockit / IBM J9中不存在永久代的概念。
> - 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermSize上线）。

#### 4. 如何解决OOM

>使用`jps`查看程序的端口，如12345使用`jinfo -flag MetaspaceSize 12345`即可查看。
>
>1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）.
>2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。
>3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器屋里内存对比看是否还可以调大，从代码上检查是否存在某些对象声明周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

#### 5. 方法区的内部结构

><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmafrcjtb3j311y05o3zo.jpg" style="zoom:50%">
>
>用于存储已被虚拟机加载的`类型信息`、`常量`、`静态变量`、`即时编译器编译后的代码缓存`等。

##### 5.1 类型信息

>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
>
>1. 这个类型的完整有效名称（全名=包名.类名）
>2. 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
>3. 这个类型的修饰符（public，abstract，final的某个子集）
>4. 这个类型直接接口的一个有序列表

5.2 域（Field信息）

>1. JVM必须在方法区中保存类型的==所有域的相关信息==以及==域的声明顺序==。
>2. 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

##### 5.3 方法(Method)信息

>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
>
>- 方法名称
>- 方法的返回类型（或void）
>- 方法参数的数量和类型（按顺序）
>- 方法的修饰符（public private protected static final synchronized native abstract）
>- 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
>- 异常表（abstract和native方法除外）
>   * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

##### 5.4 全局常量：static final

> 被声明为final的类变量的处理方法则不同，==每个全局常量在编译的时候就会被分配了==。可以通过`javap -v -p Obj.class`命令查看。
>
> ```java
> public class Obj {
> 
>  public static int i = 10;
> 
>  public final static int j = 10;
> 
>  public final int k = 10;
> 
>  public int m = 10;
> }
> ```
>
> ```
> public static int i;
>  descriptor: I
>  flags: ACC_PUBLIC, ACC_STATIC
> 
> public static final int j;
>  descriptor: I
>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
>  ConstantValue: int 10
> 
> public final int k;
>  descriptor: I
>  flags: ACC_PUBLIC, ACC_FINAL
>  ConstantValue: int 10
> 
> public int m;
>  descriptor: I
>  flags: ACC_PUBLIC
> ```

##### 5.5 运行时常量池

>常量池表：一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种==字面量和对类型、域、和方法的符号引用==。
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmags1cmjjj312a0eimy3.jpg" style="zoom:50%">
>
>- 常量池表是Class文件的一部分，==用于存放编译器生成的各种字面量与符号引用==，这部分内容将在类加载后存放到方法区的运行时常量池中。
>- 在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
>- ==JVM为每个已加载的类型（类或者接口）都维护一个常量池==。池中的数据项像数组项一样，是通过索引访问的。
>- 运行时常量池中包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里==换为真实地址==。
> - 运行时常量池，相对于Class文件常量池的另一个重要特征是：==具备动态性==。
>- 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
>- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值。则JVM会抛出OutOfMemoryError异常。

#### 6. 方法区使用举例

>```java
>public class JvmTest01 {
>public static void main(String[] args) {
>   int x = 500;
>   int y = 100;
>   int a = x / y;
>   int b = 50;
>   System.out.println(a + b);
>}
>}
>```
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai1kqumhj30u01bwjyo.jpg" style="zoom:50%">
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai2mtm21j30u01c2103.jpg" style="zoom:50%">
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai3n0w4bj30u01ce7bj.jpg" style="zoom:50%">
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai4jce3ej30u01cw7c4.jpg" style="zoom:50%">
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai5eobprj30u01cd461.jpg" style="zoom:50%">
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai5eobprj30u01cd461.jpg" style="zoom:50%">

#### 7. 方法区的演进细节

>Hotspot中方法区的变化：
>
>- jdk1.6之前有永久代，静态变量存放在永久代上
>- jdk1.7有永久代，但已经逐步”去永久代“。字符串常量池、静态变量移除，保存在堆中
>- jdk1.8及之后无永久代，==类型信息、字段、方法、常量保存在本地内存的元空间==，但==字符串常量池、静态变量仍在堆中==。
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai8t5u4ej30u013dgoz.jpg" style="zoom:50%">

##### 7.1 永久代为什么要被元空间替换

>1. 为永久代设置空间大小是很难确定的。
>    在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM。比如某个实际WEB工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。
>    而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下仅受本地内存限制。
>2. 对永久代进行调优是很困难的。

##### 7.2 String Table为什么要调整

>jdk7中==将StringTable放到了堆空间中==。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致==StringTable回收效率不高==。放到堆里，能及时回收内存。

#### 8. 方法区的垃圾回收

>《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）
>
>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。
>
>方法区的垃圾收集主要回收两部分内容：==常量池中废弃的常量和不再使用的类型==
>
>- 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
>   1. 类和接口的全限定名
>   2. 字段的名称和描述符
>   3. 方法的名称和描述符
>- Hotspot虚拟机对常量池的回收策略是很明确调的，==只要常量池中的常量没有被任何地方引用，就可以被回收==。
>- 回收废弃常量与回收Java堆中的对象非常类似。
>- 判断一个常量是否”废弃“还是相对简单的，而要判定一个类型是否属于”不再被使用的类“的条件就比较苛刻了。需要同时满足下面三个条件：
>   1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
>   2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的课替换类加载器的场景，如OSGi、JSP的重加载等，否则通常很难达成的。
>   3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
>- Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是”被允许“，而不是和对象一样，没有引用了就必然回收。关于是否要对类型进行回收，Hotspot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息
>- 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。