#### 什么是类的加载（类初始化）

>当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过==<u>加载</u>==、<u>==连接==</u>、<u>==初始化==</u>3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
>
>在java代码中，**类型**的==加载==、==连接==、与==初始化==过程都是在==程序运行期间==完成的（类从磁盘加载到内存中经历的三个阶段）
>
>1类型
>
>定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息。
>
>2）程序运行期间
>
>程序运行期间完成典型例子就是*<u>动态代理</u>*，其实很多语言都是在编译期就完成了加载，也正因为这个特性给Java程序提供了更大的灵活性，增加了更多的可能性。

##### 类加载注意事项

>1. 类加载器并不需要等到某个类被“首次主动使用”时再加载它。
>2. ==JVM规范允许类加载器在预料某个类将要被使用时就预先加载它==
>3. 如果在预先加载的过程中遇到了`.class`文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（`LinkageError`错误）。如果这个类一直没有被程序**主动使用**，那么类加载器就不会报告错误。

##### 类的生命周期

>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括 7 个阶段，而验证、准备、解析 3 个阶段统称为连接。
>
>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是固定确定的，类的加载过程必须按照这种顺序开始，而==解析阶段则不一定：它在某些情况下可以在初始化后再开始==，这是为了支持 Java 语言的运行时绑定【也就是java的动态绑定/晚期绑定】。
>
><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3xpwk8zcj310i0c80us.jpg" style="zoom:45%">

#### 1. 加载

><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6sdr8q5ij30pm08x0sz.jpg" style="zoom:60%">
>
>加载阶段指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 `java.lang.Class`对象（==HotSpot虚拟机将其放在方法区中==），==用来封装类在方法区内的数据结构==。类的加载的最终产品是位于堆区中的 `Class`对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
>
>Class对象位置【HotSpot虚拟机】：
>
>在JDK1.7是在**方法区**中或者说**永久代**中
>在JDK1.8放在**方法区**或者说**元空间中**中
>
>永久代和元空间最大的区别：==JKD7的永久代放在堆中并且独立于堆==，==JKD8的元空间完全剥离虚拟机，存在于直接内存中==。

##### 1.1 理解 Class对象与new出来的对象之间的关系

>可以把car的`Class`类看成具体的一个人，而`new car`则是人物映像，具体的一个人（`Class`）是唯一的，人物映像（`new car`）是多个的。每个`new`出来的对象都是以`Class`类为模板参照出来的！为啥可以参照捏？因为==Class对象提供了访问方法区内的数据结构的接口==哇，上面提及过了喔！

##### 1.2 总结

>**.class文件（二进制数据）——>读取到内存——>数据放进方法区——>堆中创建对应Class对象——>并提供访问方法区的接口**
>
>==加载阶段获取类的二进制字节流的动作是可控性最强的阶段==，既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
>
>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 `java.lang.Class`类的对象，这样便可以通过该对象访问方法区中的这些数据。

>加载.calss文件的方式：
>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，==JVM提供的这些类加载器通常被称为系统类加载器==。除此之外，可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器，可以从不同来源加载类的二进制数据，二进制数据通常有如下几种来源：
>
>1）从本地系统中直接加载
>2）通过网络下载.class文件
>3）从zip，jar等归档文件中加载.class文件
>4）从专用数据库中提取.class文件
>5）将java源文件动态编译为.class文件

#### 2. 验证

>确保被加载的类的正确性。
>
>- 文件格式验证
>- 元数据验证
>- 字节码验证
>- 符号引用验证

#### 3. 准备【重点】

>准备阶段是正式为类变量分配内存并设置类变量的初始值的阶段，即==在方法区中分配这些变量所使用的内存空间==。
>
>注意两个关键点，即<u>内存分配的对象</u>以及<u>初始化的类型</u>。

##### 3.1 内存分配的对象

>Java中的变量有==类变量==(被static修饰过)以及==类成员变量==。
>
>在准备阶段，JVM只会为类变量分配内存。
>
>例如下面的代码在准备阶段，只会为 `v`属性分配内存，而不会为 `y`属性分配内存。
>
>```java
>public static int v = 8080;
>public String y = "jvm";
>```

##### 3.2 初始化的类型

>在准备阶段，JVM 会为类变量分配内存，并为其初始化。这里的初始化指的是为变量赋予 Java 语言中该数据类型的默认值，而不是用户代码里初始化的值。
>
>1）变量v在准备阶段过后的初始值为0而不是8080。
>
>```java
>public static int v = 8080;
>```
>
>2）但是，如果一个变量被static final的话，那么在准备阶段，属性便会被赋予用户希望的值8080。在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。
>
>```java
>public static final int v = 8080;
>```
>
>两个语句的区别是一个有 `final` 关键字修饰，另外一个没有。而 `final` 关键字在 Java 中代表不可改变的意思，意思就是说`v`的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 `final` 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 `final` 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。

#### 4. 解析

>将Class中的常量池中的==符号引用==解析为==直接引用==，其中直接引用包含：*<u>句柄</u>*，*<u>指针</u>*，*<u>内存偏移量</u>*。
>
>解析的内容包括：==类或接口==、==字段==、==类方法==、==接口方法==、==方法类型==、==方法句柄==和==调用点限定符==7类。

##### 4.1 符号引用

>符号引用与虚拟机实现的布局无关，==引用的目标并不一定要已经加载到内存中==。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。

##### 4.2 直接引用

>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。==如果有了直接引用，那引用的目标必定已经在内存中存在。==

#### 5. 初始化【重点】

>到了初始化阶段，用户自定义的Java代码才真正开始执行。
>
>Java程序对类的使用方式可分为两种：==主动使用==与==被动使用==。一般来说只有==当对类的首次主动使用的时候才会导致类的初始化==，所以主动使用又叫做类加载过程中“初始化”开始的时机。那什么是主动使用呢？类的主动使用包括以下六种【超级重点】：
>
>1. 创建类的实例，也就是new的方式
>
>2. 访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）
>
>3. 调用类的静态方法
>
>4. 反射（如 Class.forName(“com.gx.yichun”)）
>
>5. 初始化某个类的子类，则其父类也会被初始化
>
>6. Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是==Main方法的类会首先被初始化==

##### 5.1 类构造器`<client>`

>==初始化阶段是执行类构造器`<client>`方法的过程==。
>
>`<client>`方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。
>
>- 虚拟机会保证子`<client>`方法执行之前，父类的`<client>`方法已经执行完毕。
>- 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成`<client>()`方法。

##### 5.2 不会执行类初始化的情况

>1. 通过==子类引用父类的静态字段==，只会触发父类的初始化，而不会触发子类的初始化。
>
>2. ==定义对象数组==，不会触发该类的初始化。
>
>3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
>
>4. ==通过类名获取 Class 对象==，不会触发类的初始化。
>
>5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
>
>6. ==通过 ClassLoader 默认的 loadClass 方法==，也不会触发初始化动作。

#### 6. 使用

>完成初始化之后，JVM便开始从入口方法开始执行用户的程序代码。

#### 7. 卸载

>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。

#### 8. 结束生命周期

>如下几种情况，JVM将结束生命周期：
>
>1. 执行System.exit()方法
>2. 程序正常执行结果
>3. 程序在执行过程中遇到了异常或错误而异常终止
>4. 由于操作系统出现错误而导致JVM进行终止

#### 9. 接口的加载过程

>与类加载过程稍有不同。当一个类在初始化时，要求其父类全部都已经初始化过了，但是==一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化==。

#### 10. 面试题

>```java
>class YeYe{
>static {
>System.out.println("YeYe静态代码块");
>}
>}
>
>class Father extends YeYe{
>public static String strFather="HelloJVM_Father";
>
>static{
>System.out.println("Father静态代码块");
>}
>}
>
>class Son extends Father{
>public static String strSon="HelloJVM_Son";
>
>static{
>System.out.println("Son静态代码块");
>}
>}
>
>public class InitiativeUse {
>public static void main(String[] args) {
>System.out.println(Son.strFather); 
>}
>}
>```
>
>运行结果：
>
>YeYe静态代码块
>
>Father静态代码块
>
>HelloJVM_Father
>
>这个题要注意什么呢？要注意子类`Son`类没有被初始化，也就是`Son`的静态代码块没有执行！那我们来分析分析…
>
>首先看到`Son.strFather`，你会发现是子类`Son`访问父类`Father`的静态变量`strFather`，这个时候就千万要记住在归纳主动使用概念时特别提到过的一个注意点了：==对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！==
>
>`Son.strFather`中的静态字段是属于父类`Father`的对吧，也就是说直接定义这个字段的类是父类`Father`，所以在执行 `System.out.println(Son.strFather);` 这句代码的时候会去初始化`Father`类而不是子类`Son`！

>```java
>class YeYe{
>static {
>System.out.println("YeYe静态代码块");
>}
>}
>
>class Father extends YeYe{
>public final static String strFather="HelloJVM_Father";
>
>static{
>System.out.println("Father静态代码块");
>}
>}
>
>class Son extends Father{
>public static String strSon="HelloJVM_Son";
>
>static{
>System.out.println("Son静态代码块");
>}
>}
>
>public class InitiativeUse {
>public static void main(String[] args) {
>System.out.println(Son.strFather);
>}
>}
>```
>
>运行结果：HelloJVM_Father
>
>这个题唯一的特点就在于`final static` ！是的`Son.strFather`所对应的变量便是`final static`修饰的，在本文中归纳的类的主动使用范畴第二点当中：==访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）==
>
>所以，这个题并不会初始化任何类，当然除了Main方法所在的类！于是仅仅执行了System.out.println(Son.strFather);所以仅仅打印了Son.strFather的字段结果HelloJVM_Father。

>```java
>class Test{
>static {
>System.out.println("static 静态代码块");
>}
>
>//    public static final String str= UUID.randomUUID().toString();
>public static final double str=Math.random();  //编译期不确定
>}
>
>
>public class FinalUUidTest {
>public static void main(String[] args) {
>System.out.println(Test.str);
>}
>}
>```
>
>运行结果：
>
>static 静态代码块
>
>0.7338688977344875
>
>==当一个常量的值并非编译期可以确定的==，那么这个值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，所以这个类会被初始化。

>```java
>public class ClassAndObjectLnitialize {
>
>public static void main(String[] args) {
>System.out.println("输出的打印语句");
>}
>
>public ClassAndObjectLnitialize(){
>
>System.out.println("构造方法");
>System.out.println("我是熊孩子我的智商=" + ZhiShang +",情商=" + QingShang);
>}
>
>{
>System.out.println("普通代码块");
>}
>
>int ZhiShang = 250;
>static int QingShang = 666;
>
>static
>{
>System.out.println("静态代码块");
>}     
>
>}
>```
>
>运行结果：
>
>静态代码块
>
>输出的打印语句
>
>首先根据上面说到的触发初始化的（主动使用）的第六点：==Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化==
>
>嗯哼？不是说好有Main方法的类会被初始化的么？那怎么好多东西都没有执行捏？
>
>那么类的初始化顺序到底是怎么样的呢？在代码中，我们只知道有一个构造方法，但实际上==Java代码编译成字节码之后，最开始是没有构造方法的概念的==，只有*<u>类初始化方法</u>*和*<u>对象初始化方法</u>* 。
>
>这个时候我们就不得不深入理解了！那么这两个方法是怎么来的呢？
>
>- 类初始化方法：*<u>编译器会按照其出现顺序，收集：类变量（static变量）的赋值语句、静态代码块，最终组成类初始化方法</u>*。==类初始化方法一般在类初始化的时候执行==。类初始化方法就会执行下面这段代码了：
>
> ```java
> static int QingShang = 666;  //类变量（static变量）的赋值语句
>
> static   //静态代码块
> {
>   System.out.println("静态代码块");
> }
> ```
>
>- 对象初始化方法：*<u>编译器会按照其出现顺序，收集：成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法</u>*，值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。==对象初始化方法一般在实例化类对象的时候执行==。其对象初始化方法就是下面这段代码了：
>
> ```java
> {                        
>   System.out.println("普通代码块");    //普通代码块
> }
>
> int ZhiShang = 250;   //成员变量的赋值语句
>
> System.out.println("构造方法");  //最后收集构造函数的代码
> System.out.println("我是熊孩子我的智商=" + ZhiShang +",情商=" + QingShang);
> ```
>
>正如上面提到的：如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。上面的这个例子确实没有执行对象初始化方法。忘了吗？我们根本就没有对类`ClassAndObjectLnitialize` 进行实例化！只是单纯的写了一个输出语句。