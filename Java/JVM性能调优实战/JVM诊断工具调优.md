#### 1. Stop-The-World机制

> ==STW==：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种*<u>全局暂停现象</u>*，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。

> 除了GC，JVM下还会发生停顿现象。JVM里有一条特殊的线程－－==VM Threads==，专门用来*<u>执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行</u>*。所以JVM引入了安全点的概念。

> ==安全点(Safe Point)==：在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。

> 1. 可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿。
>    - 分析工作必须在一个能确保一致性的快照中进行；
>    - 一致性指整个执行系统看起来像被冻结在某个时间点上；
>    - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证；
> 2. 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以需要减少STW的发生。

> Tips：STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。==开发中不要用`System.gc();`会导致stop-the-world的发生==。

#### 2. 除了GC，其它触发安全点的VM Operation

> 1. ==JIT相关==，比如Code deoptimization(代码反优化), Flushing code cache(刷新代码缓存)；
> 2. Class redefinition (==类重新定义==，例如agent，AOP代码植入的产生的instrumentation) ；
> 3. Biased lock revocation ==取消偏向锁==；
> 4. Various debug operation==各种调试操作==（例如线程转储或死锁检查）；

#### 3. 监控Safe Point

> 看看JVM启动参数的GC参数里配上：`-XX:+PrintGCApplicationStoppedTime`，就会把全部的JVM停顿时间（不只是GC）打印在GC日志里。
>
> 打印出是哪种原因导致的停顿：
>
> `-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1`

> 日志分为两段
>
> | total              | initially_running                  | wait_to_block                              |
> | ------------------ | ---------------------------------- | ------------------------------------------ |
> | 安全点里的总线程数 | 安全点时开始时正在运行状态的线程数 | 在VM Operation开始前需要等待其暂停的线程数 |
>
> | spin         | safepoint  | block                  | sync                                                         | cleanup      | vmop                       |
> | ------------ | ---------- | ---------------------- | ------------------------------------------------------------ | ------------ | -------------------------- |
> | 等待线程响应 | 号召的时间 | 暂停所有线程所用的事件 | 等于spin+block，这是从开始进入安全点所耗的时间，可用于判断进入安全点耗时 | 清理所用时间 | 真正执行VM Operation的事件 |

#### 4. 为什么要设置STW机制

> 垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。 大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，==当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象==。

> 虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 
> 这些特定的指令位置主要在：
>
> 1、循环的末尾
>
> 2、方法临返回前 / 调用方法的call指令后
>
> 3、可能抛异常的位置

#### 5. VisualGC