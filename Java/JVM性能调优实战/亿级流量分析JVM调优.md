#### 1. 亿级流量分析

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfihgtfo2j30u011mgmq.jpg" style="zoom:60%">

> 对象在内存中的组成，有对象头，实例数据以及对齐填充，其中主要的大小时实例数据占用的，一个对象有很多字段，一个字段占几个字节，一个对象撑死几百个字段，我们这里假设一个订单对象大小1KB，就是1024个字节，这已经算比较大的，一般对象不会超过这么大，那么接着上面的推算，每秒就会有300KB的订单对象生成，但是我们这里只是估算，下单过程中不仅仅会产生订单对象 ，还会涉及库存，优惠券，积分等其他相关对象，既然是估算，我们肯定要放大一下才可靠。
>
> 假设我们这里放大20倍，那么每秒就会有(300KB*20)也就是6M的对象产生。但是订单系统也不只提供下单操作，可能还有订单查询，订单退款等操作，我们再把这业务放大十倍，那么每秒就会产生60M的对象放入伊甸园区，而且这些对象有一个特点，当我的订单对象一旦生成完毕之后，在堆中生成的对象都会变为垃圾对象，都应该被回收掉。

#### 2. JVM内存分配

##### 2.1 按经验分配内存

> 在工作中项目上线时，都会对这个项目进行一些jvm参数的设置，我们这里假设机器是4核8G，那么一般可能会给我们虚拟机分配个四五G的内存，就会给堆分配个3G的内存，那么方法区分配256M，单个栈内存分配1M。
>
> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkgeym6r3kj30sg02uglp.jpg" style="zoom:60%">
>
> 这么分配有什么问题呢？如果是一个并发量不大的系统，基本上也不会有什么问题，因为本身也没多少对象在堆里生成。但是如果是我们上面说的亿级流量系统，就不能简简单单这么设置了，我们来分析一下：

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfj8516e9j30r30b1aak.jpg" style="zoom:80%">

> 根据之前我们讲的JVM内存分配，我们可以得知各个区域所占内存，每秒有60M对象产生进入Eden区，那么13秒就会==占满Eden区域，发生minor gc==，这些订单对象其中90%其实已经是垃圾对象了，为什么说90%，因为在gc的那一刻，这些对象肯定还有一部分的业务操作还没有完成，所以他们不会被回收，这里假设每次minor gc都有60M对象还不会被回收。
>
> 那么这60M对象会从Eden区移到S0区域，对象进入老年代有很多条件，比如较大的对象，这里的60M虽然小于100M，同样会直接被移入老年代，为什么呢？因为还有一个条件是对象动态年龄判断，就是==如果你移动的这批对象超过了Survivor区的50%，同样会把这批对象移入老年代==。
>
> 那么按现在这种参数设置，每13秒就会有60M的对象被移入老年代，那么*<u>大概五六分钟老年代的2G就会被占满，那么老年代一满就要发生full gc</u>*，但是full gc使我们最不愿意看到的结果。对于这么大的一个系统，每过五六分钟就发生一次full gc，就会让系统卡顿一次，用户体验很差，这是很大的问题。

> **JVM调优是为了调优gc，主要就是两个点，一个是减少Full gc的次数，一个是缩短一次Full gc的时间。**

##### 2.2 分析

> 先来分析一下：我们这个系统其实没有很多会长久存在的对象，我们放在老年代的那些60M的对象，在一两秒后其实都会变为垃圾对象，在下一次full gc时都会被回收掉，那么我们这种业务场景，完全没必要给老年代设置2G的内存，根本用不到。
>
> 可以把年轻代设置的大一些，现在来对jvm参数进行一些更改。
>
> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkgexn89w3j30w8029t8u.jpg" style="zoom:60%">
>
> 年轻代如果不设置，==堆中各个区域默认占比是2:1（8:1:1）==，现在我们设置了之后，那么堆中各区域占比就会发生变化。
>
> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkgfaykygbj30r50b4gm6.jpg" style="zoom:60%">
>
> 进行参数修改之后，再来分析这个过程：
>
> 此时需要25秒把伊甸园区放满，放满minor gc后有60M对象不被回收，要移到S0区，这时60M<200M/2，是可以移入S0区域的，下一次伊甸园区再放满做minor gc的时候，这60M对象所对应的订单已经生成了，已经变成了垃圾对象，是可以直接被回收的，所以没有什么对象是需要被移入老年代的。

> 这样设置过后，这个系统是不是正常情况下基本不会再发生full gc了呢？就算发生，也是很久才会一次了。
>
> **1.分析核心主线业务**
>
> **2.估算涉及对象大小**
>
> **3.画出对象内存模型**
>
> **4.对应JVM参数调优**