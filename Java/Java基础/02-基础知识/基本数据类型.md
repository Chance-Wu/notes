#### 1. 8种基本数据类型

---

- 字符型
  - char（2byte）
- 布尔型
  - boolean（1bit）
- 数值型
  - 整型：byte（1byte）、short（2byte）、int（4byte）、long（8byte）
  - 浮点型：float（4byte）、dubbo（8byte）



#### 2. byte、short、int、long取值范围

---

1字节=8位（bit）。java中的**整型属于有符号数**。

先来看计算中8bit可以表示的数字： 最小值：10000000 （-128）(-2^7) 最大值：01111111（127）(2^7-1) 具体计算方式参考：[Java中，为什么byte类型的取值范围为-128~127? - CSDN博客](https://blog.csdn.net/qq_23418393/article/details/57421688)

- byte：byte用1个字节来存储，范围为`-128(-2^7)`到`127(2^7-1)`，在变量初始化的时候，byte类型的默认值为0。
- short：short用2个字节存储，范围为-32,768 `(-2^15)`到32,767 `(2^15-1)`，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。
- int：int用4个字节存储，范围为-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)，在变量初始化的时候，int类型的默认值为0。
- long：long用8个字节存储，范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。

整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即**溢出**。如以下代码：

```java
int i = Integer.MAX_VALUE;
int j = Integer.MAX_VALUE;

int k = i + j;
System.out.println("i (" + i + ") + j (" + j + ") = k (" + k + ")");
```

输出结果：`i (2147483647) + j (2147483647) = k (-2)`

这就发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。



#### 3. 浮点型

---

>计算机的数字的存储和运算都是通过二进制进行的，对于，十进制整数转换为二进制整数采用"==除2取余，逆序排列=="法

具体做法是：

- 用2整除十进制整数，可以得到一个商和余数；
- 再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止
- 然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

如，我们想要把127转换成二进制，做法如下：

127/2 = 63	余数	1

63/2   = 31	余数	1

31/2   = 15	余数	1

15/2	= 7	 余数	1

7/2	  = 3	 余数	1

3/2	  = 1	 余数	1

1/2	  = 0	 余数	1

余数依次排列——> `1111111`

>十进制小数转换成二进制小数采用"==乘2取整，顺序排列=="法。

具体做法是：

- 用2乘十进制小数，可以得到积
- 将积的整数部分取出，再用2乘余下的小数部分，又得到一个积
- 再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

如将0.625转成二进制：

0.625*2 = 1.25	整数部分	1

0.25*2   = 0.5	  整数部分	0

0.5*2     = 1		 整数部分	1

`0.101`

但是0.625是一个特例，用同样的算法，计算下0.1对应的二进制是多少：

0.1*2 = 0.2	整数部分	0

0.2*2 = 0.4	整数部分	0

0.4*2 = 0.8	整数部分	0

0.8*2 = 1.6	整数部分	1

0.6*2 = 1.2	整数部分	1

0.2*2 = 0.4	整数部分	0

0.4*2 = 0.8	整数部分	0

0.8*2 = 1.6	整数部分	1

0.6*2 = 1.2	整数部分	1

0.2*2 = 0.4	整数部分	0

......

0.000110011001100	......出现了无限循环的情况

这种情况，计算机就没办法用二进制精确的表示0.1了。所以，为了解决部分小数无法使用二进制精确表示的问题，于是就有了IEEE 754规范。

==IEEE二进制浮点数算术标准（IEEE 754）==是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。

>浮点数和小数并不是完全一样的，计算机中小数的表示法，其实有**定点**和**浮点**两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数来表示实数的近似值。

IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。

其中最常用的就是**32位单精度浮点数**和**64位双精度浮点数**。

==IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。==

一个浮点数a由两个数m和e来表示：`a = m × b^e`。

在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。

如果m的第一位是非0整数，m称作规格化的。有一些描述使用一个单独的符号位(s 代表+或者-）来表示正负，这样m必须是正的。e是指数。



#### 4. 什么是单精度和双精度

---

单精度浮点数在计算机存储器中占用**4个字节**（32 bits），利用“浮点”（浮动小数点）的方法。

比起单精度浮点数，双精度浮点数(double)使用 64 位（**8字节**） 来存储一个浮点数。



#### 5. 为什么不能用浮点型表示金额

---

==计算机中保存的小数其实是十进制的小数的近似值==，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。

>建议使用 **BigDecimal** 或者 **Long** （单位为分）来表示金额。