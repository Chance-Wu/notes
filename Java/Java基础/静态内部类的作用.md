#### 1. 内部类

---

将一个类的定义放在另一个类的定义内部。

嵌套类是其封闭类的成员。**非静态嵌套类(内部类)可以访问封闭类的其他成员，即使它们被声明为私有的**。静态嵌套类无权访问封闭类的其他成员。为一体的一个部件OuterClass，一个嵌套类可以声明private，public，protected，或包专用。



#### 2. 静态内部类

---

在一个普通类里面，给内部类加上 static 关键字的修饰。（**随着类的加载（而不是随着对象的产生）而产生**，**可以用类名+静态成员名直接获得**。）

与类方法和变量一样，静态嵌套类与其外部类相关联。与静态类方法一样，**静态嵌套类不能直接引用其封闭类中定义的实例变量或方法**，它只能通过对象引用来使用它们。



#### 3. 内部类和静态内部类的区别

---

- 内部类只是外部类的成员变量，通俗讲，就是你只能通过先调用外部类才能去拿到这个类。
-  静态内部类就像是一个普通类一样。可以直接调用，直接去new对象。



#### 4. 内部类的作用

---

这是一种对仅在一个地方使用的类进行逻辑分组的方法：如果一个类仅对另一个类有用，那么将其嵌入该类并将两者保持在一起是合乎逻辑的。嵌套此类“帮助程序类”可使它们的程序包更加简化。

它增加了封装：考虑两个顶级类A和B，其中B需要访问A的成员，否则将对其进行声明private。通过将类B隐藏在类A中，可以将A的成员声明为私有，而B可以访问它们。另外，B本身可以对外界隐藏。

这可能会导致代码更具可读性和可维护性：在顶级类中嵌套小类会使代码更靠近使用位置。



#### 5. 注意事项

---

序列化强烈建议不要对内部类(包括 本地和 匿名类)进行序列化。当Java编译器编译某些构造(例如内部类)时，它会创建综合构造。

这些是类，方法，字段以及其他在源代码中没有相应构造的构造。合成构造使Java编译器无需更改JVM就可以实现新的Java语言功能。但是，合成构造在不同的Java编译器实现中可能有所不同，这意味着.class文件在不同的实现中也可能有所不同。因此，如果序列化一个内部类，然后使用其他JRE实现对其进行反序列化，则可能会遇到兼容性问题。

>static修饰类的方法，表示这个方法和这个类对象没有关系，只是和这个类有关系
>
>static 修饰变量，按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：
>
>对于静态变量在内存中只有一个拷贝(节省内存)，JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问(方便)，当然也可以通过对象来访问(但是这是不推荐的)。
>
>好的，是这样的。static修饰对象 可以全局使用，修饰方法可以不依赖于对象，修饰类，也不用依赖与他的对象，也可以被其他的类直接使用，或者自己进行初始化。