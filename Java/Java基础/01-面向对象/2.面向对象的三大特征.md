#### 1. 封装

---

封装：**把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏**。

##### 1.1 信息的封装和隐藏

通过数据声明为私有的（private），再提供公共的（public）方法：getXxx()和setXxx()实现对该属性的操作，以实现下述目的：

- 隐藏一个类中不需要对外提供的实现细节；
- 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
- 便于修改，增强代码的可维护性；

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0g4vommzyj21ed0u0wlk.jpg" style="zoom: 33%;" />

```java
/** 定义一个矩形 */
class Rectangle {

  /** 设置矩形的长度和宽度 */
  public Rectangle(int length, int width) {
    this.length = length;
    this.width = width;
  }

  /** 长度 */
  private int length;

  /** 宽度 */
  private int width;

  /** 获得矩形面积 */
  public int area() {
    return this.length * this.width;
  }
}
```



#### 2. 继承

---

继承是指这样一种能力：它可以**使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展**。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。

要定义一个正方形，直接继承Rectangle类，正方形是矩形的一种特例。

```java
/** 正方形，继承自矩形 */
class Square extends Rectangle {

  /** 设置正方形边长 */
  public Square(int length) {
    super(length, length);
  }
}
```

##### 2.1 继承与实现

在Java中，除了继承，还有一种体现**传递性**的方式叫做实现。

继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要**复用**，而实现的根本原因是需要定义一个**标准**。

在接口中只能定义全局常量（static final）和无实现的方法（Java 8以后可以有defult方法）；而在继承中可以定义属性方法，变量，常量等。



#### 3. 多态

---

多态：同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。**多态机制使具有不同内部结构的对象可以共享相同的外部接口**。

##### 3.1 多态的必要条件

为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：

- 有==类继承==或者==接口实现==
- 子类要==重写父类的方法==
- ==父类的引用指向子类的对象==

```java
public class Parent{
  public void call(){
    sout("im Parent");
  }
}
```

```java
public class Son extends Parent{// 1.有类继承或者接口实现
  public void call(){// 2.子类要重写父类的方法
    sout("im Son");
  }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
  public void call(){// 2.子类要重写父类的方法
    sout("im Daughter");
  }
}
```

```java
public class Test{

  public static void main(String[] args){
    Parent p = new Son(); //3.父类的引用指向子类的对象
    Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
  }
}
```

同样是Parent类的实例，p.call调用的是Son类的实现、p1.call调用的是Daughter的实现。

有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。

比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。

> （Ioc—Inversion of Control）“控制反转”，它是一种设计思想，意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

##### 3.2 静态多态

上面提到的那种动态绑定认为是动态多态，因为**只有在运行期才能知道真正调用的是哪个类的方法**。

很多人认为，还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法。

但是，其实作者认为，多态应该是一种运行期特性，Java中的方法重写是多态的体现。虽然也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。



#### 4. 方法重写与重载

---

##### 4.1 方法重写

>重写：在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。
>
>- 是一个运行期概念；
>- 遵循所谓“运行期绑定”，即在运行的时候根据引用变量所指向的实际对象的类型来调用方法；
>
>**重写是多态**

示例：

```java
class Dog{
  public void bark(){
    System.out.println("woof ");
  }
}
class Hound extends Dog{
  public void sniff(){
    System.out.println("sniff ");
  }

  public void bark(){
    System.out.println("bowl");
  }
}

public class OverridingTest{
  public static void main(String [] args){
    Dog dog = new Hound();
    dog.bark();
  }
}
```

结果：bow1

`dog`对象被定义为`Dog`类型。在编译期，编译器会检查Dog类中是否有可访问的`bark()`方法，只要其中包含`bark()`方法，那么就可以编译通过。==在运行期，`Hound`对象被`new`出来，并赋值给`dog`变量，这时，JVM是明确的知道`dog`变量指向的其实是`Hound`对象的引用。所以，当`dog`调用`bark()`方法的时候，就会调用`Hound`类中定义的`bark()`方法。这就是所谓的动态多态性==。

重写的条件：

- 参数列表必须完全与被重写方法的相同；
- 返回类型必须完全与被重写方法的返回类型相同；
- 访问级别的限制性一定不能比被重写方法的强；
- 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
- 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
- 不能重写被标示为final的方法；
- 如果不能继承一个方法，则不能重写这个方法。

##### 4.2 方法重载

>重载：函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
>
>- 是一个编译期概念；
>- 遵循所谓的“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法；
>
>因为**在编译期已经确定调用哪个方法，所以重载并不是多态**。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

示例：

```java
class Dog{
  public void bark(){
    System.out.println("woof ");
  }

  //overloading method
  public void bark(int num){
    for(int i=0; i<num; i++)
      System.out.println("woof ");
  }
}
```

定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。

重载的条件：

- 被重载的方法必须改变参数列表；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
