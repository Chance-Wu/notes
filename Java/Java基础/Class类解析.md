Class类包含了类的信息，如构造方法、方法、属性，可用于反射。

>在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。

#### 1. 获取 Class 类对象的方法

---

> Test test = new Test();
> test.getClass();
>
> 获得父类类对象： `test.getClass().getSuperclass()`

>Test.class;
>
>在编译时确定，返回当前类的类对象实例。**不会加载静态变量**。
>
>获得父类类对象： `Test.class.getSuperclass()`

> Class.forName("类路径");
>
> 会加载静态变量，比如jdbc驱动利用这个加载一些静态属性。
>
> 通过静态方法获取类对象：`Class.forName("com.wan.Test");`

#### 2. 普通类为什么不能用static修饰

---

static修饰的东西被我们称为类成员，它会**随着类的加载而加载**，比如==静态代码块，静态成员，静态方法(这里只是加载，并没有调用)==等等，可以假象一下，如果把一个Class文件中的外部类设为static，那目的何在呢？难道让这个类随着应用的启动而加载吗？如果我在这次使用过程中根本没有使用过这个类，那么是不是就会浪费内存。这样来说设计不合理。

#### 3. 为什么内部类可以使用static修饰

---

因为内部类算是类的成员了，如果没有使用静态来修饰，那么我们在创建内部类的时候就需要先有一个外部类的对象，如果我们一直在使用内部类，那么内存中就会一直存在外部类的引用，而我们有时候只需要使用内部类，不需要外部类，那么还是会浪费内存，甚至会造成内存溢出。==使用static修饰内部类之后，内部类在创建对象时就不需要有外部类对象的引用了==。

>最终结论就是：static可以用来修饰内部类，但是不可以用来修饰外部类。

#### 4. ClassLoader 相关理解

---

java程序写好以后是以 .java 的文件存在磁盘上，然后通过（bin/javac.exe）编译命令把.java文件编译成.class文件（字节码文件），并存在磁盘上。但是程序要运行，首先一定要把.class文件加载到JVM内存中才能使用的，**ClassLoader 就是负责把磁盘上的.class文件加载到JVM内存中**，如下图所示：

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzyt5ghwolj21180u0q51.jpg" style="zoom: 33%;" />

可以认为每一个Class对象拥有磁盘上的那个.class字节码内容，每一个class对象都有一个getClassLoader()方法，得到是谁把我从.class文件加载到内存中变成Class对象的。

