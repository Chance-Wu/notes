使用诸如float或者double这两种浮点型数据的处理时，典型现象。

- 条件判断超预期
- 数据转换超预期
- 基本运算超预期
- 数据自增超预期

```java
System.out.println(1f == 0.99999999f);
```

如上输出为true。

计算机底层在计算时都是基于像010100100100110011011这种二进制来完成的。把它转换到IEEE 754 Single precision 32-bit，也就float类型对应的精度。

<img src="img/image-20220928143423152.png" alt="image-20220928143423152" style="zoom: 20%;" />

很明显，它俩的二进制数字表示确实不一样，这是理所应当的结果。那么为什么0.99999999的底层二进制表示竟然是：00111111 10000000 00000000 00000000呢？这不明明是浮点数1.0的二进制表示吗？这就要谈一下浮点数的精度问题了。



### 一、浮点数的精度问题

---

浮点数在计算机中的存储方式遵循IEEE 754浮点数计数标准，可以如下数学公式表示：
$$
V=(-1)^S\times M\times 2^E
$$

- S表示sign，即符号。如果`S==0`，则浮点数V为正；如果`S==1`，则浮点数为负。
- M 表示有效数字，在 [1, 2) 之间。
- E 则是指数位。

在IEEE754标准中进行了单精度浮点数(float)和双精度数浮点数(double)的定义。float有32bit，double有64bit。它们的构成包括**符号位**、**指数位**和**尾数位**。

![img](img/20191204085148226.png)

float——第31位(1bit)---第30-23位(8bit)---第22-0位(23bit)

![img](img/20191204085205171.png)

> **取值范围**主要看指数部分：
>
> float的指数部分有8bit，由于是**有符号型**，所以得到对应的指数范围 `-128~128`（1 111 1111 ~ 0 111 1111），所以取值范围为 -2^128^到2^128^，约等于-3.4E38 ~ +3.4E38。
>
> **精度(有效数字)**主要看尾数位：
>
> float的尾数位是23bit，对应7~8位十进制数，所以有效数字**有的编译器是7位，也有的是8位**。

- **对于 32 位浮点数，可以准确表示的精度在 10^-6 这个量级。**换句话说，如果我们想要表示的小数，在小数点后 7 位还有有效数字的话，32 位的浮点数就不能精确表示了。
- **对于 64 位浮点数，可以准确表示的精度在 10^-15 这个量级。**换句话说，如果我们想要表示的小数，在小数点后 16 位还有有效数字的话，64 位的浮点数就不能精确表示了。



### 二、精度问题如何解决

---

如果涉及**商品金额**、**交易值**、**货币计算**等这种对精度要求很高的场景该怎么办呢？

#### 2.1 用字符串或者数组解决多位数问题

用字符串或者数组表示大数是一个典型的解题思路。

比如经典面试题：编写两个任意位数大数的加法、减法、乘法等运算。 

这时候我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：进位、借位、符号等等问题的处理，确实十分复杂，本文不做赘述。 

#### 2.2 Java的大数类

JDK提供了专用于高精度数值计算的大数类来方便我们使用。 

Java的大数类位于java.math包下：常用的 `BigInteger` 和 `BigDecimal`，像BigInteger 和 BigDecimal这种大数类的运算效率肯定是不如原生类型效率高，代价还是比较昂贵的，是否选用需要根据实际场景来评估。



### 三、BigDecimal类

---

#### 3.1 BigDecimal初始化

















