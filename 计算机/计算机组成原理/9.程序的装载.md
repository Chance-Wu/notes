### 一、程序装载的挑战

---

在运行这些可执行文件的时候，我们其实是通过一个装载器，解析ELF或者PE格式的可执行文件。

装载器会把对应的指令和数据加载到内存里面来，让CPU去执行。

**装载到内存**,装载器需要满足两个要求：

- 可执行程序加载后**占用的内存空间应该是连续的** 执行指令的时候，程序计数器是顺序地一条一条指令执行。这意味着，这一条条指令需要连续地存储在一起。
- **需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置** 虽然编译出来的指令里已经有了对应的各种各样的内存地址，但是实际加载的时候，我们其实没有办法确保，这个程序一定加载在哪一段内存地址上 因为现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用。

要满足这两个基本的要求，我们很容易想到一个办法。那就是我们可以在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。

指令里用到的内存地址叫作**虚拟内存地址（Virtual Memory Address）**。

实际在内存硬件里面的空间地址，我们叫**物理内存地址（Physical Memory Address）**。

程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。

对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。

























































