### 一、概念

>**serverId（服务ID即myid）**
>
>- 三台服务器，编号分别是1，2，3；
>- ==编号越大在选择算法中的权重越大==。

> **zxid（最新的事务ID即LastLoggedZxid）**
>
> - 服务器中存放的最大数据ID；
> - ID值越大说明数据越新，==在选举算法中数据越新权重越大==。

>**epoch（逻辑时钟即PeerEpoch）**
>
>- 每个服务器都会给自己投票，或者叫投票次数，同一轮投票过程中的逻辑时钟是相同的；
>- 每投完一次票这个数据就会增加，然后与接收到的其他服务器返回的投票信息中的数值相比；
>- 如果收到低于当前轮次的投票结果，该投票无效，需更新到当前轮次和当前的投票结果。

>**选举状态**
>
>- LOOKING，竞选状态；
>- FOLLOWING，随从状态，同步leader状态，参与投票；
>- OBSERVING，观察状态，同步leader状态，不参与投票；
>- LEADING，领导状态。

>**选举算法**
>
>通过 zoo.cfg 配置文件中的 `electionAlg` 属性指定（1-3），需要一些`paxos`算法的理论基础。
>
>1对应：LeaderElection
>
>2对应：AuthFastLeaderElection
>
>3对应：==FastLeaderElection 默认的算法==

>**投票内容**
>
>- 选举人ID
>- 选举人数据ID
>- 选举人选举轮数
>- 选举人选举状态
>- 推举人ID
>- 推举人选举轮数



### 二、Leader选举

Leader选举有如下两种：

1. 服务器初始化启动的Leader选举；
2. 服务器运行时期的Leader选举（服务器运行期间无法和Leader保持连接）



Leader选举的前提条件

- 只有==服务器状态在LOOKING（==竞选状态）才会去执行选举算法；
- zk的集群规模==至少是2台机器，==才可以选举Leader；
- 当一台服务器启动时是不能选举的，等第二台服务器启动后，==两台机器之间可以互相通信，才可以进行Leader选举==；
- 服务器运行期间无法和Leader保持连接的时候。



#### 2.1 服务器启动时期的 Leader 选举

---

在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动后，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下：

1. 每个Server发出一个投票投给自己。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，==每次投票会包含所的服务器的myid和ZXID==，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。

2. 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先==判断该投票的有效性==，如检查是否是本轮投票、是否来自LOOKING状态的服务器。

3. 处理投票。针对每一个投票，==服务器都需要将别人的投票和自己的投票进行PK==，PK规则如下

   1. 优先检查ZXID。==ZXID比较大的服务器优先作为Leader==。
   2. 如果ZXID相同，那么就比较myid。==myid较大的服务器作为Leader服务器==。

   > 对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。

4. 统计投票。每次投票后，服务器都会统计投票信息，==判断是否已经有过半机器接受到相同的投票信息==，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。
5. 改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。



#### 2.2 服务器运行时期的 Leader 选举

---

zk运行期间，即便有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。选举过程如下：

1. 变更状态。Leader挂后，余下的非Observer服务器都会将自己的服务器状态变更为LOOKING，进入Leader选举流程；
2. 每个Server会发出一个投票。在这个过程中，需要生成投票信息(myid,ZXID)每个服务器上的ZXID可能不同，我们假定Server1的ZXID为123，而Server3的ZXID为122；在第一轮投票中，Server1和Server3都会投自己，产生投票(1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器；
3. 接收来自各个服务器的投票。与启动时过程相同；
4. 处理投票。此时，Server1将会成为Leader；
5. 统计投票；
6. 改变服务器的状态。



#### 2.3 Leader选举算法分析

---

在3.4.0后的Zookeeper的版本只保留了TCP版本的`FastLeaderElection`选举算法。

>当ZooKeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举。
>
>- 服务器初始化启动。
>- 服务器运行期间无法和Leader保持连接。
>
>而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态。
>
>- 集群中本来就巳经存在一个Leader。
>- 集群中确实不存在Leader。



假设ZooKeeper由5台机器组成，SID分別为1、2、3、4和5, ZXID分别为9、9、9、8和8,并且此时SID为2的机器是Leader服务器。某一时刻，1和2所在的机器出现故障，因此集群开始进行Leader选举。

在第一次投票的时候，由于还无法检测到集群中其他机器的状态信息，因此每台机器都是将自己作为被推举的对象来进行投票，于是SID为3、4和5的机器，投票情况分别为：（3, 9）、（4, 8）和（5, 8）。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gtl19uip81j60je06yt8z02.jpg)

>简单地说，通常哪台服务器上的数据越新（ZXID会越大），那么越有可能成为Leader,原因很简单，数据越新，那么它的ZXID也就越大，也就越能够保证数据的恢复。当然，如果集群中有几个服务器有相同的ZXID，那么SID较大的那台服务器成为Leader。



### 三、选举实现细节

#### 3.1 QuorumCnxManager：网络I/O

---

每台服务器在启动的的过程中，会启动一个`QuorumCnxManager`，负责各台服务器之间的底层Leader选举过程中的网络通信。

>（1）**消息队列**
>
>QuorumCnxManager内部维护了一系列的队列，用来保存接收到的、待发送的消息以及消息的发送器，除接收队列以外，其他队列都按照SID分组形成队列集合，如一个集群中除了自身还有3台机器，那么就会为这3台机器分别创建一个发送队列，互不干扰。
>
>- recvQueue：消息接收队列，用于存放那些从其他服务器接收到的消息。
>- queueSendMap：消息发送队列，用于保存那些待发送的消息，按照SID进行分组。
>- senderWorkerMap：发送器集合，每个SenderWorker消息发送器，都对应一台远程Zookeeper服务器，负责消息的发送，也按照SID进行分组。
>- lastMessageSent：最近发送过的消息，为每个SID保留最近发送过的一个消息。
>
>（2）**建立连接**
>
>为了能够相互投票，Zookeeper集群中的所有机器都需要两两建立起网络连接。QuorumCnxManager在启动时会创建一个ServerSocket来监听Leader选举的通信端口(默认为3888)。开启监听后，Zookeeper能够不断地接收到来自其他服务器的创建连接请求，在接收到其他服务器的TCP连接请求时，会进行处理。为了避免两台机器之间重复地创建TCP连接，Zookeeper只允许SID大的服务器主动和其他机器建立连接，否则断开连接。在接收到创建连接请求后，服务器通过对比自己和远程服务器的SID值来判断是否接收连接请求，如果当前服务器发现自己的SID更大，那么会断开当前连接，然后自己主动和远程服务器建立连接。一旦连接建立，就会根据远程服务器的SID来创建相应的消息发送器SendWorker和消息接收器RecvWorker，并启动。
>
>（3）**消息接收与消息发送**
>
>消息接收：由消息接收器RecvWorker负责，由于Zookeeper为每个远程服务器都分配一个单独的RecvWorker，因此，每个RecvWorker只需要不断地从这个TCP连接中读取消息，并将其保存到recvQueue队列中。
>
>消息发送：由于Zookeeper为每个远程服务器都分配一个单独的SendWorker，因此，每个SendWorker只需要不断地从对应的消息发送队列中获取出一个消息发送即可，同时将这个消息放入lastMessageSent中。在SendWorker中，一旦Zookeeper发现针对当前服务器的消息发送队列为空，那么此时需要从lastMessageSent中取出一个最近发送过的消息来进行再次发送，这是为了解决接收方在消息接收前或者接收到消息后服务器挂了，导致消息尚未被正确处理。同时，Zookeeper能够保证接收方在处理消息时，会对重复消息进行正确的处理。



#### 3.2 FastLeaderElection-选举算法核心

---

**（1）选票管理**

- sendqueue：选票发送队列，用于保存待发送的选票。
- recvqueue：选票接收队列，用于保存接收到的外部投票。
- WorkerReceiver：选票接收器。其会不断地从QuorumCnxManager中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。
- WorkerSender：选票发送器，不断地从sendqueue中获取待发送的选票，并将其传递到底层QuorumCnxManager中。



**（2）算法核心**

![](https://tva1.sinaimg.cn/large/008i3skNgy1gtltttelm1j60dq07bt8s02.jpg)

>上图展示了FastLeaderElection模块是如何与底层网络I/O进行交互的。Leader选举的基本流程如下：
>
>**1、自增选举轮次**。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。
>
>**2、初始化选票**。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader。
>
>**3、发送初始化选票**。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。
>
>**4、接收外部投票**。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。
>
>**5、判断选举轮次**。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。
>
>- 外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。
>- 外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。
>- 外部投票的选举轮次等于内部投票。此时可以开始进行选票PK。
>
>**6、选票PK**。在进行选票PK时，符合任意一个条件就需要变更投票。
>
>- 若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。
>- 若选举轮次一致，那么就对比两者的ZXID，若外部投票的ZXID大，那么需要变更投票。
>- 若两者的ZXID一致，那么就对比两者的SID，若外部投票的SID大，那么就需要变更投票。
>
>**7、变更投票**。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。
>
>**8、选票归档**。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票（按照服务队的SID区别，如{(1, vote1), (2, vote2)...}）。
>
>**9、统计投票**。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤4。
>
>**10、更新服务器状态**。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。
>
>以上10个步骤就是FastLeaderElection的核心，其中步骤4-9会经过几轮循环，直到有Leader选举产生。
