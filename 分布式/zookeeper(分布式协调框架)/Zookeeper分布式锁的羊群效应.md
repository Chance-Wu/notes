>在java分布式环境下，分布式的应用越来越常见，本文将介绍zk中使用分布式锁并有效防止羊群效应。 那么什么是羊群效应呢？百科上这么说的：羊群效应理论（The Effect of Sheep Flock），也称羊群行为（Herd Behavior）、从众心理。 羊群是一种很散乱的组织，平时在一起也是盲目地左冲右撞，但一旦有一只头羊动起来，其他的羊也会不假思索地一哄而上，全然不顾旁边可能有的狼和不远处更好的草。看到这里，就应该知道了，当多个客户端请求获取zk创建临时节点来进行加锁的时候，会进行竞争，因为zk独有的一个特性：即watch机制。啥意思呢？就是当A获取锁并加锁的时候，B会监听A的结点变化，当A创建的临时结点被删除的时候，B会去竞争锁。懂了没？

>那么问题来了？如果同时有1000个客户端发起请求并创建临时节点，都会去监听A结点的变化，然后A删除节点的时候会通知其他节点，这样是否会太影响并耗费资源了？那么怎么有效避免羊群效应呢？
>
>我在processon上画了一张图用来消化这篇文章：
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmei4hjccwj30nx0hq3yu.jpg" style="zoom:80%">
>
>当多个客户端请求并创建临时节点，此时这些节点名顺序排列，比如A-->znode-01，B--->znode-02，C--->znode-03，此时节点会进行顺序排列，将节点顺序排列，每次只获取当前最小的节点，当我们znode-01获取锁的时候此时znode-02监听其节点， znode-03监听znode-02节点，以此类推…… 每一个后来的节点监听前一个节点，即每次id最小的节点会获取锁，执行完逻辑之后删除临时节点
>
>整体步骤如下：
>
>1. 所有客户端都尝试去创建临时有序节点以获取锁
>2. 序号最小的临时有序节点获得锁
>3. 未获取到锁的客户端给自己的上一个临时有序节点添加监听
>4. 获得锁的客户端进行自己的操作，操作完成之后删除自己的临时有序节点
>5. 当监听到自己的上一个临时有序节点释放了锁，尝试自己去加锁
>6. 操作完成之后释放锁
>7. 之后剩下的客户端重复加锁和解锁的操作
>
>因此，本方法可以有效解决zk的羊群效应，使得分布式锁可以有顺序的执行。



