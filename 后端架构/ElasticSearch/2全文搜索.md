**全文搜索**：计算机搜索程序通过扫描文章中的每一个词，**对每一个词建立一个索引**，**指明该词在文章中出现的次数和位置**，当用户查询时，搜索程序就根据事先建立的索引进行查找。（这个过程类似于通过字典中的搜索字表查字的过程）



### 一、Lucene介绍

---

>Lucene 是Apache基金会中：
>
>- 一个开源的全文搜索引擎工具包、
>- 一个全文搜索引擎的架构。提供完整的查询引擎和索引引擎，部分文本分析引擎、
>- 简单易用的工具包。



### 二、Lucene 倒排索引

---

>**倒排索引**：
>
>实际应用中需要**根据属性的值来查找记录**。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。是**由属性值来确定记录的位置**，因为称为倒排索引（inverted index）。

**倒排索引文件/倒排文件（inverted file）**：带有倒排索引的文件。

倒排索引中的索引对象是文档或者文档集合中的单词等，用来存储这些单词在一个文档或者一组文档中的存储位置。

**搜索引擎的关键步骤就是建立倒排索引**，倒排索引一般表示为**一个关键词**，然后是它的**频度**（出现的次数）、**位置**（出现在哪一篇文章或网页中，及有关的日期，作者等信息）。



### 三、倒排索引及相应的生成算法

---

假设有两篇文章1和文章2

```
文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.
文章2的内容为：He onece lived in Shanghai. 
```

#### 3.1 取得关键词

由于Lucene是基于**关键词**索引和查询的，首先要取得这两篇文章的关键词，通常需要如下处理措施：

- 现在有的是文章内容，即一个字符串，**先找出字符串中的所有单词，即分词**。英文单词由于用空格分隔，比较好处理。中文单词间由于是连在一起的，所以需要特殊的分词处理。
- 文中的“in”，“once”，“too”等词没什么实际意义，中文中的“的”，“是”等字通常也无具体含义，这些**不代表概念的词是可以过滤掉的**。
- 用户通常希望查“He”时能把含“he”和“HE”的文章也找出来，所以**所有单词需要统一大小写**。
- 用户通常希望查“live”时能把含“lives”和“lived”的文章也找出来，所以**需要把“lives”，“lived”还原成“live”**。
- **文章中的标点符号可以过滤掉**。 

在Lucene中以上措施有Analyzer类完成。经过上面处理后，得到如下结果：

```
文章1的所有关键词为：[tom][live][guangzhou][i][live][guangzhou]
文章2的所有关键词为：[he][live][shanghai]
```

#### 3.2 建立倒排索引

上面的对应关系是“文章号”对“文章中所有的关键词”。倒排索引把这个关系倒过来，变成“关键词”对“拥有该关键词的所有文章号”。

| 关键词    | 文章号 |
| --------- | ------ |
| guangzhou | 1      |
| he        | 2      |
| i         | 1      |
| live      | 1,2    |
| shanghai  | 2      |
| tom       | 1      |

通常仅知道关键词在哪些文章中出现还不够，还需要知道**关键词在文章中出现的次数和位置**，通常有两种位置：

- 字符位置，即记录该词是文章中第几个字符（优点是显示并定位关键词块）。
- 关键词位置，即记录该词是文章中第几个关键词（优点是节约索引空间、词组查询快）Lucene中记录的就是这种位置。

加上“出现频率”和“出现位置”信息后，索引结构如下：

| 关键词    | 文章号[出现频率] | 出现位置 |
| --------- | ---------------- | -------- |
| guangzhou | 1[2]             | 3,6      |
| he        | 2[1]             | 1        |
| i         | 1[1]             | 4        |
| live      | 1[2]     2[1]    | 2,5    2 |
| shanghai  | 2[1]             | 3        |
| tom       | 1[1]             | 1        |

以上就是Lucene索引结构中最核心的部分。注意到关键字是按字符数顺序排序的（Lucene 没有使用 B树结构），因此 Lucene可以用二元搜索算法快速定位关键词。

#### 3.3 实现

实现时，Lucene将上面三列分别作以下三种文件保存：

- **词典文件**（Term Dictionary）:不仅保存了每个关键字，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。
- **频率文件**（frequencies）
- **位置文件**（positions）

Lucene中使用了`field`的概念，用于表达信息所在位置（如标题中、文章中、URL中），在建索引中，该field信息也记录在词典文件中，每个关键词都有一个field信息，因为*<u>每个关键字一定属于一个或多个field</u>*。

#### 3.4 压缩算法

为了减小索引文件的大小。

- 首先，对词典文件中的关键词进行了压缩，关键词压缩为`<前缀长度,后缀>`，例如：当前词为“阿拉伯语”，那么“阿拉伯语”压缩为`<3,语>`。
- 其次大量用到的是对数字的压缩，`数字只保存与上一个值的插值`（这样可以减少数字的长度，进而减少保存该数字需要的字节数）。例如当前文章号是16389，不压缩要用3个字节保存，上一文章号是16382，压缩后只保存7，只用一个字节。

#### 3.5 应用场景

下面我们可以通过对该索引的查询来解释一下为什么要建立索引。

假设要查询单词“live”，**Lucene先对词典二元查找，找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果**。词典通常非常小，因而，整个过程的时间是毫秒级的。

