### 一、直接 DOM 操作时代

---

“直接 DOM 操作时代”通常指的是在现代前端框架（如 React、Vue、Angular）普及之前，Web 开发的主要模式。那个时代的开发者直接使用原生 JavaScript 或 jQuery 等库来查询、修改、添加或删除页面上的 DOM 元素。

#### 1.1 核心特征

1. **直接与 DOM 交互**：
   - 开发者通过 `document.getElementById`、`document.querySelector`、`document.createElement` 等 API 直接获取和操作页面元素。
   - 状态（数据）和视图（UI）的同步需要开发者手动编写大量代码来维护。
2. **命令式编程**：
   - 开发者需要明确地告诉浏览器“**如何**”更新页面。例如，“找到这个按钮，然后修改它的文本，再改变它的样式类”。
   - 这与现代框架的“声明式”编程（只需描述“**是什么**”）形成鲜明对比。
3. **jQuery 的黄金时期**：
   - jQuery 是直接 DOM 操作时代的代表性库。它简化了跨浏览器的 DOM 操作、事件处理和动画，极大地提高了开发效率。
   - “解放生产力”成为了那个时代的口号，但开发者仍需花费大量精力管理 DOM 的复杂性。
4. **性能挑战**：
   - 频繁的 DOM 操作（尤其是直接修改）会导致浏览器频繁地进行**重排**（reflow）和**重绘**（repaint），严重影响性能。
   - 开发者需要掌握性能优化技巧，例如使用 `DocumentFragment` 来批量插入节点，以减少页面重排次数。

#### 1.2 代码示例

```js
// 直接 DOM 操作：更新用户信息
const nameElement = document.getElementById('userName');
const statusElement = document.getElementById('userStatus');

// 假设从服务器获取了新数据
const userData = { name: '张三', status: '在线' };

// 手动更新 DOM
nameElement.textContent = userData.name;
statusElement.textContent = userData.status;
statusElement.classList.add('online');
```

#### 1.3 为何被现代框架取代

1. **维护成本高**：随着应用复杂度增加，手动管理 DOM 状态变得极其繁琐且容易出错。
2. **性能瓶颈**：不恰当的 DOM 操作是性能杀手。现代框架通过**虚拟 DOM** 和高效的 diff 算法，最小化对真实 DOM 的操作，从而提升性能。
3. **开发效率低**：开发者需要关注大量底层细节，难以专注于业务逻辑本身。
4. **组件化缺失**：缺乏原生的组件化支持，代码复用和组织困难。

#### 1.4 现代视角下的“直接操作 DOM”

- **并非完全消失**：在现代框架中，有时仍需要直接操作 DOM，例如处理焦点、集成第三方库或进行复杂的动画。React 的 `ref`、Vue 的 `ref` 都提供了安全访问底层 DOM 节点的途径。
- **作为优化手段**：在性能要求极高的特定场景下，直接 DOM 操作可能比通过框架更新更高效。
- **与框架共存**：“直接 DOM 操作”不再是构建应用的**主要方式**，而是作为现代框架能力的补充。



### 二、MV* 交互模式

---

`MV*（Model-View-Whatever）`是一系列软件架构模式的统称，旨在解决用户界面（UI）开发中的代码组织、关注点分离和可维护性问题。它起源于经典的 MVC（Model-View-Controller）模式，并衍生出 MVP、MVVM 等变体，以适应不同平台和框架的需求。在前端开发中，`MV* 模式`为构建复杂的交互式应用提供了清晰的结构。

#### 2.1 核心组件

所有 `MV*` 模式都威少三个核心概念展开：

- Model（模型）
  - 负责**管理应用的数据和业务逻辑**。
  - **与数据源（如数据库、API）交互**。
  - 不关心数据如何被展示或用户如何与之交互。
- View（视图）
  - 负责 UI 的呈现和用户交互。
  - 显示 Model 中的数据。
  - 将用户的操作（如点击、输入）传递给其他组件处理。
- “Whatever”（中间协调者）
  - 这是 `MV*` 中变化的部分，可以是 Controller、Presenter 或 ViewModel。
  - 它充当 Model 和 View 之间的桥梁，处理用户输出、更新数据、并决定如何更新视图。

#### 2.2 MVC 模式详解

- 工作流程：

  - 用户与 View 交互。

  - View 将事件通知给 Controller。

  - Controller 处理事件，可能更新 Model。

  - Model 更新后，通知 View 进行刷新。

- 特点：

  - Controller 是主动的，它接收输入并决定如何响应。

  - View 和 Model 通常是直接通信的（View 观察 Model 的变化）。

  - 在 Web 开发中，Controller 常对应服务器端的路由和逻辑（如 Rails、Djanggo）。

- 前端应用：传统上，前端 MVC 较少见，Backbone.js 是一个典型的例子。

#### 2.3 MVP

`Model-View-Presenter`

- 工作流程：
  - 用户与 View 交互。
  - View 将事件委托给 Presenter。
  - Presenter 处理业务逻辑，操作 Model。
  - Model 变化后，通知 Presenter，
  - Presenter 获取新数据，并直接调用 View 的方法来更新 UI。
- 特点：
  - Presenter 完全掌控 View，View 是被动的（Passive View）。
  - View 和 Model 之间不直接通信，所有交互都通过 Presenter。
  - 便于单元测试，因为 Presenter 不依赖具体的 UI 实现。
- 应用场景：常用于桌面应用或需要高度可测试性的项目。

#### 2.4 MVVM

`Model-View-ViewModel`

- 工作流程：
  - ViewModel 暴露 Model 的数据和命令（Commands）。
  - View 通过数据绑定（Data Binding）与 ViewModel连接。
  - 用户与 View 交互，数据绑定自动将变化同步到 ViewModel。
  - ViewModel 更新 Model。
  - Model 变化时，通知 ViewModel，再通过数据绑定自动更新 View。
- 特点：
  - 核心是数据绑定，实现了 View和 ViewModel 的自动同步。
  - View 和 Model 完全解耦，开发者只需关注数据流。
  - ViewModel 是 View 的抽象，包含 UI 逻辑和状态。
- 前端应用：
  - Knockout.js：最早的 MVVM 框架。
  - Vue.js：其响应式系统和 `v-model` 指令是 MVVM 的完美体现。
  - Angular：虽然更接近 MVC/MVP，但其双向绑定也借鉴了 MVVM 的思想。
  - React+状态管理库：React 本身是 View 层，配合 Redux、MobX 等，可以构建类似 MVVM 的架构。

#### 2.5 MVVM 示例

Vue.js 中的 MVVM 实现，一个组件（Component）完美地体现了 MVVM 模式：

| MVVM 角色     | Vue.js 对应部分                                              | 说明                                                         |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Model**     | 组件的 `data` 属性中的数据、从 API 获取的数据、Vuex/Pinia 状态 | 代表应用的实际数据。                                         |
| **View**      | 组件的 `<template>` 部分 (HTML 模板)                         | 定义了 UI 的结构和外观。                                     |
| **ViewModel** | Vue 组件实例 (由 `<script>` 定义的选项或 `setup` 函数创建)   | 包含 `data`、`methods`、`computed`、`watch` 等。Vue 的响应式系统是其核心，实现了自动数据绑定。 |

假设创建一个组件，用于显示和编辑用户的姓名和状态。

```vue
<template>
    <!-- View 通过声明式模版绑定到 ViewModel -->
    <div class="user-info">
        <h2>用户信息</h2>

        <!-- 双向数据绑定：View <-> ViewModel -->
        <label>
            姓名：
            <input v-model="userInfo.name" type="text" />
        </label>

        <label>
            状态：
            <select v-model="userInfo.status">
                <option value="online">在线</option>
                <option value="offline">离线</option>
                <option value="away">离开</option>
            </select>
        </label>

        <!-- 单向绑定：Model -> View -->
        <p>当前状态：<strong>{{ userInfo.status }}</strong></p>

        <!-- 事件绑定：View -> ViewModel -->
        <button @click="saveChanges">保存更改</button>
        <button @click="resetForm"> 重置</button>
    </div>
</template>
```

```js
<script>
// ==================== VIEWMODEL & MODEL ====================
export default {
    name: 'UserInfo',

    date() {
        // Model：组件的本地状态数据
        // 这既是 Model（数据）也是 ViewModel 的一部分（响应式源）
        return {
            userInfo: {
                name: '张三',
                status: 'online'
            },
            // 初始值可以来自 API 调用
            originUserInfo: null // 用于重置
        }
    },

    created() {
        // 模拟从 API 获取数据后保存到 Model
        this.fetchUserData().then(
            data => {
                this.userInfo = data
            }
        )
        this.originUserInfo = { ...this.userInfo } // 保存初始状态
    },

    methods: {
        // ViewModel：包含处理用户交互的方法（Commands）

        saveChanges() {
            // ViewModel：处理逻辑：将更改保存到后端（Model 的持久化）
            console.log('保存用户信息：', this.userInfo);
            // 模拟 API 调用
            // api.saveUser(this.userInfo).then(() => {
            //     alert('保存成功！');
            // });
        },

        resetForm() {
            // ViewModel 操作：将 Model 重置为原始状态
            this.userInfo = { ...this.originUserInfo };
            // View 会自动更新，无需手动操作 DOM
        }
    },

    computed: {
        // ViewModel：计算属性 — 基于 Model 派生数据
        // 也是响应式的，会自动更新
        displayName() {
            return this.userInfo.name || '未命名用户';
        }
    },

    watch: {
        // viewModel：监听器 - 响应 Model 的变化
        'userInfo.status'(newStatus, oldStatus) {
            console.log(`状态从 ${oldStatus} 变更为 ${newStatus}`)；
            // 可以在此出发其他逻辑，如发送状态更新事件
        }
    }
}
</script>
```

**MVVM 工作流程解析**（用户修改姓名并点击“保存”）：

- 用户交互（View）：
  - 用户在 `<input>` 框中将姓名从 "张三" 修改为 "李四"。
- 数据绑定（ViewModel）：
  - `v-model="userInfo.name"` 建立了**双向数据绑定**。
  - 输入框内容的改变会**自动**触发 Vue 的响应式系统。
  - Vue 更新 `data()` 中 `userInfo.name` 的值（Model 被更新）。
- Model 更新：
  - `this.userInfo.name` 的值变为 "李四"。
- 自动视图更新（View）：
  - 由于数据绑定，任何依赖 `userInfo.name` 的地方都会自动更新。
  - (如果模板中有 `{{ userInfo.name }}`，它会立即显示 "李四")。
- 用户点击按钮（View）：
  - 用户点击 "保存更改" 按钮。
- 事件处理（ViewModel）：
  - `@click="saveChanges"` 监听点击事件。
  - 事件触发 `methods` 中的 `saveChanges` 方法。
- ViewModel 执行逻辑：
  - `saveChanges` 方法执行，它使用当前 `userInfo` 对象（已包含新姓名 "李四"）。
  - 方法内部可以调用 API 将新数据保存到服务器（持久化 Model）。
- 状态监听（ViewModel）：
  - 如果用户改变了状态，watch 会检测到 userInfo.status 的变化，并执行相应的逻辑。

**关键优势（MVVM 在 Vue 中的体现）**

- 声明式渲染：开发者只需在 `<template>` 中声明 UI 应该是什么样子，Vue 自动处理 DOM 更新。
- 双向数据绑定（v-model）：表单输入和数据状态自动同步，极大简化了表单处理。
- 关注点分离：
  - HTML 结构在 `<template>`。
  - JavaScript 逻辑在 `<script>`。
  - CSS 样式在 `<style>`。
  - 数据、方法、计算属性、监听器职责分明。
-  响应式系统：这是 Vue 作为 ViewModel 的核心。当 Model（data）变化时，View 自动更新；当 View 因用户交互变化时，Model 也自动更新。
- 开发效率高：开发者无需手动操作 DOM (`document.getElementById`, `.innerText = ...`)，可以专注于数据和逻辑。



### 三、数据变更检测

---

#### 3.1 基于 getter/setter 的响应式系统

**（Vue2 &3 的 data 选项，Anglular）**

- 原理：
  - 框架在初始化时，遍历数据对象的所有属性。
  - 使用 `Object.defineProperty()` (Vue 2) 或 `Proxy` (Vue 3) 将这些属性转换为**访问器属性**（getter 和 setter）。
  - **Getter**：在读取属性时被触发，用于**收集依赖**（即哪些组件或计算属性依赖于这个数据）。
  - **Setter**：在修改属性时被触发，用于**通知变更**（通知所有依赖此数据的观察者进行更新）。
- 流程：
  - **初始化/渲染**：组件首次渲染时，会读取其模板中用到的数据（如`{{user.name}}`）。
  - **依赖收集**：读取操作触发 getter，框架记录当前组件依赖于 `user.name`。
  - **数据变更**：当 `user.name = '新名字'` 时，setter 被触发。
  - **派发更新**：setter 通知所有依赖 `user.name` 的组件或计算属性：“数据变了，需要更新”。
  - **视图更新**：相关组件重新渲染或部分更新 DOM。
- 优点：
  - 精确：能精确知道是哪个属性发生了变化。
  - 高效：可以做到细粒度的更新。
- 缺点（主要针对 Vue2）：
  - 无法检测对象属性的动态添加/删除（Vue 2 中需用 `Vue.set`）。
  - 数组某些原生方法（如 `arr[index] = newVal`）不会触发 setter（Vue 2 中已通过重写数组方法解决）。

#### 3.2 ~~脏检查~~

**（AngularJS 1.x）**

- 原理：
  - 框架维护一个“脏值检查”循环。
  - 在特定时机（如事件处理后、`$timeout` 结束），框架会遍历所有被监视的数据（`$scope` 上的变量）
  - 将当前值与上一次记录的值进行比较。
  - 如果发现不同（“变脏”了），则标记该数据需要更新，并触发视图更新。
- 流程：
  - 用户触发操作事件。
  - 事件处理函数执行，可能修改数据。
  - 事件结束后，AngularJS 启动脏检查循环。
  - 遍历所有 `$watch` 表达式，比较新旧值。
  - 如果有变化，执行相应的回调（通常是更新 DOM）。
  - 循环继续，直到所有值都稳定（“干净”）为止。
- 优点：
  - 概念简单，对数据没有特殊要求（可以是任何 JavaScript 对象）。
- 缺点：
  - 性能差：需要遍历所有监视项，即使大多数数据未变化。应用越大，性能越差。
  - 不可预测：需要手动触发 `$digest` 循环。

#### 3.3 虚拟 DOM + Diff 算法

**（React，Vue3 的部分场景）**

- 原理：
  - 框架并不直接追踪数据变化，而是假设数据**可能**已经变化。
  - 当组件状态（`state`）或属性（`props`）更新时，框架会**重新执行**组件的渲染函数，生成一个新的**虚拟 DOM 树**。
  - 将新的虚拟 DOM 树与上一次的虚拟 DOM 树进行**Diff**（差异比较）。
  - 计算出最小的、需要对真实 DOM 进行的操作（如更新文本、添加/删除节点）。
  - 将这些操作**批量**应用到真实 DOM。
- 流程：
  - `setState()` 或 `useState` 的 setter 被调用。
  - 组件被标记为“需要更新”。
  - 在下一个渲染周期，组件的 `render()` 函数被调用，生成新 VDOM。
  - Diff 算法比较新旧 VDOM。
  - 计算出补丁（Patch），更新真实 DOM。
- 优点：
  - **简单可靠**：不依赖复杂的响应式系统，逻辑清晰。
  - **可预测**：只要状态改变，就重新渲染。
  - **跨平台**：虚拟 DOM 是 JavaScript 对象，可渲染到 Web、Native 等。
- 缺点：
  - 需要重新执行渲染函数，如果组件复杂，可能有性能开销（但 Diff 算法和 `React.memo` 等优化可缓解）。

#### 3.4 编译时响应式

**（Svelte，Qwik）**

- 原理：
  - 在**编译阶段**分析组件代码。
  - 自动插入变更检测和 DOM 更新的代码。
  - 运行时不需要框架的响应式运行时库，生成的代码非常高效。
- 优点：
  - **极致性能**：运行时开销极小，接近手写 JavaScript。
  - **体积小**：无需打包框架的运行时。
- 缺点：
  - 需要构建步骤，开发体验略有不同。



### 四、Virtual DOM 交互模式

---

**Virtual DOM（虚拟 DOM）是一种用于高效更新真实 DOM 的技术或策略**，它深刻地影响了现代前端框架的**交互和更新模式**。它本身不是一种架构模式，而是实现“数据驱动视图”这一交互理念的核心引擎。

#### 4.1 核心思想

- **在内存中维护一个轻量级的、与真实 DOM 对应的 JavaScript 对象树（即 Virtual DOM）**。
- 当应用状态（State）发生变化时，框架会**重新生成一个新的 Virtual DOM 树**。
- 将**新的 Virtual DOM 树**与**上一次的 Virtual DOM 树**进行**Diff 算法**比较，找出两者之间的**最小差异**（即需要对真实 DOM 进行哪些操作）。
- 将这些差异**批量**应用到真实 DOM 上，完成视图更新。

这个过程将“**如何更新 DOM**”的复杂性从开发者手中接管，开发者只需关心“**UI 应该是什么样子**”（通过声明式模板或 JSX 描述）。

#### 4.2 工作流程详解

假设有一个简单的计数器组件：

```vue
<template>
  <!-- ========== VIEW ========== -->
  <!-- 模板会被编译成一个渲染函数，返回 Virtual DOM (VNode) -->
  <div class="counter">
    <h1>计数: {{ count }}</h1>
    <button @click="increment">+1</button>
    <p>双倍计数: {{ doubleCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

// ========== STATE & LOGIC ==========

// 响应式数据 (Reactive State) - 相当于 Model
// Vue 3 使用 Proxy 实现响应式，但 Virtual DOM 机制独立工作
const count = ref(0)

// 计算属性 - 基于响应式数据派生
const doubleCount = computed(() => count.value * 2)

// 事件处理函数 - 处理用户交互
function increment() {
  count.value++ // 修改状态
  // 在 Vue 中，这会触发响应式系统
  // 响应式系统会通知依赖 count 的组件需要重新渲染
  // 进而触发 Virtual DOM 的更新流程
}
</script>

<style scoped>
.counter {
  padding: 20px;
  text-align: center;
}
button {
  margin: 10px;
  padding: 8px 16px;
  font-size: 16px;
}
</style>
```

1. 初始渲染（Mounting）

   - 模板编译：

     - Vue 的编译器（在构建时或运行时）将 `<template>` 中的 HTML 模板编译成一个**渲染函数**（render function）。
     - 这个渲染函数接收当前组件的状态（`count`, `doubleCount`）作为输入，返回一个描述 UI 结构的 **Virtual DOM 树**（在 Vue 中称为 VNode Tree）。

   - 执行渲染函数：

     - 初始时 `count.value = 0`, `doubleCount.value = 0`。

     - 渲染函数被执行，生成初始的 VNode 树：

       ```js
       // 简化的 VNode 结构
       {
         type: 'div',
         props: { class: 'counter' },
         children: [
           { type: 'h1', children: '计数: 0' },
           { type: 'button', props: { onClick: increment }, children: '+1' },
           { type: 'p', children: '双倍计数: 0' }
         ]
       }
       ```

   - 创建真实 DOM：

     - Vue 的渲染器（Renderer）遍历这个 VNode 树，根据每个 VNode 的描述创建对应的**真实 DOM 元素**（`<div>`, `<h1>`, `<button>`, `<p>`）。
     - 将这些真实 DOM 元素插入到页面中。
     - 此时，Vue 内部保存了这个初始的 VNode 树作为**基准**（previous VNode tree）。

2. 用户交互与状态变更

   - 用户点击按钮：
     - `@click` 事件监听器触发，执行 `increment()` 函数。
   - 修改响应式状态：
     - `increment()` 函数中执行 `count.value++`。
     - 由于 `count` 是通过 `ref()` 创建的响应式对象，Vue 的响应式系统（基于 `Proxy`）会**拦截**这个赋值操作。
     - 响应式系统知道 `count` 被修改了，并且**追踪到**哪些依赖（effect）需要更新。
   - 触发组件更新：
     - 在 Vue 3 中，组件的整个 `setup()` 函数或 `<template>` 被视为一个**副作用**（effect）。
     - `count` 的变化会**触发**这个副作用重新执行（即组件需要重新渲染）。
     - **注意**：这里与 React 不同。React 是“状态变 -> 重新调用组件函数”，Vue 3 是“响应式依赖变 -> 重新执行渲染”（本质类似，但触发机制基于响应式系统）。

3. 重新渲染与 Diff（Re-render & Reconciliation）

   - 生成新的 VNode 树：

     - 组件进入更新流程。

     - `count.value` 现在是 `1`，`doubleCount.value` 自动计算为 `2`。

     - **渲染函数再次被执行**，生成**新的 VNode 树**：

       ```js
       {
         type: 'div',
         props: { class: 'counter' },
         children: [
           { type: 'h1', children: '计数: 1' },     // 变化
           { type: 'button', props: { onClick: increment }, children: '+1' },
           { type: 'p', children: '双倍计数: 2' }   // 变化
         ]
       }
       ```

   - Diff 算法（Patch/Reconciliation）：

     - Vue 的渲染器将**新的 VNode 树**与**上一次保存的 VNode 树**（`count=0` 时的树）进行比较。

     - Diff 过程：

       - **根节点对比**：两个 VNode 的 `type` 都是 `'div'`，类型相同，可以复用真实 DOM 节点，进入子节点对比。

       - 子节点对比（简化为同层级对比）：

         - 第一个子节点 (`h1`)：类型相同，但 `children` 从 `'计数: 0'` 变为 `'计数: 1'`。标记为需要**更新文本内容**。

         - 第二个子节点 (`button`)：类型、`props`、`children` 完全相同。**跳过**，无需更新。

         - 第三个子节点 (`p`)：类型相同，但 `children` 从 `'双倍计数: 0'` 变为 `'双倍计数: 2'`。标记为需要**更新文本内容**。

     - Vue 3 的 Diff 算法比 Vue 2 更加优化，例如对静态节点的提升（hoist static nodes）、缓存事件处理函数等。

   - 打补丁（Patching）：

     - 渲染器根据 Diff 的结果，生成一个**补丁**（patch）。
     - 这个补丁包含两个操作：
       1. 更新 `<h1>` 元素的 `textContent` 为 `'计数: 1'`。
       2. 更新 `<p>` 元素的 `textContent` 为 `'双倍计数: 2'`。
     - 这些操作被**批量**应用到真实 DOM 上。

4. 视图完成更新

   - 真实 DOM 被更新，用户看到页面上的计数和双倍计数都已变化。
   - Vue 内部将**新的 VNode 树**保存下来，作为下一次更新的“上一次 VNode 树”。
   - 整个流程结束。

#### 4.3 为什么需要 Virtual DOM

直接操作真实 DOM 非常昂贵，因为：

- **重排 (Reflow)**：DOM 结构变化可能触发浏览器重新计算所有元素的几何属性（位置、大小）。
- **重绘 (Repaint)**：样式变化可能触发浏览器重新绘制页面的一部分或全部。
- **性能瓶颈**：频繁的 DOM 操作会导致页面卡顿。

Virtual DOM 通过以下方式解决这些问题：

1. **批量更新**：将多次 DOM 操作合并为一次，减少重排重绘次数。
2. **最小化操作**：通过 Diff 算法，只更新真正变化的部分，避免不必要的 DOM 操作。
3. **跨平台**：Virtual DOM 是纯 JavaScript 对象，可以渲染到 Web、Native（React Native）、Canvas 等不同环境。

#### 4.4 Virtual DOM 的“交互模式”特点

- 声明式 UI
  - 开发者描述 “UI 应该是什么”，而不是“如何一步步修改 UI”。
  - 交互逻辑简化为“状态变更 -> 重新渲染”。
- 不可变性倾向
  - 为了高效 Diff，框架鼓励使用不可变数据。直接修改对象（`obj.prop = newVal`）很难被检测和比较。
  - 应该创建新对象（`{...obj, prop: newVal}`）来表示状态变化。
- 函数式组件
  - 组件被设计为纯函数：`UI = f(state)`。
  - 给定相同的 `state` 和 `props`，总是返回相同的 Virtual DOM 结构。
- 单向数据流
  - 数据从父组件流向子组件（通过 props）。
  - 子组件通过回调函数（事件）通知父组件状态变化。
  - Virtual DOM 的更新流程天然支持这种模式。