

### 一、ECMAScript5

---

ECMAScript 5 (ES5) 是 JavaScript 语言的一个重要里程碑版本，于2009年12月正式发布。它在之前的版本（主要是 ES3）基础上进行了重大改进和标准化，极大地增强了语言的能力和一致性，并为现代 Web 开发奠定了坚实的基础。

#### 1.1 严格模式（Strict Mode）

ES5 引入了 `strict mode`，通过在脚本或函数顶部添加 `"use strict";` 指令来启用。它改变了 JavaScript 的执行方式，使其更严格、更安全。

**优点:**

- **捕获常见错误**：例如，给未声明的变量赋值会抛出错误（而不是创建全局变量）。
- **防止意外全局变量**：禁止意外创建全局变量。
- **函数参数限制**：禁止函数参数重名。
- **`this` 绑定**：在非方法调用的函数中，`this` 不再指向全局对象（如 `window`），而是 `undefined`。
- **禁止删除变量/函数/函数参数**。
- **保留字限制**：对 `eval` 和 `arguments` 的使用有更多限制。
- **禁止八进制语法**。

>强烈建议在所有代码中使用严格模式。

#### 1.2 对象属性的属性描述符（Property Property Descriptors）

ES5 引入了对对象属性的元数据（称为“属性描述符”）进行更精细控制的能力。

1. **数据属性描述符：**

   - `value`：属性的值。

   - `writable`：布尔值，表示属性值是否可修改。

   - `enumerable`：布尔值，表示属性是否可被 `for...in` 循环枚举。

   - `configurable`：布尔值，表示属性描述符本身是否可被修改或属性是否可被删除。

2. **访问器属性描述符：**

   - `get`: 获取属性值时调用的函数。
   - `set`: 设置属性值时调用的函数。
   - `enumerable`, `configurable`: 同上。

3. **相关方法：**

   - `Object.defineProperty(obj, prop, descriptor)`: 定义或修改一个对象的属性及其描述符。
   - `Object.defineProperties(obj, props)`: 同时定义或修改多个属性。
   - `Object.getOwnPropertyDescriptor(obj, prop)`: 获取一个自有属性的描述符。
   - `Object.getOwnPropertyNames(obj)`: 返回对象所有自有属性（包括不可枚举的）的名称数组。

#### 1.3 对象创建与原型

- `Object.create(proto, [propertiesObject])`：提供了一种更直接的方式创建一个新对象，并将其原型设置为指定的对象 proto 。这是实现原型继承的更清晰方法。

  ```js
  const parent = { greet: function() { console.log("Hello!"); } };
  const child = Object.create(parent); // child 的原型是 parent
  child.greet(); // "Hello!"
  ```

- `Object.getPrototypeOf(obj)`返回指定对象的原型（内部 `[[Prototype]]` 属性的值）。

- `Object.setPrototypeOf(obj, prototype)`: （ES5.1 引入，但通常被认为性能不佳，不推荐在热路径使用）设置一个对象的原型。

#### 1.4 数组方法的扩展

ES5 为 `Array.prototype` 添加了许多非常有用的高阶函数，简化了数组操作：

- 遍历与转换：
  - `forEach(callback[, thisArg])`: 对数组每个元素执行一次回调函数。
  - `map(callback[, thisArg])`: 创建一个新数组，其结果是原数组每个元素调用回调函数后的返回值。
  - `filter(callback[, thisArg])`: 创建一个新数组，包含原数组中满足回调函数条件的元素。
  - `reduce(callback[, initialValue])`: 从左到右对数组的每个元素执行一个回调函数，将其结果汇总为一个单一的值。
  - `reduceRight(callback[, initialValue])`: 与 `reduce` 类似，但从右到左。
- 查找与判断：
  - `some(callback[, thisArg])`: 如果数组中至少有一个元素满足回调函数条件，则返回 `true`。
  - `every(callback[, thisArg])`: 如果数组中的所有元素都满足回调函数条件，则返回 `true`。
  - `indexOf(searchElement[, fromIndex])`: 返回数组中第一个匹配给定元素的索引，未找到返回 -1。
  - `lastIndexOf(searchElement[, fromIndex])`: 返回数组中最后一个匹配给定元素的索引，未找到返回 -1。

#### 1.5 字符串方法

`trim()`: 移除字符串首尾的空白字符（空格、制表符、换行符等）。

#### 1.6 函数方法

`Function.prototype.bind(thisArg[, arg1[, arg2[, ...]]])`：创建一个新函数，当被调用时，其 this 关键字设置为提供的值 thisArg，并带有指定的参数序列。这在需要控制 this 上下文（如事件处理、回调）时非常有用。

```js
function greet() { console.log(`Hello, ${this.name}`); }
const person = { name: "Alice" };
const boundGreet = greet.bind(person);
boundGreet(); // "Hello, Alice"
```

#### 1.7 JSON 支持

ES5 内置了对 JSON（JavaScript Object Notation）的原生支持：

- `JSON.parse(text[, reviver])`: 将 JSON 字符串解析为 JavaScript 值。
- `JSON.stringify(value[, replacer[, space]])`: 将 JavaScript 值转换为 JSON 字符串。



### 二、ECMAScript6

---

ECMAScript 2015 (ES2015)，通常被称为 **ECMAScript 6 (ES6)** 或 **ES6+**，是 JavaScript 语言历史上一次革命性的重大更新，于2015年6月正式发布。它引入了大量现代化的语法特性和编程概念，极大地提升了 JavaScript 的表达能力、可读性和开发效率，使其能够更好地构建复杂的应用程序。

#### 2.1 变量声明：let 和 const

取代了 `var`，解决了其变量提升和函数作用域带来的问题。

- `let`：
  - **块级作用域**: 变量只在 `{}` 内部有效。
  - **不存在变量提升**: 在声明前访问会报错（Temporal Dead Zone - 临时死区）。
  - **可重新赋值**。
- `const`：
  - **块级作用域**。
  - **不存在变量提升**。
  - **声明时必须初始化**。
  - **声明后不可重新赋值**（对于对象和数组，其引用不可变，但对象的属性或数组的元素可以修改）。

> 优先使用 `const`，只有在需要重新赋值时才使用 `let`，避免使用 `var`。

#### 2.2 箭头函数

提供了一种更简洁的函数语法，并解决了 `this` 绑定的问题。

- 语法：

  ```js
  // 基本语法
  const add = (a, b) => a + b;
  
  // 多行函数体需要 {}
  const greet = (name) => {
      console.log(`Hello, ${name}!`);
      return `Hi, ${name}`;
  };
  
  // 单个参数可省略 ()
  const square = x => x * x;
  
  // 返回对象字面量需要 ()
  const createPerson = (name, age) => ({ name, age });
  ```

- `this` 绑定：

































































