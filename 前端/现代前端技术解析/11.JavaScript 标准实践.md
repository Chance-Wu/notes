

### 一、ECMAScript5

---

ECMAScript 5 (ES5) 是 JavaScript 语言的一个重要里程碑版本，于2009年12月正式发布。它在之前的版本（主要是 ES3）基础上进行了重大改进和标准化，极大地增强了语言的能力和一致性，并为现代 Web 开发奠定了坚实的基础。

#### 1.1 严格模式（Strict Mode）

ES5 引入了 `strict mode`，通过在脚本或函数顶部添加 `"use strict";` 指令来启用。它改变了 JavaScript 的执行方式，使其更严格、更安全。

**优点:**

- **捕获常见错误**：例如，给未声明的变量赋值会抛出错误（而不是创建全局变量）。
- **防止意外全局变量**：禁止意外创建全局变量。
- **函数参数限制**：禁止函数参数重名。
- **`this` 绑定**：在非方法调用的函数中，`this` 不再指向全局对象（如 `window`），而是 `undefined`。
- **禁止删除变量/函数/函数参数**。
- **保留字限制**：对 `eval` 和 `arguments` 的使用有更多限制。
- **禁止八进制语法**。

>强烈建议在所有代码中使用严格模式。

#### 1.2 对象属性的属性描述符（Property Property Descriptors）

ES5 引入了对对象属性的元数据（称为“属性描述符”）进行更精细控制的能力。

1. **数据属性描述符：**

   - `value`：属性的值。

   - `writable`：布尔值，表示属性值是否可修改。

   - `enumerable`：布尔值，表示属性是否可被 `for...in` 循环枚举。

   - `configurable`：布尔值，表示属性描述符本身是否可被修改或属性是否可被删除。

2. **访问器属性描述符：**

   - `get`: 获取属性值时调用的函数。
   - `set`: 设置属性值时调用的函数。
   - `enumerable`, `configurable`: 同上。

3. **相关方法：**

   - `Object.defineProperty(obj, prop, descriptor)`: 定义或修改一个对象的属性及其描述符。
   - `Object.defineProperties(obj, props)`: 同时定义或修改多个属性。
   - `Object.getOwnPropertyDescriptor(obj, prop)`: 获取一个自有属性的描述符。
   - `Object.getOwnPropertyNames(obj)`: 返回对象所有自有属性（包括不可枚举的）的名称数组。

#### 1.3 对象创建与原型

- `Object.create(proto, [propertiesObject])`：提供了一种更直接的方式创建一个新对象，并将其原型设置为指定的对象 proto 。这是实现原型继承的更清晰方法。

  ```js
  const parent = { greet: function() { console.log("Hello!"); } };
  const child = Object.create(parent); // child 的原型是 parent
  child.greet(); // "Hello!"
  ```

- `Object.getPrototypeOf(obj)`返回指定对象的原型（内部 `[[Prototype]]` 属性的值）。

- `Object.setPrototypeOf(obj, prototype)`: （ES5.1 引入，但通常被认为性能不佳，不推荐在热路径使用）设置一个对象的原型。

#### 1.4 数组方法的扩展

ES5 为 `Array.prototype` 添加了许多非常有用的高阶函数，简化了数组操作：

- 遍历与转换：
  - `forEach(callback[, thisArg])`: 对数组每个元素执行一次回调函数。
  - `map(callback[, thisArg])`: 创建一个新数组，其结果是原数组每个元素调用回调函数后的返回值。
  - `filter(callback[, thisArg])`: 创建一个新数组，包含原数组中满足回调函数条件的元素。
  - `reduce(callback[, initialValue])`: 从左到右对数组的每个元素执行一个回调函数，将其结果汇总为一个单一的值。
  - `reduceRight(callback[, initialValue])`: 与 `reduce` 类似，但从右到左。
- 查找与判断：
  - `some(callback[, thisArg])`: 如果数组中至少有一个元素满足回调函数条件，则返回 `true`。
  - `every(callback[, thisArg])`: 如果数组中的所有元素都满足回调函数条件，则返回 `true`。
  - `indexOf(searchElement[, fromIndex])`: 返回数组中第一个匹配给定元素的索引，未找到返回 -1。
  - `lastIndexOf(searchElement[, fromIndex])`: 返回数组中最后一个匹配给定元素的索引，未找到返回 -1。

#### 1.5 字符串方法

`trim()`: 移除字符串首尾的空白字符（空格、制表符、换行符等）。

#### 1.6 函数方法

`Function.prototype.bind(thisArg[, arg1[, arg2[, ...]]])`：创建一个新函数，当被调用时，其 this 关键字设置为提供的值 thisArg，并带有指定的参数序列。这在需要控制 this 上下文（如事件处理、回调）时非常有用。

```js
function greet() { console.log(`Hello, ${this.name}`); }
const person = { name: "Alice" };
const boundGreet = greet.bind(person);
boundGreet(); // "Hello, Alice"
```

#### 1.7 JSON 支持

ES5 内置了对 JSON（JavaScript Object Notation）的原生支持：

- `JSON.parse(text[, reviver])`: 将 JSON 字符串解析为 JavaScript 值。
- `JSON.stringify(value[, replacer[, space]])`: 将 JavaScript 值转换为 JSON 字符串。



### 二、ECMAScript6

---

ECMAScript 2015 (ES2015)，通常被称为 **ECMAScript 6 (ES6)** 或 **ES6+**，是 JavaScript 语言历史上一次革命性的重大更新，于2015年6月正式发布。它引入了大量现代化的语法特性和编程概念，极大地提升了 JavaScript 的表达能力、可读性和开发效率，使其能够更好地构建复杂的应用程序。

#### 2.1 变量声明：let 和 const

取代了 `var`，解决了其变量提升和函数作用域带来的问题。

- `let`：
  - **块级作用域**: 变量只在 `{}` 内部有效。
  - **不存在变量提升**: 在声明前访问会报错（Temporal Dead Zone - 临时死区）。
  - **可重新赋值**。
- `const`：
  - **块级作用域**。
  - **不存在变量提升**。
  - **声明时必须初始化**。
  - **声明后不可重新赋值**（对于对象和数组，其引用不可变，但对象的属性或数组的元素可以修改）。

> 优先使用 `const`，只有在需要重新赋值时才使用 `let`，避免使用 `var`。

#### 2.2 箭头函数

提供了一种更简洁的函数语法，并解决了 `this` 绑定的问题。

- 语法：

  ```js
  // 基本语法
  const add = (a, b) => a + b;
  
  // 多行函数体需要 {}
  const greet = (name) => {
      console.log(`Hello, ${name}!`);
      return `Hi, ${name}`;
  };
  
  // 单个参数可省略 ()
  const square = x => x * x;
  
  // 返回对象字面量需要 ()
  const createPerson = (name, age) => ({ name, age });
  ```

- this 绑定：箭头函数没有自己的 this。它的 this 继承自外层（包裹它的）函数或全局作用域的 this 值。这使得在回调函数中使用 this 时不再需要 .bind(this) 或保存 self = this。

#### 2.3 模板字符串

使用反引号 (```) 定义，支持多行字符串和字符串插值。

- 字符串插值：

  ```js
  const name = "Alice";
  const age = 30;
  const message = `Hello, my name is ${name} and I am ${age} years old.`;
  ```

- 多行字符串：

  ```js
  const html = `
  <div>
      <h1>Title</h1>
      <p>Content</p>
  </div>
  `;
  ```

- 标签模板：允许使用函数来解析模板字符串，常用于国际化、CSS-in-JS等。

#### 2.4 结构赋值

从数组或对象中提取数据并赋值给变量，语法简洁。

- **数组解构**：

  ```js
  const [first, second] = ["apple", "banana", "cherry"];
  console.log(first); // "apple"
  
  // 跳过元素
  const [,, third] = ["a", "b", "c"];
  console.log(third); // "c"
  
  // 默认值
  const [x = 1, y = 2] = [10]; // x=10, y=2
  ```

- **对象解构**：

  ```js
  const person = { name: "Bob", age: 25, city: "NYC" };
  const { name, age } = person;
  console.log(name); // "Bob"
  
  // 重命名变量
  const { name: personName, age: personAge } = person;
  
  // 默认值
  const { name, hobby = "reading" } = person;
  ```

#### 2.5 默认参数

允许在函数定义时为参数指定默认值。

```js
function greet(name = "Guest", greeting = "Hello") {
    console.log(`${greeting}, ${name}!`);
}
greet(); // "Hello, Guest!"
greet("Alice"); // "Hello, Alice!"
greet("Bob", "Hi"); // "Hi, Bob!"
```

#### 2.6 展开语法（Spread Syntax）和剩余参数（Rest Parameters）

**展开语法(...)**：

- 将数组或对象的元素展开

- 数组：

  ```js
  const arr1 = [1, 2];
  const arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]
  const copy = [...arr1]; // 创建副本
  Math.max(...[1, 2, 3]); // 等价于 Math.max(1, 2, 3)
  ```

- 对象：

  ```js
  const obj1 = { a: 1, b: 2 };
  const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }
  const copy = { ...obj1 }; // 浅拷贝
  ```

**剩余参数(...)**：

- 将函数的多个参数收集到一个数组中。

  ```js
  function sum(...numbers) {
      return numbers.reduce((acc, num) => acc + num, 0);
  }
  sum(1, 2, 3, 4); // 10
  ```

#### 2.7 对象字面量简写

简化了对象的定义。

```js
const name = "Charlie";
const age = 35;

// ES6 简写
const person = {
    name, // 等价于 name: name
    age,  // 等价于 age: age
    // 方法简写
    greet() {
        console.log(`Hi, I'm ${this.name}`);
    }
};
```

#### 2.8 类（Classes）

提供了基于类的面向对象编程的语法糖，底层仍是原型继承。

```js
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // 实例方法
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }

    // 静态方法
    static createAnonymous(age) {
        return new Person("Anonymous", age);
    }
}

class Student extends Person {
    constructor(name, age, grade) {
        super(name, age); // 调用父类构造函数
        this.grade = grade;
    }

    // 重写方法
    greet() {
        super.greet(); // 调用父类方法
        console.log(`I'm in grade ${this.grade}`);
    }
}

const student = new Student("Diana", 20, "A");
student.greet();
```

#### 2.9 模块（Modules）

提供了原生的模块系统，用于组织和共享代码。

- 导出（export）

  ```js
  /**
   * 圆周率常量
   */
  export const PI = 3.1415926
  
  /**
   * 两个数相加
   * @param {number} a 第一个加数
   * @param {number} b 第二个加数
   * @returns {number} 两个数的和
   */
  export function add(a, b) {
      return a + b;
  }
  
  /**
   * 默认导出（一个模块只能有一个）
   */
  export default function multiply(a, b) {
      return a * b;
  }
  ```

- 导入（import）

  ```js
  import multiply, { PI, add } from "./math";
  // 或者重命名
  // import multiply, { PI as pi, add } from './math.js';
  
  console.log(multiply(2, 3));
  console.log(add(PI, 1));
  ```

#### 2.10 Promise

为异步编程提供了更强大的原生支持，解决了“回调地狱”问题。

```js
// 创建 Promise
const fetchData = () => {
    return new Promise((resolve, reject) => {
        // 模拟异步操作
        setTimeout(() => {
            const success = true;
            if (success) {
                resolve("Data fetched successfully!");
            } else {
                reject("Failed to fetch data.");
            }
        }, 1000);
    });
};

// 使用 Promise
fetchData()
    .then(data => console.log(data))
    .catch(error => console.error(error));
```

#### 2.11 其他重要特性

- 迭代器（Iterators）和 `for...of` 循环（可以遍历实现了迭代器协议的对象（如数组、字符串、Map、Set））

  ```js
  for (const item of [1, 2, 3]) {
      console.log(item);
  }
  ```

- Map 和 Set

  - `Map`: 键值对集合，键可以是任何类型。
  - `Set`: 值的集合，值唯一。

- Symbol：一种新的原始数据类型，表示独一无二的值，常用于创建对象的私有属性或定义内置方法（如 Symbol.iterator）。

- Proxy 和 Reflext：（高级特性）允许你拦截和自定义对象的基本操作（如属性读取、赋值）。



### 三、ECMAScript7+

---

在 ECMAScript 2015 (ES6) 这一重大更新之后，TC39 委员会采用了**年度发布模式**。这意味着从 2016 年开始，每年都会发布一个包含相对较小但实用特性的新版本 ECMAScript 标准。我们通常将 ES6 之后的版本统称为 **ES7+** 或 **现代 JavaScript**。

#### 3.1 ES2016（ES7）

- `Array.prototype.includes(searchElement, fromIndex?)`:

  - 检查数组是否包含指定元素，返回 `true` 或 `false`。
  - 解决了 `indexOf` 无法区分 `NaN` 和 `-0` 的问题，且语法更直观。

  ```js
  [1, 2, 3].includes(2); // true
  [1, 2, NaN].includes(NaN); // true (而 indexOf 无法做到)
  ```

- **求幂运算符 (`**`)**:

  提供了更简洁的指数运算语法。

  ```js
  const result = 2 ** 3; // 8
  // 等价于 Math.pow(2, 3)
  ```

#### 3.2 ES2017（ES8）

- `async`/`await`:

  这是继 Promise 之后异步编程的又一重大飞跃。`async` 函数返回一个 Promise，`await` 关键字可以在 `async` 函数内部“暂停”执行，等待 Promise 解决，使异步代码看起来像同步代码，极大提高了可读性和可维护性。

  ```js
  async function fetchData() {
      try {
          const response = await fetch('/api/data');
          const data = await response.json();
          console.log(data);
      } catch (error) {
          console.error('Error:', error);
      }
  }
  ```

- `Object.values(obj)` 和 `Object.entries(obj)`：

  - `Object.values()`: 返回对象自身所有可枚举属性值的数组。
  - `Object.entries()`: 返回对象自身所有可枚举属性 `[key, value]` 对的数组。这使得遍历对象属性变得非常方便。

  ```js
  const obj = { a: 1, b: 2 };
  Object.values(obj); // [1, 2]
  Object.entries(obj); // [['a', 1], ['b', 2]]
  for (const [key, value] of Object.entries(obj)) {
      console.log(`${key}: ${value}`);
  }
  ```

- 字符串填充 (`padStart` / `padEnd`)：

  - `str.padStart(targetLength, padString?)`：从字符串开头填充，直到达到指定长度。
  - `str.padEnd(targetLength, padString?)`：从字符串末尾填充，直到达到指定长度。

  ```js
  '5'.padStart(3, '0'); // '005'
  '5'.padEnd(3, '0'); // '500'
  ```

- `Object.getOwnPropertyDescriptors(obj)`：返回一个对象，其属性是对象 `obj` 自身所有属性的属性描述符。

- 尾逗号：允许在函数参数列表和调用中使用尾随逗号（在最后一个参数后），这在版本控制和代码生成中很有用。

  ```js
  function foo(
      param1,
      param2, // 允许这里的逗号
  ) { /* ... */ }
  
  foo(
      'arg1',
      'arg2', // 允许这里的逗号
  );
  ```

#### 3.3 ES2018（ES9）

---

- 异步迭代（for await...of）：用于遍历异步可迭代对象（如异步生成器产生的序列）。

  ```js
  async function* asyncGenerator() {
      yield 'a';
      yield 'b';
  }
  
  for await (const item of asyncGenerator()) {
      console.log(item); // 'a', then 'b'
  }
  ```

- `Promise.prototype.finally()`：注册一个回调函数，无论 Promise 是 fulfilled 还是 rejected，都会在 Promise 链的最后执行。常用于清理工作（如隐藏加载指示器）。

  ```js
  fetch('/api/data')
      .then(data => console.log(data))
      .catch(error => console.error(error))
      .finally(() => {
          // 隐藏加载 spinner
      });
  ```

- Rest/Spread 属性：将对象的剩余属性收集到一个新对象中（Rest），或将一个对象的可枚举属性展开到新对象中（Spread）。这是对数组 `...` 语法在对象上的扩展。

  ```js
  // 解构中的 Rest
  const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
  console.log(rest); // { c: 3, d: 4 }
  
  // 对象字面量中的 Spread
  const obj1 = { a: 1, b: 2 };
  const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }xxxxxxxxxx1 1js
  ```

- 正则表达式改进

  - 命名捕获组 (`?<name>`): 为捕获组命名，便于引用。
  - Unicode 转义序列 (`\p{...}`): 在正则中更方便地匹配 Unicode 字符。
  - `dotAll` 模式 (`s` 标志): 使 `.` 元字符也能匹配换行符。
  - 后行断言 (Lookbehind Assertions): `(?<=...)` (正向), `(?<!...)` (负向)。

#### 3.4 ES2019（ES10）

- `Array.prototype.flat()` 和 `Array.prototype.flatMap()`:

  - `flat(depth?)`: 将嵌套数组“拉平”。
  - `flatMap(callback)`: 先使用 `map` 映射，再对结果进行 `flat(1)`。

  ```js
  [1, [2, 3], [4, [5]]].flat(); // [1, 2, 3, 4, [5]]
  [1, [2, 3], [4, [5]]].flat(2); // [1, 2, 3, 4, 5]
  
  ["a b", "c d"].flatMap(str => str.split(" ")); // ["a", "b", "c", "d"]
  ```

- `Object.fromEntries(iterable)`：将键值对列表（如 `Object.entries()` 的返回值）转换回对象。是 `Object.entries()` 的逆操作。

  ```js
  const entries = [['a', 1], ['b', 2]];
  const obj = Object.fromEntries(entries); // { a: 1, b: 2 }
  ```

- `String.prototype.trimStart()` / `trimEnd()`：分别移除字符串开头或结尾的空白字符。`trimLeft`/`trimRight` 的标准化别名。

- 可选的 `catch` 绑定：如果 `catch` 块不需要错误对象，可以省略参数。

  ```js
  try {
      // ...
  } catch { // 不需要 e
      console.log('An error occurred');
  }
  ```

- `Symbol.prototype.description`：获取 Symbol 的描述字符串（只读）。

  ```js
  const sym = Symbol('description');
  console.log(sym.description); // 'description'
  ```

#### 3.5 ES2020（ES11）

- `BigInt`：一种新的数字类型，可以表示任意精度的整数，解决了 `Number` 类型在处理极大整数时的精度问题。

  ```js
  const bigInt = 1234567890123456789012345678901234567890n;
  ```

- `Promise.allSettled(promises)`：等待所有 Promise 都“完成”（无论 fulfilled 还是 rejected），返回一个包含每个 Promise 结果（状态和值/原因）的数组。

  ```js
  Promise.allSettled([promise1, promise2])
      .then(results => {
          results.forEach((result, index) => {
              if (result.status === 'fulfilled') {
                  console.log(`Promise ${index} succeeded with:`, result.value);
              } else {
                  console.log(`Promise ${index} failed with:`, result.reason);
              }
          });
      });
  ```

- `globalThis`：提供了一个统一的全局对象引用，无论在浏览器 (`window`)、Node.js (`global`) 还是 Web Workers (`self`) 中。

  ```js
  console.log(globalThis); // 在任何环境中都指向全局对象
  ```

- 空值合并运算符 (`??`)：只有当左侧操作数是 `null` 或 `undefined` 时，才返回右侧操作数。与 `||` 不同，`||` 会在左侧为“假值”（如 `0`, `''`, `false`）时返回右侧。

  ```js
  const value = null ?? 'default'; // 'default'
  const count = 0 ?? 10; // 0 (因为 0 不是 null/undefined)
  const countOr = 0 || 10; // 10 (因为 0 是假值)
  ```

- 可选链 (`?.`)：一种安全访问嵌套对象属性的方式。如果访问的路径中某个属性不存在（`null` 或 `undefined`），则整个表达式短路返回 `undefined`，而不会抛出错误。

  ```js
  const street = user?.address?.street; // 如果 user 或 address 为 null/undefined，则 street 为 undefined
  const result = someFunction?.(); // 安全调用函数
  const value = arr?.[index]; // 安全访问数组元素
  ```

- 动态 `import()`：返回一个 Promise 的函数，用于动态加载 ES 模块。常用于代码分割和按需加载。

  ```js
  button.addEventListener('click', async () => {
      const module = await import('./module.js');
      module.doSomething();
  });
  ```

- `String.prototype.matchAll()`：返回一个迭代器，包含正则表达式匹配的所有结果（包括捕获组）。

#### 3.6 ES2021（ES12）

- 逻辑赋值运算符 (`&&=`, `||=`, `??=`)：结合了逻辑运算符和赋值操作。

  ```js
  a ||= b; // 等价于 a || (a = b)
  a &&= b; // 等价于 a && (a = b)
  a ??= b; // 等价于 a ?? (a = b)
  ```

- `String.prototype.replaceAll(searchValue, replaceValue)`：替换所有匹配项。`str.replace(/.../g, ...)` 的更直观替代。

- `Promise.any(promises)`：返回一个 Promise，一旦列表中的某个 Promise fulfilled，就 fulfilled；只有当所有 Promise 都 rejected 时才 rejected。

- `WeakRef` 和 `FinalizationRegistry`：提供了对对象的弱引用和对象被垃圾回收时的清理回调。**使用需谨慎**，通常用于高级优化或特定场景。

#### 3.7 ES2022（ES13）

- 顶级 `await` (Top-level `await`)：允许在模块的顶层直接使用 `await`，而无需包裹在 `async` 函数中。这简化了模块的初始化逻辑。

  ```js
  // 在模块顶层
  const response = await fetch('/api/config');
  const config = await response.json();
  export { config };
  ```

- `at()` 方法：为 `Array`, `String`, `TypedArray` 提供了 `at(index)` 方法，支持负索引（`-1` 表示最后一个元素）。

  ```js
  [1, 2, 3].at(-1); // 3
  ```

- `Object.hasOwn(obj, prop)`：`Object.prototype.hasOwnProperty()` 的更安全、更推荐的替代品。

- 类特性 (Class Features)

  - **公有实例字段**: `class C { field = value; }`
  - **私有实例字段**: `class C { #privateField = value; }`
  - **私有实例方法**: `class C { #privateMethod() { ... } }`
  - **静态 `public`/`private` 字段和方法**: `static field = value;`, `static #privateStaticField = value;`

- 正则表达式匹配索引 (`d` 标志)：在匹配结果中包含匹配项的开始和结束索引。
