- ==组件名首字母必须大写==
- 虚拟DOM元素只能有一个根元素
- 虚拟DOM元素必须有结束标签



### 1. 函数式组件

---

>创建纯展示组件，只负责根据传入的props来展示，不涉及到state状态的操作，是一个只带有一个`render`方法的组件类。
>
>- 组件==不会被实例化==，整体渲染性能得到提升；
>- 组件==不能访问this对象==；
>- 组件==无法访问生命周期的方法==；
>- 无状态的组件只能访问输入的props。

```react
//1.创建函数式组件
function MyComponent(){
  console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式
  return <h2>我是用函数定义的组件(适用于【简单组件】的定义)</h2>
}

//2.渲染组件到页面
ReactDOM.render(<MyComponent/>,document.getElementById('test'))
```

1. React解析组件标签，找到了MyComponent组件。
2. 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。



### 2. 类示组件（推荐）

---

>React.Component是以ES6的形式来创建react组件的，有状态组件。

```react
<script type="text/babel">

  class MyComponent extends React.Component {
    render(){
      //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。
      //render中的this是谁？—— MyComponent的实例对象 <=> MyComponent组件实例对象。
      console.log('render中的this:',this);
      return <h2>我是用类定义的组件(适用于【复杂组件】的定义)</h2>
    }
  }

  ReactDOM.render(<MyComponent/>,document.getElementById('test'))
</script>
```

>渲染类组件标签的基本流程：
>
>1. React内部会==创建组件实例对象==（new MyComponent）；
>2. 调用render()得到虚拟DOM，并解析为真实DOM；
>3. 插入到指定的页面元素内部。



### 3. 组件实例三大属性

---

#### 3.1 state

---

>- state是组件对象最重要的属性，值是对象。
>- 组件被称为状态机，==通过更新组件的state来更新对应的页面显示==（重新渲染组件）。
>
>```react
>state = {
>  isHot: false,
>  wind: '微风'
>}
>```
>
>1. 组件中render方法中的==this为组件实例对象==。
>2. 组件自定义的方法中this为undefined，
>
>```react
><script type="text/babel">
>  //1.创建组件
>  class Weather extends React.Component{
>
>    //构造器调用 ———— 1次
>    constructor(props){
>      super(props)
>      //初始化状态
>      this.state = {isHot:false,wind:'微风'}
>      //解决changeWeather中this指向问题
>      this.changeWeather = this.changeWeather.bind(this)
>    }
>
>    //render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
>    render(){
>      //读取状态
>      const {isHot,wind} = this.state
>      return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
>    }
>
>    //changeWeather ———— 点几次调几次
>    changeWeather(){
>      //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
>      //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
>      //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
>
>      console.log('changeWeather');
>      //获取原来的isHot值
>      const isHot = this.state.isHot
>      //严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
>      this.setState({isHot:!isHot})
>      console.log(this);
>
>      //严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
>      //this.state.isHot = !isHot //这是错误的写法
>    }
>  }
>  //2.渲染组件到页面
>  ReactDOM.render(<Weather/>,document.getElementById('test'))
>
></script>
>```



























































