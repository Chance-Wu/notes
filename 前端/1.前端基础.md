<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gknlx6acxuj316y09qq3d.jpg" style="zoom:60%">

#### 1. ES6新特性

> ECMAScript6.0，ES6是浏览器脚本语言的规范，JavaScript则是规范的具体实现。

##### 1.1 let声明变量

> - var 声明的变量往往会越域
> - let 声明的变量有严格局部作用域

```html
<script>
    {
    var a = 1;
    let b = 2;
}
console.log(a);
console.log(b);

</script>
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gknxunjinhj30i6036745.jpg" style="zoom:60%">

> var 同一个变量可以声明多次
>
> let 只能声明一次

```html
<script>
    var m = 1
    var m = 2
    let n = 3
    let n = 4
    console.log(m) // 2
    console.log(n) // Identifier 'n' has already been declared
</script>
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gknyfza8phj30qi014a9x.jpg" style="zoom:60%">

> var 会变量提升
>
> let 不存在变量提升

```html
<script>
    console.log(x);
    var x = 10;
    console.log(y);
    let y = 20;
</srcipt>
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkohfotspqj30ro034dfr.jpg" style="zoom:60%">

##### 1.2 const声明变量（只读变量）

> 声明之后，不允许改变
>
> 一旦声明必须初始化，否则会报错

```html
<script>
    const a = 1;
    a = 3;
</script>
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkoo98fur9j30mk022746.jpg" style="zoom:60%">

##### 1.3 结构表达式

>数组解构：const []

```html
<script>
    let arr = [1,2,3];
    
    let [a,b,c] = arr;

    console.log(a,b,c)
</script>
```

> 对象解构：const {}

```html
<script>
    // 对象解构
    const person = {
        name: "jack",
        age: 21,
        language: ["java","js","css"]
    }
    // const name = person.name;
    // const age = person.age;
    // const language = person.language;
    const {name:a,age:b,language:c} = person;
    console.log(a,b,c);
</script>
```

##### 1.4 字符串扩展

> 几个新的API

```html
<script>
    let str = "hello.vue";
    console.log(str.startsWith("hello"));
    console.log(str.endsWith(".vue"));
    console.log(str.includes("e"));
    console.log(str.includes("hello"));
</script>
```

> 字符串模板：使用``定义字符串模板。

```html
<script>
    // 字符串模板
    let ss = `<div>
            	<span>hello world</span>
            </div>`;
    console.log(ss);
</script>
```

> 字符串中调用函数：字符串插入变量和表达式，变量名写在 `${}` 中，`${}` 中可以放入JavaScript表达式。

```html
<script>
    function fun() {
    return "这是一个函数"
	}
	let sss = `O(n_n)O哈哈~，${fun()}`;
	console.log(sss);
	let a = "chance";
    let ssss =`我是${a}`;
    console.log(ssss);
</script>
```

##### 1.5 函数优化

> 给函数参数设置默认值，调用函数时不传值，则使用默认值。

```html
<script>
    function add2(a = 20, b = 1) {
        return a + b;
    }
    console.log(add2());
</script>
```

> 不定参数

```html
<script>// 设置不定参数
    function fun(...values) {
    	console.log(values.length);
	}
	fun(1, 2)
	fun(1, 2, 3, 4)
</script>
```

> 箭头函数：函数参数 => 方法体，==箭头函数，this不能使用，必须使用对象.属性==

```html
<script>
    // 一个参数
    var print = obj => console.log(obj);
    print(100);
	// 两个参数
	var sum = (a, b) => console.log(a + b);
    sum(1, 2);
</script>
```

> 实战：箭头函数结合结构表达式。

```html
<script>    
    const person = {
        name: "jack",
        age: 18,
        languge: ["java", "js", "css"]
    }

	var hello = ({name}) => console.log("hello", name);
	hello(person);
</script>
```

##### 1.6 对象优化

> 新增API：ES6给Object拓展了许多新的方法，如：
>
> - keys(obj)：获取对象的所有key形成的数组
> - values(obj)：获取对象的所有value形成的数组
> - entries(obj)：获取对象的所有key和value形成的二维数组。
> - assign(dest,...src)：将多个src对象的值 拷贝到 dest中。（第一层为深拷贝，第二层为浅拷贝）

```html
<script>
    const person = {
        name: "jack",
        age: 18,
        language: ["java", "js", "css"]
    }
	console.log(Object.keys(person));
	console.log(Object.values(person));
	console.log(Object.entries(person));

	// 将source1，sources2的属性合并到target对象中
	const target = { a: 1 };
    const source1 = { b: 2 };
    const source2 = { c: 3 };
    Object.assign(target, source1, source2);
    console.log(target);
</script>
```

> 声明对象简写：ES6属性名和属性值变量名一样，可以省略

```html
<script>
	const age = 23;
    const name = "zhangsan";
    const person2 = { age, name };
    console.log(person2);    
</script>
```

> 对象的函数属性简写

```html
<script>
	let person3 = {
        name: "jack",
        eat: function (food) {
            console.log(this.name + "在吃" + food);
        },
        eat2: food => console.log(person3.name + "在吃" + food),
        eat3(food) {
        	console.log(this.name + "在吃" + food);
        }
    }
	person3.eat("香蕉");

	person3.eat2("苹果");
	
	person3.eat3("葡萄");
</script>
```

> 对象的扩展运算符：(...)用于取出参数对象所有可遍历属性然后拷贝到当前对象。

```html
<script>
	// 拷贝对象（深拷贝）
    let person1 = { name: "Amy", age: 15 };
    let someone = { ...person1 };
    console.log(someone);
	
	// 合并对象
	let age = { age: 15 };
    let name = { name: "Amy" };
    // 如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值
    let person4 = { name: "zhangsan" };
    person4 = { ...age, ...name };
    console.log(person4);
</script>
```

##### 1.7 数组中新增map和reduce方法

> map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。

```html
<script>
    let arr = ['1', '20', '-5', '3'];
    arr = arr.map(item => item * 2)
    console.log(arr);
</script>
```

> reduce()：为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素
>
> - previousValue  表示上一次调用时的返回值， 或者初始值init
> - currentValue  表示当前正在处理的数组元素
> - index 表示当前正在处理的数组元素的索引，若提供init值，则索引为0，否则索引为1
> - array  表示初始值

```html
<script>
	let result = arr.reduce((a, b) => {
        console.log("上次处理后：" + a);
        console.log("当前正在处理：" + b);
        return a + b;
    }, 100);
	console.log(result);
</script>
```

##### 1.8 Promise对象

> Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
>
> Promise，简单说就是*<u>一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</u>*。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

> 特点：
>
> 1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：
>
>    - `Pending`（进行中）
>    - `Resolved`（已完成，又称Fulfilled）
>    - `Rejected`（已失败）。
>
>    只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
>
> 2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`Pending`变为`Resolved`和从`Pending`变为`Rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
>
> 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。
>
> Promise的缺点：
>
> - 首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。
> - 其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
> - 第三，当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
>
> 如果某些事件不断地反复发生，一般来说，使用`stream模式`是比部署`Promise`更好的选择。

> 基本用法：
>
> ES6规定，Promise对象是一个构造函数，用来生成Promise实例。
>
> *<u>Promise作为构造函数接受一个函数作为参数</u>*，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由JavaScript引擎提供，不用自己部署。
>
> - `resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
> - `reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
>
> Promise实例生成以后，可以用then方法分别制定Resolved状态和Reject状态的回调函数。
>
> then方法可以接受两个回调函数作为参数。第一个回调函数式Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数式可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

> Promise简单例子：
>
> ```html
> <script>
>     // 嵌套查询，乱，不工整
>     // 1.查出当前用户信息
>     // 2.按照当前用户的id查出他的课程
>     // 3.按照当前课程id查出分数
>     // $.ajax({
>     //     url: "mock/user.json",
>     //     success(data) {
>     //         console.log("查询用户：", data);
>     //         $.ajax({
>     //             url: `mock/user_corse_${data.id}.json`,
>     //             success(data) {
>     //                 console.log("查询到课程：", data);
>     //                 $.ajax({
>     //                     url: `mock/corse_score_${data.id}.json`,
>     //                     success(data) {
>     //                         console.log("查询到分数：", data);
>     //                     },
>     //                     error(error) {
>     //                         console.log("出现异常了：" + error);
>     //                     }
>     //                 });
>     //             },
>     //             error(error) {
>     //                 console.log("出现异常了：" + error);
>     //             }
>     //         });
>     //     },
>     //     error(error) {
>     //         console.log("出现异常了：" + error);
>     //     }
>     // });
> 
>     // 1.Promise可以封装异步操作
>     let p = new Promise((resolve, reject) => {
>         // 1.异步操作
>         $.ajax({
>             url: `mock/user.json`,
>             success: function (data) {
>                 console.log("查询用户成功：", data);
>                 resolve(data);
>             },
>             error: function (err) {
>                 reject(err);
>             }
>         });
>     });
> 
>     p.then((data) => {
>         return new Promise((resolve, reject) => {
>             // 继续异步操作
>             $.ajax({
>                 url: `mock/user_corse_${data.id}.json`,
>                 success: function (data) {
>                     console.log("查询用户课程成功：", data);
>                     resolve(data);
>                 },
>                 error: function (err) {
>                     reject(err);
>                 }
>             });
>         })
>     }).then((data) => {
>         console.log("上一步的结果", data);
>         $.ajax({
>             url: `mock/corse_score_${data.id}.json`,
>             success: function (data) {
>                 console.log("查询课程分数成功：", data);
>             },
>             error: function (err) {
>                 console.log("查询课程分数失败：", err);
>             }
>         });
>     });
> 
> </script>
> ```

> 上述例子可以简化：
>
> 抽取出一个方法
>
> ```html
> <script>
> 	// 抽取出请求方法
>     function get(url, data) {
>         return new Promise((resolve, reject) => {
>             $.ajax({
>                 url: url,
>                 data: data,
>                 success: function (data) {
>                     resolve(data);
>                 },
>                 error: function (err) {
>                     reject(err);
>                 }
>             })
>         });
>     }
> 
>     get("mock/user.json")
>         .then((data) => {
>         console.log("用户查询成功：", data);
>         return get(`mock/user_corse_${data.id}.json`);
>     })
>         .then((data) => {
>         console.log("课程查询成功：", data);
>         return get(`mock/corse_score_${data.id}.json`);
>     })
>         .then((data) => {
>         console.log("课程成绩查询成功：", data);
>     })
>         .catch((err) => {
>         console.log(err);
>     });
> </script>
> ```

##### 1.9 模块化

> 模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。而JS中没有包的概念，换来的是模块。

> ES6是通过export命令显示指定输出的代码，再通过import命令输入。
>
> `import { stat, exists, readFile } from 'fs'`
>
> 上述代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“==编译时加载/静态加载==”，即ES6可以在编译时就完成模块加载，效率要比CommonsJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。

> **export：用于规定模块的对外接口**
>
> 不仅可以导出对象，一切JS变量都可以导出。比如：基本类型、函数、数组、对象。
>
> *hello.js*
>
> ```js
> // 为模块指定默认输出
> export default {
>     sum(a, b) {
>         return a + b;
>     }
> }
> ```
>
> *main.js*输入hello.js提供的功能，此时名字可以随便起，比如“abc”
>
> ```js
> import abc from "./hello.js"
> ```



