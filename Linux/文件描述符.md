>文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指向被打开的文件，所有执行I/O操作的系统调用都通过文件描述符；文件描述符是一个简单的非负整数，用以表明每个被进程打开的文件。

[Linux 中一切皆文件](http://c.biancheng.net/view/2852.html)，比如 C++源文件、视频文件、Shell脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。

一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，**Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为文件描述符（File Descriptor）**。

阅读本篇文章需要有C语言编程基础，至少要理解数组、指针和结构体；如果理解内存，那就更好了。

#### Linux 文件描述符是什么

---

**一个 Linux 进程启动后，会在内核空间中创建一个 PCB （Process Control Block）控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件**。

>内核空间是虚拟地址空间的一部分，参考《[C语言内存精讲](http://c.biancheng.net/c/140/)》，可以简单理解为：进程启动后要占用内存，其中一部分内存分配给了文件描述符表。

除了文件描述符表，系统还需要维护另外两张表：

- 打开文件表（Open file table）
- i-node表（i-node table）

==文件描述符表每个进程都有一个，打开文件表和i-node表整个系统只有一个==，三者关系如下：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzodbmgeqmj20mb0d674t.jpg)

从本质上讲，这三种表都是结构体数组，0、1、2、73、1976等都是数组下标。表头只是自己添加的注释，数组本身是没有的。实线箭头表示指针的指向。

通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：

- 文件偏移量，也就是文件内部指针偏移量。调用read()或者write()函数时，文件偏移量会自动更新，当然也可以使用lseek()直接修改。
- 状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。
- i-node 表指针。

要想真正读写文件，还得通过打开文件表的 i-node 指针进入 i-node 表，该表包含了诸如以下的信息：

- 文件类型，例如常规文件、套接字或 FIFO。
- 文件大小。
- 时间戳，比如创建时间、更新时间。
- 文件锁

对上图的进一步说明：

- 在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。
- 进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。
- 进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 

#### lsof 简介

---

lsof（list open files）是一个**列出当前系统打开文件**的工具。在Linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。无论文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表，对系统监测以及排错将是很有帮助的。

>lsof常用参数
>
>lsof filename 显示打开指定文件的所有进程
>
>lsof -a 表示两个参数都必须满足时才显示结果 
>
>lsof -c string 显示COMMAND列中包含指定字符的进程所有打开的文件 
>
>lsof -u username 显示所属user进程打开的文件 
>
>lsof -g gid 显示归属gid的进程情况 
>
>lsof +d /DIR/ 显示目录下被进程打开的文件 
>
>lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长 
>
>lsof -d FD 显示指定文件描述符的进程 
>
>lsof -n 不将IP转换为hostname，缺省是不加上-n参数 
>
>lsof -i 用以显示符合条件的进程情况 

#### Linux标准文件描述符

---

| 名称                 | 代码 | 操作符          | Linux下文件描述符（Debian为例） | Java中表示                                   |
| -------------------- | ---- | --------------- | ------------------------------- | -------------------------------------------- |
| 标准输入(stdin)      |      | < 或 <<         | System.in                       | /dev/stdin -> /proc/self/fd/0 -> /dev/pts/0  |
| 标准输出(stdout)     | 1    | >,>>,1>  或 1>> | System.out                      | /dev/stdout -> /proc/self/fd/1 -> /dev/pts/0 |
| 标准错误输出(stderr) | 2    | 2> 或 2>>       | System.err                      | /dev/stderr -> /proc/self/fd/2 -> /dev/pts/0 |

其实与计算机之间的交互是我可以输入一些指令之后它给我一些输出。那么我们可以把上面表格中的文件描述符0理解为我和计算机交互时的输入，而这个输入默认是指向键盘的；文件描述符1理解为我和计算机交互时的输出，而这个输出默认是指向显示器的；文件描述符2理解为我和计算机交互时，计算机出现错误时的输出，而这个输出默认是和文件描述符1指向一个位置。

#### 输入/输出重定向

---

| 命令               | 说明                                                   |
| :----------------- | :----------------------------------------------------- |
| ==command > file== | ==将输出重定向到 file。==                              |
| command < file     | 将输入重定向到 file。                                  |
| command >> file    | 将输出以追加的方式重定向到 file。                      |
| ==n > file==       | ==将文件描述符为 n 的文件重定向到 file。==             |
| n >> file          | 将文件描述符为 n 的文件以追加的方式重定向到 file。     |
| ==n >& m==         | ==将输出文件 m 和 n 合并。==                           |
| n <& m             | 将输入文件 m 和 n 合并。                               |
| ==<< tag==         | ==将开始标记 tag 和结束标记 tag 之间的内容作为输入。== |

##### Here Document

Here Document 是shell中的一种特殊的重定向方式，用来将输入重定向到一个交互式Shell脚本或程序。

基本形式如下：

```sh
command << delimiter
    document
delimiter
```

将两个 **delimiter** 之间的内容作为输入传递给command。

在命令行中通过 `wc -l` 命令计算Here Document的行数：

```sh
$ wc -l << EOF
heredoc>A
heredoc>B
heredoc>EOF
								2
```

可以将Here Document用在脚本中，如下：

```sh
#!/bin/bash

cat << EOF
www.runoob.com
EOF
```

执行以上脚本，输出结果：

www.runoob.com

##### /dev/null 文件

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

```sh
$ command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```sh
$ command > /dev/null 2>&1
```

##### 2>&1 的含义

将标准错误输出重定向到标准输出。

```sh
nohup java -jar app.jar >log 2>&1 &
```

上述命令表示将标准错误输出和标准输出都定向到log中。

>**>start.log 2>&1**简写如下：
>
>- **&>start.log**

#### 查看一个进程打开了哪些文件

---

>语法：`ll /proc/[进程ID]/fd`

```sh
$ vim a.txt  
 
[1]+  已停止               vim a.txt 
[xf@xuexi ~]$ ps -aux | grep vim 
xf        11990  0.6  0.2 151796  5396 pts/0    T    16:37   0:00 vim a.txt 
xf        11998  0.0  0.0 112724   988 pts/0    S+   16:37   0:00 grep --color=auto vim 
$ ll /proc/11990/fd 
总用量 0 
lrwx------. 1 xf xf 64 2月  21 16:37 0 -> /dev/pts/0 
lrwx------. 1 xf xf 64 2月  21 16:37 1 -> /dev/pts/0 
lrwx------. 1 xf xf 64 2月  21 16:37 2 -> /dev/pts/0 
lrwx------. 1 xf xf 64 2月  21 16:37 4 -> /home/xf/.a.txt.swp 
```

0、1、2也就是宏STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。

**/proc/[进程ID]/fd** 这个目录专门用于存放文件描述符。

另外还可以使用 `ls -l /proc/self/fd`

#### 文件描述符限制

---

Linux中最大文件描述符的限制有两个方面：

- 用户级限制
- 系统级限制

查看Linux文件描述符限制有三种方式：

- `sysctl -a | grep file-max`（系统级别限制）
- `cat /proc/sys/fs/file-max`（系统级别限制）
- `ulimit -n`（用户级限制）

##### 用户级限制

**ulimit** 命令看到的是用户级的最大文件描述符限制，也就是说每一个用户登录后执行的程序占用文件描述符的总数不能超过这个限制。

永久修改需要使用root用户编辑 `/etc/security/limits.conf`。修改文件描述符，应该注意 `<item>` 字段下是否存在nofile字段，如果存在请修改，不存在请添加。

```sh
vim /etc/security/limits.conf
* hard nofile 102400
* soft nofile 102400
```

##### 系统级限制

**sysctl** 命令与 **proc** 文件系统中查看到的数值是一样的，这属于系统级限制，它是限制所有用户打开文件描述符的总和。

修改系统限制级，不管是临时修改还是永久修改都需要使用root用户。

永久修改需要进入到 `/etc/sysctl.conf` 中，修改或添加 `fs.file-max=value`，然后重启系统或使用 `sysctl -p` 重新读取参数。

```sh
vim /etc/sysctl.conf
fs.file-max = 196630

sysctl -p
```













