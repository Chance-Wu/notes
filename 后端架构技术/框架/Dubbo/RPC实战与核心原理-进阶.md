### 一、架构设计：设计一个灵活的RPC框架

---

RPC 就是把拦截到的方法参数，转成可以在网络中传输的二进制，并保证在服务提供方能正确地还原出语义，最终实现像调用本地一样地调用远程的目的。

#### RPC架构设计

网络传输，保证可靠性——>TCP

1. **传输模块**，收发二进制数据，屏蔽网络传输的复杂性。

2. **协议模块**

   - 序列化过程: 用户请求基于方法调用，方法出入参数都是对象数据，对象在网络中传输需要转成二进制；
   - 协议封装: 在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，在两个“断句”符号中间放的内容就是请求的二进制数据；
   - 压缩功能: 在方法调用参数或者返回值的二进制数据大于某个阈值的情况下，通过压缩框架进行无损压缩，然后在另外一端也用同样的压缩算法进行解压，保证数据可还原；
   - 目的: 保证数据在网络中可以正确传输。

3. **Bootstrap模块**，屏蔽细节，让研发人员感觉不到本地调用和远程调用的区别。可以把一个 RPC 接口定义成一个 Spring Bean，并且这个 Bean 也会统一被 Spring Bean Factory 管理，可以在项目中通过 Spring 依赖注入到方式引用。

4. **集群模块**

   集群能力，就是针对同一个接口有着多个服务提供者，但这多个服务提供者对于调用方来说是透明的，所以在 RPC 里面还需要给调用方找到所有的服务提供方，并需要在 RPC 里面维护好接口跟服务提供者地址的关系，这样调用方在发起请求的时候才能快速地找到对应的接收地址，这就是“**服务发现**”。

   但服务发现只是解决了接口和服务提供方地址映射关系的查找问题，这更多是一种“静态数据”。说它是静态数据是因为，对于 RPC 来说，每次发送请求的时候都是需要用 TCP 连接的，相对服务提供方 IP 地址，**TCP 连接状态是瞬息万变的**，所以 RPC 框架里面要有**连接管理器**去维护 TCP 连接的状态。

   有了集群之后，提供方可能就需要管理好这些服务了，那 RPC 就需要内置一些**服务治理**的功能，比如服务提供方权重的设置、调用授权等一些常规治理手段。而服务调用方在每次调用前，都需要根据服务提供方设置的规则，从集群中选择可用的连接用于发送请求。

四层RPC框架

![在这里插入图片描述](RPC%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA546L6IOW5rO9,size_20,color_FFFFFF,t_70,g_se,x_16.png)

#### 可扩展的架构-插件化架构

将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。
在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机制，它可以==动态地为某个接口寻找服务实现==。使用 SPI 机制需要在 Classpath 下的 `META-INF/services` 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。

在实际项目中，其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载，==ServiceLoader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费==。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。

加上插件功能后, 包含核心功能体系与插件体系的RPC 框架：

![在这里插入图片描述](RPC%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA546L6IOW5rO9,size_20,color_FFFFFF,t_70,g_se,x_16-20220707103607256.png)

这时，整个架构就变成了一个微内核架构，将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离并提供接口的默认实现。

这样的架构相比之前的架构，有很多优势:

1. 首先它的可扩展性很好，实现了`开闭原则`，用户可以非常方便地通过插件扩展实现自己的功能，而且不需要修改核心功能的本身；
2. 其次就是保持了核心包的精简，`依赖外部包少`，这样可以有效减少开发人员引入 RPC 导致的包版本冲突问题。



### 二、服务发现：到底是CP还是AP

---



















































































































