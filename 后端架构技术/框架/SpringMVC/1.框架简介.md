>Spring的模型-视图-控制器（MVC）框架是围绕一个 `DispatcherServlet` 来设计的，这个Servlet会==把请求分发给各个处理器==，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。处理器是应用中注解了 `@Controller` 和 `@RequestMapping` 的类和方法。Spring 3.0以后提供了 @Controller 注解机制、 @PathVariable 注解以及一些其他的特性。

>“对扩展开放”是Spring Web MVC框架一个重要的设计原则，而对于Spring的整个完整框 架来说，其设计原则则是“对扩展开放，对修改闭合”。 
>
>理解AOP代理一节，其中解释了AOP代理的相关知识，论述了为什么你不能对 final 方法进行增强。

>1. 在Spring MVC中，==可以使用任何对象来作为命令对象或表单返回对象==。Spring的数据绑定非常灵活：比如，它会把数据类型不匹配当成可由应用自行处理的运行时验证错误，而非系统错误。你可能会为了避免非法的类型转换在表单对象中使用字符串来存储数据，但无类型的字符串无法描述业务数据的真正含义，并且你还需要把它们转换成对应的业务对象类型。有了Spring的验证机制，意味着你再也不需这么做了，并且直接将业务对象绑定到表单对象上通常是更好的选择。 
>
>2. Spring的视图解析也是设计得异常灵活。==控制器一般负责准备一个 Map 模型、填充数据、返回一个合适的视图名等，同时它也可以直接将数据写到响应流中==。视图名的解析高度灵活，支持多种配置，包括通过文件扩展名、Accept 内容头、bean、配置文件等的配置，甚至你还可以自己实现一个视图解析器 ViewResolver 。
>
>3. 模型（MVC中的M）其实是==一个 Map 类型的接口==，彻底地把数据从视图技术中抽象分离了出来。你可以与基于模板的渲染技术直接整合，如JSP、Velocity和Freemarker等，或者你还可以直接生成XML、JSON、Atom以及其他多种类型的内容。 Map 模型会简单地被转换成合适的格式，比如JSP的请求属性（attribute），一个Velocity模板的模型等。 

#### 1. 新特性

>Spring的web模块支持许多web相关的特性：
>
>- 清晰的职责分离。每个角色——控制器，验证器，命令对象，表单对象，模型对象， DispatcherServlet ，处理器映射，视图解析器，等等许多——的工作，都可以由相应的对象来完成。
>- 强大、直观的框架和应用bean的配置。这种配置能力包括能够从不同的上下文中进行简单的引用，比如在web控制器中引用业务对象、验证器等。
>- 强大的适配能力、非侵入性和灵活性。Spring MVC支持你定义任意的控制器方法签名，在特定的场景下你还可以添加适合的注解（比如 @RequestParam 、 @RequestHeader 、 @PathVariable 等）
>- 可复用的业务代码，使你远离重复代码。你可以使用已有的业务对象作为命令对象或表单对象，而不需让它们去继承一个框架提供的什么基类。
>- 可定制的数据绑定和验证。类型不匹配仅被认为是应用级别的验证错误，错误值、本地化日期、数字绑定等会被保存。你不需要再在表单对象使用全String字段，然后再手动将它们转换成业务对象。
>- 可定制的处理器映射和视图解析。处理器映射和视图解析策略从简单的基于URL配置，到精细专用的解析策略，Spring全都支持。在这一点上，Spring比一些依赖于特定技术的 web框架要更加灵活。
>- 灵活的模型传递。Spring使用一个名称/值对的Map来做模型，这使得模型很容易集成、传递给任何类型的视图技术。
>- 可定制的本地化信息、时区和主题解析。支持用/不用Spring标签库的JSP技术，支持JSTL，支持无需额外配置的Velocity模板，等等。
>- 一个简单但功能强大的JSP标签库，通常称为Spring标签库，它提供了诸如数据绑定、主题支持等一些特性的支持。这些定制的标签为标记（markup）你的代码提供了最大程度的灵活性。
>- 一个Spring 2.0开始引入的JSP表单标签库。它让你在JSP页面中编写表单简单许多。
>- 新增生命周期仅绑定到当前HTTP请求或HTTP会话的Bean类型。严格来说，这不是 Spring MVC自身的特性，而是Spring MVC使用的上下文容器 WebApplicationContext 所提供的特性。

#### 2. 允许其他MVC实现

>有些项目可能更倾向于使用非Spring的MVC框架。 许多团队希望仍然使用现有的技术栈，比如JSF等。 
>
>如果你确实不想使用Spring的Web MVC，但又希望能从Spring提供的一些解决方案中受益，那么将你所使用的框架和Spring进行集成也很容易。只需要==在 ContextLoaderListener 中启动一个Spring的根应用上下文（root application context），然后你就可以在任何action对象中通过其 ServletContext 属性（或通过Spring对应的helper方法）取得==。从应用层的视角来看，你只是将Spring当成依赖库使用，并且将它的根应用上下文实例作为应用进入点。 
>
>即使不用Spring的Web MVC框架，你配置的其他Spring的bean和服务也都能很方便地取得。在这种场景下，Spring与其他web框架的使用不冲突。Spring只是在许多问题上提出了其他纯 web MVC框架未曾提出过的解决方案，比如**bean的配置**、**数据存取**、**事务处理**等，仅此而已。因此，如果你只是想使用Spring的一部分特性来增强你的应用，比如Spring提供的 JDBC/Hibernate事务抽象等，那么你可以将Spring作为一个中间层和/或数据存取层来使用。

