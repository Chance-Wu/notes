#### 1. 什么是Hash

>散列/hash，==把任意长度的输入(预映射pre-image)通过散列算法变换成固定长度的输出==，该输出就是散列值。

#### 2. 什么是Hash表

>哈希表（散列表），是基于关键码值(Key value)而直接进行访问的数据结构。也就是说，它==通过把关键码值映射到表中一个位置来访问记录==，以加快查找的速度。这个映射函数叫做散列函数（哈希函数），存放记录的数组叫做散列表。

#### 3. 哈希函数与哈希表

>- hash函数并没有统一标准，它的核心思想就是把任意长度的而输入(pre-image)通过散列散发变换成固定长度的输出。
>- 这种转换是一种压缩映射，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，这个消息可能是字符、数组、字符串等等。
>- 在使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，这样就充分==利用到数组的定位性能进行数据定位==。
>- 拥有这样的hash存储结构的数据结构称为散列表，或者叫哈希表。
>- ==哈希表一般基于数组实现==，特定情况下结合链表，但是数组是哈希表基础数据结构。

#### 4. 哈希表的优势

>- 数组的特点是：寻址容易，插入和删除困难；
>- 链表的特点是：寻址困难，插入和删除容易。
>
>那么能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法.

#### 5. 哈希算法

>首先明确什么是”好“的哈希算法。若对于关键字集合中的任意个关键字，经哈希函数映射到地址集合中任何一个地址的概率是相等的，则称为`均匀的哈希函数`。即使关键字经过哈希函数得到一个”随机地址“，以便使一组关键字的哈希地址均匀分布在整个地址区间中，从而减少冲突。

>一个hash函数需要满足：
>
>1. 接受一个单一的参数（任何类型）。
>2. 返回一个整型值（一般情况下）。
>3. 输出的==哈希地址均匀分布在整个地址区间中==。
>4. 对于两个相同的输入，输出必须相同。
>5. 对于两个不同的输入，输出相同的概率需要做到非常小。
>6. hash的计算不能过于复杂，时间复杂度尽可能地低。

##### 5.1 直接寻址方法

>==取key的线性函数值作为hash值==，`value = a * key + b`（a,b为常数）。这一类散列码的特点是：对输入为整型数据而言，不会产生下标冲突。不产生冲突当然是最完美的状态，但是这种方式要求输入的key遵循一定的线性规律。

>例如：有一个01到07的部门人数统计表，其中，部门编号作为关键字，哈希函数取关键字自身。如下表所示：
>
>地址01、02、03、04、05、06、07
>
>部门01、02、03、04、05、06、07
>
>人数23、43、24、65、64、33、46
>
>这样要询问01部门有多少人，则只要查表的第01项即可。由于==直接定址所得的地址集合和关键字集合的大小相同==。因此，对于不同的关键字不会发生冲突，但是实际中能使用这种哈希函数的情况很少。

##### 5.2 除留余数法

>假设数组的长度为l，`value = key % l`，这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数，被除数为质数在一定程度上可以缓解数据堆积的问题。

>对于散列表长为m的散列函数公式为： `f( key ) = key mod p ( p ≤ m )`
>
>mod是取模（求余数）。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。显然在这里选取p的值至为关键，那么选取p值多少为合适呢？
>
>下面我们来举个例子看看：有一个关键字，它有7个记录。如果采用除留余数法，那么可以先尝试将散列函数设计为f(key) = key mod 7的方法。比如12 mod 7= 5，所以它存储在下标为5的位置。
>
>地址：0、1、2、3、4、5、6
>
>关键字：7、22、9、17、11、12、48
>
>不过也存在冲突的可能，如：7、14、21、28、35......这些获得的下标都为0。

>如何选取p值？
>
>若散列表长为m，通常==p为小于或等于表长的最小质数==或==不包含小于20质因子的数==。若散列表长度为100，散列函数为k%p，则p选97。

##### 5.3 数字分析法

>数字分析法即对关键字进行分析，==取关键字的若干位进行或者组合进行hash计算==，这一类散列码的特点是比较灵活，通常是结合其他hash函数来计算，可根据实际情况来做出调整，具有想当的灵活性。

>有学生的生日数据如下：
>
>学生序号：0、1、2、3、4、5
>
>学生生日：1975.10.03、1975.11.23、1975.03.02、1975.07.12、1975.04.21、1975.02.15
>
>经分析，第一位，第二位，第三位，第四位重复的可能性大，取前四位造成冲突的机会增加，所以尽量不取前四位，取后四位比较好。

##### 5.4 随机数法

>选择一个随机函数，==取关键字的随机函数值为它的哈希地址==，即H(key)=random(key)，其中random为随机函数。通常，当关键字长度不等时采用此构造函数较恰当。

##### 5.5 平方取中法

>==取关键字平方后中间几位作哈希地址==。适于关键字长度不统一的情况，而且对于元素连续的输入，可以很好的将其散列均匀，而且相对于除法而言，乘法的执行速度更快，这个由硬件决定。

##### 5.6 折叠法

>==将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址==。

#### 6. 处理哈希冲突的方法

>基本原则：从hash函数的要求可以看到，事实上我们只能定义对于两个不同的输入，输出相同的概率尽可能小。

##### 6.1 开放地址法

>基本思想：当发生冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。可用以下公式描述：
>
>`H i ( key ) = ( H ( key )+ d i ) mod m ( i = 1,2,…… ， k ( k ≤ m – 1)) `
>
>- H(key)：关键字key的直接哈希地址。
>- m：哈希表的长度。
>- di：为每次再探测时的地址增量。
>
>首先计算出==元素的直接哈希地址H(key)==，如果该存储单元已被其他元素占用，则继续查看==地址为H(key)+d2的存储单元==，如此重复直至找到某个存储单元为空时，将关键字为key的数据元素存放到该单元。
>
>增量d可以有不同的取法，并根据其取法有不同的称呼：
>
>1. di=1，2，3，......==线性探测再散列==
>2. di=1^2， -1^2， 2^2， -2^2， k^2， -k^2......==二次探测再散列==
>3. di=伪随机序列 ==伪随机再散列==

>假设有哈希函数 H ( key ) = key mod 7 ，哈希表的地址空间为 0 ～ 6 ，对关键字序列（ 32 ， 13 ， 49 ， 55 ， 22 ， 38 ， 21 ）按线性探测再散列和二次探测再散列的方法分别构造哈希表。
>解：
>（ 1 ）线性探测再散列：
>32 ％ 7 = 4 ； 13 ％ 7 = 6 ； 49 ％ 7 = 0 ；
>55 ％ 7 = 6 发生冲突，下一个存储地址（ 6 ＋ 1 ）％ 7 ＝ 0 ，仍然发生冲突，再下一个存储地址：（ 6 ＋ 2 ）％ 7 ＝ 1 未发生冲突，可以存入。
>22 ％ 7 ＝ 1 发生冲突，下一个存储地址是：（ 1 ＋ 1 ）％ 7 ＝ 2 未发生冲突；
>38 ％ 7 ＝ 3 ；
>21 ％ 7 ＝ 0 发生冲突，按照上面方法继续探测直至空间 5 ，不发生冲突，所得到的哈希表对应存储位置：
>下标： 0 1 2 3 4 5 6
>49 55 22 38 32 21 13
>（ 2 ）二次探测再散列：
>下标： 0 1 2 3 4 5 6
>49 22 21 38 32 55 13
>注意：对于利用开放地址法处理冲突所产生的哈希表中删除一个元素时需要谨慎，不能直接地删除，因为这样将会截断其他具有相同哈希地址的元素的查找地址，所以，通常采用设定一个特殊的标志以示该元素已被删除。

##### 6.2 链地址法

>如果哈希表空间为 0 ～ m - 1 ，设置一个由 m 个指针分量组成的一维数组 ST[ m ]，凡哈希地址为 i 的数据元素都插入到头指针为 ST[ i ] 的链表中。这种方法有点近似于邻接表的基本思想，且这种方法适合于冲突比较严重的情况。 
>
><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmhr0h253ij30jl070dfs.jpg" style="zoom:100%">

#### 7. 应用

##### 7.1 String中的hashCode()方法

> hash的默认值为0，对String当做一个数组，这个字符数组中的每个字符都转为int，加上h乘以31，即是hash值。从中可以看出，hash算法返回的是int型的数值。
>
> ```java
> /** 通过该数组来存储字符串 */
> private final char value[];
> private int hash; // Default to 0
> 
> public int hashCode() {
>     int h = hash;
>     // 如果hash值不等于0，且value.length > 0
>     if (h == 0 && value.length > 0) {
>         char val[] = value;
> 
>         for (int i = 0; i < value.length; i++) {
>             h = 31 * h + val[i];
>         }
>         hash = h;
>     }
>     return h;
> }
> ```
>
> 1. 如果 `hash == 0 && value.length > 0`，则进行哈希计算
> 2. 哈希算法`h = 31 * h + val[i];`，以31为因子，每一位字符的ASCII值进行运算，用自然溢出来等效取模。

##### 7.2 String类的hashCode()方法为什么要使用31作为因子

>`h = 31 * h + val[i]`
>
>1. 可以被编译器优化：`31 * h  =  (h<<5) - h`
>2. 是一个质数：==质数是只能被1和自身整除的数==，使用质数作为乘法因子获得的散列值，在将来进行取模时，得到相同index的概率会降低，即==降低了哈希冲突的概率==。
>3. 是一个不大不小的质数：质数太小容易造成散列值聚集在一个小区间，提供散列冲突概率；质数过大容易造成散列值超出int的取值范围（溢出），丢失部分数值信息，散列冲突概率不稳定。



(1) 选择数字31是因为它是一个奇质数，如果选择一个偶数，因为乘二相当于左移一位，可能会产生溢出，导致数值信息溢出。

(2) 这一点的优势并不明显，但这是一个传统（选择质数）。

(3) 同时，数字31有一个很好的特性，乘法运算可以被移位和减法运算来取代，来获取更好的性能，而且这一点可以由jvm来自动完成。

(4) 31*i=(i<<5)-i

- HashMap中hash值存在的目的是加速键值对的查找，key的作用是为了将元素适当的放在各个桶里，对于抗碰撞的要求没那么高。

- 对key的hash计算，就是计算出key的hash值，并移动到低位，完成高低位的融合。

 

#### Hash在密码学中的应用

> hash算法在密码学中主要用于消息摘要和签名。换句话说，主要是对整个消息的完整性进行校验。 

#### 解决碰撞的方法

通过构造性能良好的hash算法，可以减少冲突，但不能完全避免冲突。而且在创建hash表和查找hash表都有可能会遇到冲突。因为作为一种可用的hash算法，其位数一定是有限的，但是它所能记录的文件又是无限的。所以碰到碰撞的概率永远不会是零。

常见的解决方法主要有***\*开放寻址法\****，***\*再哈希法\****，***\*链地址法\****，***\*建立公共溢出区\****

- 开放寻址法

n 主要是通过key转出hash值h1，如果遇到冲突，那在h1的基础上，再次进行hash操作得到h2，直到不产生冲突为止。

- 再哈希法

n 主要是同时构造多个hash函数，当第一个hash函数计算出来的遇到冲突时，调用第二个hash函数计算出来的值。以此类推，直到不产生冲突为止。

- 链地址法

n 主要将所有hash值（比如都为i）相同的元素构成一个所谓同义词链的单链表，将单链表的头指针存放在hash表的第i个单元中。

- 建立公共溢出区

n 主要将hash表分为基本表和溢出表，凡是和基本表相冲突的，都放在溢出表中。 

#### 常见的Hash算法

主要的Hash实现主要有一下几类，其中MD5和SHA-1是应用最为广泛的Hash算法。

- MD4

n MD4是MIT的Rivest在1990年设计，MD是信息摘要Message Digest的缩写。它是基于32位操作数的位操作来实现的。

- MD5

n MD5是Rivest在1991年对MD4的改进，MD5比MD4来得复杂，因此速度慢一些，但安全性更好。

SHA-1

n SHA-1是由NIST NSA设计的，它对长度小于264位的输入，产生长度位160位的散列值。因此抗穷举性更好。SHA-1模仿了MD4的算法。

#### 总结

- 在java中array和list是两个极端，array查询快，但是添加删除操作慢；list添加删除快，但查询慢。

- HashMap折中了上面两点，Key的hash用数组，value用列表，如果value有碰撞，就是用链表依次存储。

