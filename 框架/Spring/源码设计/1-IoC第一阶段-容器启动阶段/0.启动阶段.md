启动Spring容器，本质上是创建并初始化一个具体的容器类的过程。以`ClassPathXmlApplicationContext`为例。

```java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");
```

上述代码已经创建并启动了一个IoC容器。



#### 容器启动流程

---

1. 首先调用了重载构造函数：

```java
public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
  this(new String[] {configLocation}, true, null);
}
```

>Spring容器有父子容器的概念，通过HierarcalBeanFactory接口定义了具有层级关系的容器体系。在抽象实现类AbstractApplicationContext类的内部，有一个表示父容器的成员变量。
>
>- ==子容器可以访问父容器中的Bean==
>- 父容器不可以访问子容器中的Bean
>
>```java
>/** Parent context */
>@Nullable
>private ApplicationContext parent;
>```

跟进源码：

```java
public ClassPathXmlApplicationContext(
  String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
  throws BeansException {

  // 设置父容器
  super(parent);
  // 设置xml文件的路径
  setConfigLocations(configLocations);
  if (refresh) {
    // 启动Spring容器
    refresh();
  }
}
```



2. 启动容器的入口refresh()

该方法定义在AbstractApplicationContext类中的模板方法，==定义了容器启动的基本流程，并留下钩子方法供子类进行扩展==。

以refresh命名，是为了形象地表示容器可以被重启这层含义。为了防止并发环境下多个线程同时启动IoC容器，整个过程使用同步代码块来进行同步。

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
  synchronized (this.startupShutdownMonitor) {
    // 刷新前的预处理
    prepareRefresh();

    // 创建DefaultListableBeanFactory，用来加载BeanDefinition
    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

    // 准备 bean工厂
    prepareBeanFactory(beanFactory);

    try {
      // 在上下文子类中对bean工厂进行后处理
      postProcessBeanFactory(beanFactory);

      // 调用在上下文中注册为bean的 工厂处理器
      invokeBeanFactoryPostProcessors(beanFactory);

      // 注册拦截bean创建的 BeanPostProcessor
      registerBeanPostProcessors(beanFactory);

      // 为此上下文初始化消息源
      initMessageSource();

      // 为此上下文初始化事件多播器
      initApplicationEventMulticaster();

      // 在特定上下文子类中初始化其他特殊bean
      onRefresh();

      // 检查侦听器bean并注册它们
      registerListeners();

      // 实例化所有剩余的单例（非懒加载）
      finishBeanFactoryInitialization(beanFactory);

      // 最后一步：发布相应的事件
      finishRefresh();
    }

    catch (BeansException ex) {
      if (logger.isWarnEnabled()) {
        logger.warn("Exception encountered during context initialization - " +
                    "cancelling refresh attempt: " + ex);
      }

      // 销毁已创建的单例以避免资源悬空。
      destroyBeans();

      // 重置active标志设置为false
      cancelRefresh(ex);

      // 将异常传播给调用者
      throw ex;
    }

    finally {
      resetCommonCaches();
    }
  }
}
```





















#### IoC容器及如何获取对象间的依赖关系

Spring中提供了两种IoC容器：

- `BeanFactory`：基础类型IoC容器，提供完整的IoC服务支持，==默认采用延迟初始化策略==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。
- `ApplicationContext`：除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等，==ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成==。ApplicationContext要求更多的系统资源，在启动时就完成所有初始化。

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpp4jnx1suj329q0auglv.jpg" style="zoom:100%">

无论使用哪种容器，都需要通过某种方式告诉容器关于对象依赖的信息。spring支持四种方式：

- 通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系；
- ==通过XML文件格式来记录对应信息==；
- 通过编写代码的方式来注册这些对应信息；
- ==通过注解方式来注册这些对应信息==；

> **那么容器（`BeanFactory`）怎么从xml配置文件中得到对象依赖的信息呢？**
>
> ---
>
> 在BeanFactory容器中，==每一个注入对象都对应一个BeanDefinition实例对象==（负责保存注入对象的所有必要信息，包括对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等）。
>
> 当客户端向BeanFactory请求相应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例。

>**那么BeanDefinition实例对象的信息是从哪儿而来的呢？**
>
>---
>
>专门加载解析配置文件的类——`BeanDefinitionReader`，对应到xml配置文件，就是其子类`XmlBeanDefinitionReader`（负责读取Spring指定格式的XML配置文件并解析，之后将解析后的文件内容映射到相应的BeanDefinition）

>**Bean的定义**
>
>---
>
>- 类中所有的属性都必须封装，即private声明；
>- 封装的属性如果需要被外部所操作，则必须编写对应的getter、setter方法；
>- 一个JavaBean中至少存在一个无参构造方法。
>
>Spring中Bean是一个被==实例化==，==组装==，并==通过Spring IoC容器所管理==的对象。这些bean是由用容器提供的配置元数据创建的。可以采用XML配置文件来管理和配置Bean信息。
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
><beans xmlns="http://www.springframework.org/schema/beans"
>       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
>  <bean id="user" class="com.wgs.spring.bean.User"></bean>
></beans>
>```
>
>`<beans>`是根节点，下面可包含多个`<bean>`子节点。
>
>常见属性：
>
>| 属性            | 描述                                                         |
>| --------------- | ------------------------------------------------------------ |
>| id              | 注册到容器的对象都有一个唯一的id值，如id="user"，这个id值使其表示的bean与其他bean区分开来。 |
>| name            | 可以用name属性来指定bean的别名。使用<u>逗号</u>、<u>空格</u>或<u>冒号</u>等分割指定多个name。 |
>| class           | 每个注册到容器的bean都需要通过class属性指定其类型。          |
>| scope           |                                                              |
>| constructor-arg | 用来注入依赖关系                                             |

>**Bean的类型**
>
>---
>
>- XML（通常使用构造方法注入与setter注入）
>  - `<constructor-arg type="" value="">`
>  - `<property name = "" value="">`
>- Annotation
>- Class
>- Properties
>- YML

>**Bean的作用域**
>
>---
>
>- `singleton`（默认）
>- prototype
>- request
>- session
>- global session