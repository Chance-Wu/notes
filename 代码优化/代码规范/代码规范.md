### 1. 日志规范

如下面这段代码中的日志：

```java
public Result execRule(RuleReq req) {
    try {
        logger.info("执行服务规则 req：{}", JSON.toJSONString(req));
        // 业务流程
        return Result.buildSuccess();
    } catch (Exception e) {
        logger.error("执行服务规则失败", e);
        return Result.buildError(e);
    }
}
```

- 看似没什么问题，但在这段异常代码中，没有打方法的入参信息。如果方法异常时只是抛出一些异常栈信息，那么是很难定位具体的由此调用触发的。
- 另外如果你的系统监控服务，没有类似方法跟踪ID的功能，最好还需要在日志中把本次调用具有标识性的id，作为查询条件打到日志中。

修改后的日志：

```java
public Result execRule(RuleReq req) {
    try {
        logger.info("执行服务规则{}开始 req：{}", req.getrId(), JSON.toJSONString(req));
        // 业务流程
        logger.info("执行服务规则{}完成 res：{}", req.getrId(), "业务流程，必要的结果信息");
        return Result.buildSuccess();
    } catch (Exception e) {
        logger.error("执行服务规则{}失败 req：{}", req.getrId(), JSON.toJSONString(req), e);
        return Result.buildError(e);
    }
}
```

### 2. 单元测试

单测？覆盖率？写代码不是写完就可以了吗？

当然不是，你写的代码你需要保证它能你跑通你所有的流程节点，确保这份功能是没有问题的，才能提交给测试，否则来回反复，耗时耗力。这也就是写单测的目的！甚至好一点的研发可以通过单测驱动开发，在这个阶段能把一些共用的方法合并、抽离，避免过多的冗余方法。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giyb4pssnrj30xn0crwfm.jpg" style="zoom:200%">

- 单测完整基本也就是代码的健壮性更好。
- 很多公司中一般都会要求单测覆盖率超过多少，否则不允许编译提交的，还有插件可以和Jenkins配合使用。

### 3. 分支规范

在互联网中，往往一个系统需要几个人维护，并同时进行开发。一般这里会包括；master分支、test分支、本次需求的分支，有这么多分支怎么用呢，如下：

1. ==master分支，是主分支，也是上线分支，不允许在上面直接修改代码==。
2. test分支，是测试环境分支，==每个人都需要把自己开发完的分支，提测后合并到test分支，交由测试验证==。
3. ==需求分支，也是个人开发的分支==，同一个需求下，大家在这个分支写代码，当然也可能这个系统模块的分支就一个人在开发。

> 重点：如果有人不遵守分支规范或者压根没概念，把自己的需求代码写在test分支上，并且是多次修改提交都在test分支写。那么就危险了，严重会耽误上线；为什么？
>
> （1）test分支，是由大家把自己的代码合并过来共用的，那么这个分支就会包含2个或者更多的并行需求，当你需要上线的时候，需要把自己的代码合并到master，但test分支代码是不能合并到master的，那么多未知的内容，根本没有在上线范围。
>
> （2）那么你又想上线，又不能避开test分支，就需要把你写的代码，重新粘贴过去，这个时间成本非常大。
>
> （3）test分支，还随时有删除重新拉的可能，如果有人通知大家删除重新拉，那你的代码就会丢失。

### 4. 夹带需求

研发开发需求代码时候，*<u>有时候会额外加一些其他代码，而且这些代码可能跟本次需求并没有关系</u>*。那为什么会这样呢？

1. 以前留下来的bug，想修复下，但忘记告知测试
2. 在开发这个需求时，其他产品又找过来让加功能，并说功能很小，没有发邮件通知相关测试人员
3. 看到某块以前写的代码太乱了，就想着优化下，自信心很高，不必告诉测试

那这时候你提交的代码，如果不在测试范围又出了问题，只能研发自己抗。并且在所有的研发团队，几乎是不会让夹带需求上线的，这样的做完了不算功劳，做出了问题还会被骂。

### 5. 异常流程

我们编程很多时候都是在处理异常流程，正常流程往往并不难，难的是分析出这段开发的代码有多少异常流程有没有处理。﻿

那么，会有哪些异常呢？

- 支付成功MQ消息发送失败，需要worker补偿
- PRC接口调用失败，网络超时，实际成功
- 接口幂等性，多次调用结果一致性﻿

等等，这些都是异常流程，尤其在一些交易提现环节，会出现各种异常，那么不可能把这些异常都反馈用户展示到界面。而是要有一些非常友好的提示，并且在服务端的流程里，有一定的补偿机制，来保证最终的调用成功，或者逆反。

### 6. 代码成坨

很多时候研发写代码，根本不考虑是否要扩展，总之一个类 + 几十行ifelse，能搞定所有需求。等下次在开发类似的，就粘贴过去再修修补补，能用就行。

缺少写出良好代码的研发，一方面是经历有限，另外一方面是学了很多理论但是不好落地。比如设计模式，但自己实际写代码的时候还是很晕。

《重学Java设计模式》，全书共计22个真实业务场景对应59组案例工程、编写了18万字271页的PDF、包含交易、营销、秒杀、中间件、源码等22个真实场景。

### 7. SQL性能

`select * from table where status = 1 limit 200;`

这是一段定时任务扫描库表的SQL，这段sql会定时扫库，将库表中状态是1的扫描出来进行处理，每次扫描200行。有什么问题吗？

- ==扫描必要字段即可==，不需要全部字段。
- 这段sql会越来越慢，即使状态字段加了索引。因为status并不能大量排掉其他状态字段，随着数据越来越多依然是全表扫描。

> 优化:
>
> 先根据状态查询到符合条件的最小的id，之后再sql的查询条件中添加id > xx，即可。另外如果你的任务需要多个worker扫描，增加效率，可以增加门牌号设计，提升扫描效率。如下：

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giybt71u2oj30q10hwwg7.jpg" style="zoom:80%">

