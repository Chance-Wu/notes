#### 1. 同步阻塞 IO（BIO）（blocking IO）

---

**在 Linux 中，默认情况下所有的 socket 都是 blocking 的**。

应用进程发起 IO 系统调用后，应用进程被阻塞，转到内核空间处理。之后，内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个 IO 处理完毕后返回进程。最后应用的进程解除阻塞状态，运行业务逻辑。

系统内核处理 IO 操作分为两个阶段——==等待数据==和==拷贝数据==。而在这两个阶段中，应用进程中 IO 操作的线程会一直都处于阻塞状态，**如果是基于 Java 多线程开发，那么每一个 IO 操作都要占用线程，直至 IO 操作结束**。



#### 2. 同步非阻塞 IO（NIO）

---



#### 3. IO 多路复用（IO multiplexing）

---

多路复用 IO 是在高并发场景中使用最为广泛的一种 IO 模型，如 Java 的 NIO、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的 `Reactor 模式`也是基于此类 IO 模型。

IO 多路复用
多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。
==多个网络连接的 IO 可以注册到一个复用器（select）上==，当用户进程调用了 select，那么整个进程会被阻塞。
同时，内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。
这个时候用户进程再调用 read 操作，将数据从内核中拷贝到用户进程。

当用户进程发起了 select 调用，进程会被阻塞，当发现该 select 负责的 socket 有准备好的数据时才返回，之后才发起一次 read，

- 坏处
  整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。
- 好处
  用户可以在一个线程内同时处理多个 socket 的 IO 请求。
  用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

好比几个人一起去餐厅吃饭，专门留了一个人在餐厅排号等位，其他人就去逛街了，等排号的朋友通知可以吃饭就直接去享用了。



#### 4. 异步非阻塞 IO（AIO）

---



#### 为什么说阻塞 IO 和 IO 多路复用最为常用？

---

在网络 IO 的应用需要考虑

- 系统内核的支持
  大多数系统内核都会支持阻塞 IO、非阻塞 IO 和 IO 多路复用，但像信号驱动 IO、异步 IO，只有高版本的 Linux 系统内核才会支持
- 编程语言的支持
  无论 C++ 还是 Java，在高性能的网络编程框架的编写上，大多数都是**基于 Reactor 模式**，其中最为典型的便是 Java 的 Netty 框架，而 Reactor 模式是基于 IO 多路复用的。当然，在非高并发场景下，同步阻塞 IO 是最为常见的

这两种 IO 模型，已经可以满足绝大多数网络 IO 的应用场景。