### 记录Log的基本原则

#### 1. 日志级别划分

---

| **Log4j、slf4j**安全 | **使用场景**框架                                             |
| -------------------- | ------------------------------------------------------------ |
| error                | 问题已经影响到软件的正常运行，而且软件不能自行恢复到正常的运行状态，此时须要输出该级别的错误日志。 |
| warn                 | 与业务处理相关的失败，这次失败不影响下次业务的执行，一般的结果为外部的输入不能得到指望的结果。 |
| info                 | 系统运行期间的系统运行状态变化，或关键业务处理记录等用户或管理员在系统运行期间关注的一些信息。<br>系统配置、系统运行环境信息，有助于安装实施人员检查配置是否正确。 |
| debug                | 软件调试信息，开发人员使用该级别的日志发现程序运行中的一些问题，排除故障。 |
| trace                | 基本同上，但显示的信息更详尽。                               |



#### 2. 日志对性能影响

---

无论多么优秀的日志工具，在日志输出时总会对性能产生或多或少的影响，为了将影响下降到最低，有如下几个准则需要遵照：

1. 如何建立Logger实例：建立Logger实例是否static的区别
2. 判断日志级别
   1. 对于能够预见的会频繁产生的日志输出，好比for、while循环，按期执行的job等，建议先使用if对日志级别进行判断后再输出。
   2. 对于日志输出内容须要复杂的序列化，或输出的某些信息获取成本较高时，须要对日志级别进行判断。好比日志中须要输出用户名，而用户名须要在日志输出时从数据库获取，此时就须要先判断一下日志级别，看看是否有必要获取这些信息。
   3. 优先使用参数，减小字符串拼接：使用参数的方式输出日志信息，有助于在性能和代码简洁之间取得平衡。当日志级别限制输出该日志时，参数内容将不会融合到最终输出中，减小了字符串的拼接，从而提高执行效率。



#### 3. 何时输出日志

---

##### 3.1 系统启动参数、环境变量

系统启动的参数、配置、环境变量、System.Properties等信息对于软件的正常运行相当重要，这些信息的输出有助于安装配置人员经过日志快速定位问题，因此程序有必要在启动过程当中把使用到的关键参数、变量在日志中输出出来。在输出时须要注意，不是一股脑的所有输出，而是将软件运行涉及到的配置信息输出出来。好比，若是软件对jvm的内存参数比较敏感，对最低配置有要求，那么就须要在日志中将-Xms -Xmx -XX:PermSize这几个参数的值输出出来。

##### 3.2 异常的捕获

在捕获异常处输出日志。

##### 3.3 函数得到期望以外的结果时

一个函数，尤为是供外部系统或远程调用的函数，一般都会有一个指望的结果，但若是内部系统或输出参数发生错误时，函数将没法返回指望的正确结果，此时就须要记录日志，日志的基本一般是warn。须要特别说明的是，这里的指望以外的结果不是说没有返回就不须要记录日志了，也不是说返回false就须要记录日志。好比函数：isXXXXX()，不管返回true、false记录日志都不是必须的，可是==若是系统内部没法判断应该返回true还是false时，就须要记录日志，而且日志的级别应该至少是warn==。

##### 3.4 关键操作

关键操作的日志通常是INFO级别，若是数量、频度很高，能够考虑使用DEBUG级别。如下是一些关键操作的举例：

- 删除：删除一个文件、删除一组重要数据库记录……
- 添加：和外系统交互时，收到了一个文件、收到了一个任务……
- 处理：开始、结束一条任务……



#### 4. 日志输出的内容

---

- ERROR：错误的简短描述，和该错误相关的关键参数，若是有异常，要有该异常的StackTrace。
- WARN：告警的简短描述，和该错误相关的关键参数，若是有异常，要有该异常的StackTrace。
- INFO：言简意赅地信息描述，若是有相关动态关键数据，要一并输出，好比相关ID、名称等。
- DEBUG：简单描述，相关数据，若是有异常，要有该异常的StackTrace。



#### 5. 何时使用J2SE自带的日志

---

一般使用 `slf4j` 或 `log4j` 这两个工具记录日志，那么还须要使用J2SE的日志框架吗？固然须要，在编写一些通用的工具类时，为了减小对第三方的jar包的依赖，首先要考虑使用 java.util.logging。

考虑到slf4j等日志框架提供了日志bridge工具，为java.util.logging提供了Handler，因此普通应用的开发过程当中也能够考虑使用J2SE自有日志，这样不但能够减小项目的编译依赖，同时在应用实施时能够更灵活的选择日志的输出工具包。



### 典型问题分析

#### 1. 该用日志的地方不用

---

对异常的处理直接使用e.printStackTrace()显然是有问题的，正确的作法是：要么经过日志方式输出错误信息，要么直接抛出异常，要么建立新的自定义异常抛出。

另：对于静态工具类函数中的异常处理，最简单的方式就是不捕获、不记录日志，直接向上抛出，若是认为异常类型太多，或者意义不明确，能够抛出自定义异常类的实例。



#### 2. 啰嗦重复、没有重点

---

首先上面不该有error级别的日志。

==日志系统是一个多线程公用的系统，在两行日志输出之间有可能会被插入其余线程的日志记录，不会按照咱们的意愿顺序输出==，后面有更典型的例子。



#### 3. 日志和异常处理的关系

---

既然将异常捕获并记录的日志，就不该该从新将一个如出一辙的异常再次抛出去了。若是将异常再次抛出，那在上层确定还须要对该异常进行处理，并记录日志，这样就重复了。若是没有特别缘由，此处不该该捕获异常。



#### 4. System.out方式的日志

---

==对于临时调试日志，建议在日志的输出信息中添加一些特殊的连续字符==，也能够用本身的名称、代号，这样能够在调试完毕后，提交代码以前，方便地找到全部临时代码，一并删除。



#### 5. 日志信息不明确

---

既没有记录任务id，也没有任务名称，软件部署后发现错误后，根据该日志记录不能确认哪一条任务错误，给进一步的分析缘由带来困难。



#### 6. 忘记日志输出是多线程公用的

---

若是有另一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。==正确的作法应是将这些信息放到一行==，若是须要换行能够考虑使用“\r”，若是内容较多，考虑增加if (logger.isDebugEnabled())进行判断。



#### 7. 多个参数的处理

---

对于多个参数的日志输出，能够考虑：

public void debug(String format, Object... arguments);

可是==在使用多参时，会建立一个对象数组==，也会有必定的消耗，为此，在对性能敏感的场景，能够==增加对日志级别的判断==。



### 关于日志打印中的占位符的使用

```java
public void error(String msg);
```

当error中只有一个参数时，默认是String类型。

当使用两个参数，并且第一个参数中使用占位符的时候：

```java
public void error(String format, Object... arguments);
```

`logger.error("使用占位符 {}",e);`

输出结果是：{}......

占位符失效，不过也输出了异常信息；通过查看源码，发现调用的并非是public void error(String format, Object arg);而是调用的public void error(String msg, Throwable t);所以猜测新版本应该会自动识别第二个参数的类型，如果是一个对象（dto），则会调用toString方法打印，但是如果是一个异常，则会调用public void error(String msg, Throwable t);方法。

使用上述方法时，打印异常方法：`logger.error("使用,:",e);`

接着看多个参数的时候：

```java
public void error(String format, Object arg1, Object arg2);
```

这个时候又会输出什么呢？
重点重点！！
当使用

```java
logger.error("多参数输出:msg：{} err：{} ", dto, e);
```

当异常信息作为最后一个参数的时候，输出。

异常信息也是正常打印出来，但是源码显示这是的异常信息是一个object对象，看来和上面单独使用占位符一样，会自动将异常信息归为Throwable对象；
当异常信息不放在最后的时候呢？

通过实践，得出结论：
==当使用error或者warn级别打印异常时，只要将异常信息作为最后一个参数，不论使用还是不使用占位符，都不会影响异常信息的输出，只不过占位符不会生效。==